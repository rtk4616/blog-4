<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>wxsm&#39;s blog</title><link>https://blog.wxsm.space</link><description>wxsm&#39;s personal blog.</description><atom:link href="https://blog.wxsm.space/feed.xml" rel="self" type="application/rss+xml" /><item><title>React node starter</title><description><![CDATA[<!-- 「」 -->
<p>出于某种需求搭建了一个非常简单的、基于 React / Node / Express / MongoDB 的 starter 工程：<a href="https://github.com/wxsms/react-node-starter">wxsms/react-node-starter</a>，旨在简化小型或中小型项目开发流程，关注实际业务开发。</p>
<p>目前所实现的内容有：</p>
<ul>
<li>前后端完全分离</li>
<li>热重载</li>
<li>用户注册、登录</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/5960988/46710580-0ca53f00-cc7b-11e8-8328-f49e0a14c601.png" alt=""></p>
<p>麻雀虽小，五脏俱全。下面记录搭建过程。</p>
<!-- more -->
<h2 id="react">React <a class="header-anchor" href="#react" aria-hidden="true">&#128279;</a></h2>
<p>整个项目实际上是一个使用 <a href="https://github.com/facebook/create-react-app">facebook/create-react-app</a> 创建出来的架构。</p>
<pre><code>$ npm install create-react-app -g
$ create-react-app react-node-starter
</code></pre>
<p>如此就完事了。创建出来的项目会包含 React 以及 React Scripts，Webpack 等配置都已经包含在了 React Scripts 中。执行 <code>npm start</code> 会打开 <a href="http://localhost:3000">http://localhost:3000</a>，但是有一个遗憾之处是，这里提供的热重载不是 HMR，而是整个页面级别的重新加载。</p>
<h2 id="node-express">Node &amp; Express <a class="header-anchor" href="#node-express" aria-hidden="true">&#128279;</a></h2>
<p>要在前端项目的基础上加入 Node 服务端，由于项目的极简性质，需要考虑一个问题是：如何在不跨域、不加入额外反代的情况下完成这个任务。有幸的是 create-react-app 贴心地加入了 <a href="https://github.com/facebook/create-react-app/blob/master/packages/react-scripts/template/README.md#proxying-api-requests-in-development">Proxying API Requests in Development</a> 功能，只需要给 <code>package.json</code> 加入一对键值，就可以达成目的：</p>
<pre><code>&quot;proxy&quot;: &quot;http://localhost:3001&quot;
</code></pre>
<p>这样一来，在开发环境下，前端会自动将 <code>Accept</code> Header 不包含 <code>text/html</code> 的请求（即 Ajax 请求）转发到 3001 端口，那么我们只需要将服务端部署到 3001 端口就好了。</p>
<p>至于生产环境则无此烦恼，只需要将 <code>npm run build</code> 打包出来的文件当做静态资源，服务器依旧照常启动即可。</p>
<p>在项目根目录下新建 <code>server</code> 文件夹，用来存放服务端代码。</p>
<p><code>server/server.js</code>:</p>
<pre><code class="language-javascript"><span class="hljs-meta">#!/usr/bin/env node</span>

<span class="hljs-keyword">const</span> app = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./app'</span>);
<span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);

<span class="hljs-keyword">const</span> port = <span class="hljs-number">3001</span>;
app.set(<span class="hljs-string">'port'</span>, port);

<span class="hljs-keyword">const</span> server = http.createServer(app);

server.listen(port);
</code></pre>
<p><code>server/app.js</code>:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);
<span class="hljs-keyword">const</span> session = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express-session'</span>);
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);
<span class="hljs-keyword">const</span> logger = <span class="hljs-built_in">require</span>(<span class="hljs-string">'morgan'</span>);
<span class="hljs-keyword">const</span> cookieParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">'cookie-parser'</span>);
<span class="hljs-keyword">const</span> bodyParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">'body-parser'</span>);

<span class="hljs-keyword">const</span> router = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./router'</span>);

<span class="hljs-keyword">const</span> app = express();

app.use(logger(<span class="hljs-string">'dev'</span>));
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({<span class="hljs-attr">extended</span>: <span class="hljs-literal">false</span>}));
app.use(cookieParser());
app.use(session({
  <span class="hljs-attr">secret</span>: <span class="hljs-string">'test'</span>,
  <span class="hljs-attr">resave</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">saveUninitialized</span>: <span class="hljs-literal">true</span>
}));
app.use(express.static(path.join(__dirname, <span class="hljs-string">'../build'</span>)));
app.use(<span class="hljs-string">'/public'</span>, express.static(path.join(__dirname, <span class="hljs-string">'../public'</span>)));
app.use(<span class="hljs-string">'/api'</span>, router);
app.get(<span class="hljs-string">'*'</span>, (req, res) =&gt; {
  res.sendFile(<span class="hljs-string">'build/index.html'</span>, {<span class="hljs-attr">root</span>: path.join(__dirname, <span class="hljs-string">'../'</span>)});
});

<span class="hljs-built_in">module</span>.exports = app;
</code></pre>
<p>就是一个典型的 Express HTTP 服务器。当处于开发环境时，<code>build</code> 目录只存在于内存中。执行生产构建脚本后，会打包至硬盘，因此上面的代码可以同时覆盖到开发与生产环境，无需再做额外配置。</p>
<p>准备完成后，将 <code>start</code> 脚本更新为：</p>
<pre><code>&quot;start&quot;: &quot;concurrently \&quot;react-scripts start\&quot; \&quot;nodemon server/server.js\&quot;&quot;
</code></pre>
<p>即可。其中：</p>
<ul>
<li><a href="https://github.com/kimmobrunfeldt/concurrently">concurrently</a> 是为了在一个终端窗口中同时执行前端与服务端命令</li>
<li><a href="https://github.com/remy/nodemon">nodemon</a> 是为了实现服务端热重载</li>
</ul>
<p>熟悉 Node.js 的应该对这两个工具都不陌生。</p>
<p>这里有一个对原项目作出改变的地方是，出于尽可能简化的目的，将 <code>registerServiceWorker.js</code> 文件及其引用移除了，同时使用 Express 来对 <code>public</code> 文件夹做静态资源路由。</p>
<p>如此一来，重新执行 <code>npm start</code> 会发现 Express 服务器能够按照预期运行了。</p>
<h2 id="mongodb">MongoDB <a class="header-anchor" href="#mongodb" aria-hidden="true">&#128279;</a></h2>
<p>建好 Express 整体框架后，加入 MongoDB 的相关支持就非常简单了。安装 <a href="https://mongoosejs.com/">mongoose</a>，然后在 <code>server</code> 目录下新建一个 <code>models</code> 文件夹用来存放 Model，然后新建一个 db 初始化文件：</p>
<p><code>server/mongodb.js</code></p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mongoose'</span>);
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

mongoose.connect(<span class="hljs-string">'mongodb://localhost:27017'</span>);

fs.readdirSync(path.join(__dirname, <span class="hljs-string">'/models'</span>)).forEach(<span class="hljs-function"><span class="hljs-params">file</span> =&gt;</span> {
  <span class="hljs-built_in">require</span>(<span class="hljs-string">'./models/'</span> + file);
});
</code></pre>
<p>最后将此文件在 <code>app.js</code> 中引用即可：</p>
<pre><code class="language-javascript"><span class="hljs-built_in">require</span>(<span class="hljs-string">'./mongodb'</span>);
</code></pre>
<h2 id="session-auth">Session Auth <a class="header-anchor" href="#session-auth" aria-hidden="true">&#128279;</a></h2>
<p>本项目采用 Session 鉴权，那么在前后端分离的项目中，无法通过服务端模板来同步赋值，因此有一个问题就是如何让前端项目获取到当前登录的角色。出于尽可能简单的目的，最终做法是在页面入口初始化时向服务端发起请求获取当前登录角色，获取过程中显示 Loading 界面。用户信息获取成功后才开始真正的路由渲染，如果具体页面鉴权失败则重定向回登录页面。</p>
<h2 id="antd">AntD <a class="header-anchor" href="#antd" aria-hidden="true">&#128279;</a></h2>
<p>前端选用 <a href="https://github.com/ant-design/ant-design">Ant Design</a> 作为 UI 框架，为了更方便地使用它，参考其文档教程，这里做一点小小的配置，首先安装 <a href="https://github.com/timarney/react-app-rewired">react-app-rewired</a> 与 <a href="https://www.npmjs.com/package/babel-plugin-import">babel-plugin-import</a>：</p>
<pre><code>$ yarn add react-app-rewired babel-plugin-import
</code></pre>
<p>修改 <code>package.json</code> 中的脚本，将 <code>react-scripts</code> 全都替换为 <code>react-app-rewired</code>：</p>
<pre><code class="language-json">{
   <span class="hljs-attr">"scripts"</span>: {
     <span class="hljs-attr">"start"</span>: <span class="hljs-string">"concurrently \"react-app-rewired start\" \"nodemon server/server.js\""</span>,
     <span class="hljs-attr">"build"</span>: <span class="hljs-string">"react-app-rewired build"</span>,
     <span class="hljs-attr">"test"</span>: <span class="hljs-string">"react-app-rewired test --env=jsdom"</span>,
     <span class="hljs-attr">"eject"</span>: <span class="hljs-string">"react-app-rewired eject"</span>
   }
}
</code></pre>
<p>然后在项目根目录中创建 <code>config-overrides.js</code> 文件：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> {injectBabelPlugin} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-app-rewired'</span>);

<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">override</span> (<span class="hljs-params">config, env</span>) </span>{
  config = injectBabelPlugin(
    [<span class="hljs-string">'import'</span>, {<span class="hljs-attr">libraryName</span>: <span class="hljs-string">'antd'</span>, <span class="hljs-attr">libraryDirectory</span>: <span class="hljs-string">'es'</span>, <span class="hljs-attr">style</span>: <span class="hljs-string">'css'</span>}],
    config,
  );
  <span class="hljs-keyword">return</span> config;
};
</code></pre>
<p>这样做的好处是，CSS 可以按需加载，并且引用 AntD 组件更方便了，如：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> {Button} <span class="hljs-keyword">from</span> <span class="hljs-string">'antd'</span>;
</code></pre>
<h2 id="redux">Redux <a class="header-anchor" href="#redux" aria-hidden="true">&#128279;</a></h2>
<p>安装 Redux 全家桶：</p>
<pre><code>$ yarn add redux redux-thunk react-redux immutable
</code></pre>
<p>然后按照 <a href="https://codesandbox.io/s/9on71rvnyo">示例项目</a> 插入到项目中去即可。区别是为了在 action 中执行异步操作加入了一个中间件 <a href="https://github.com/reduxjs/redux-thunk">redux-thunk</a>，以及原示例没有使用 <a href="https://facebook.github.io/immutable-js/">Immutable.js</a>，也在本项目中加入了。</p>
<p><code>src/redux/store.js</code>:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> {createStore, applyMiddleware} <span class="hljs-keyword">from</span> <span class="hljs-string">'redux'</span>;
<span class="hljs-keyword">import</span> thunk <span class="hljs-keyword">from</span> <span class="hljs-string">'redux-thunk'</span>;
<span class="hljs-keyword">import</span> rootReducer <span class="hljs-keyword">from</span> <span class="hljs-string">'./reducers/index'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> createStore(
  rootReducer,
  applyMiddleware(thunk)
);
</code></pre>
]]></description><pubDate>Wed Oct 10 2018 02:36:09 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/react-node-starter</link><guid isPermaLink="true">https://blog.wxsm.space/p/react-node-starter</guid></item><item><title>Unicode substring</title><description><![CDATA[<p>最近遇到一个问题：在做字符串截取操作时，如果字符串中包含了 emoji 字符（一个表情占多个 unicode 字符），而碰巧又把它截断了，程序会出错。在 ReactNative App 下的具体表现就是崩溃。由于以前做的是网页比较多，基本没有输入表情字符的案例，而在手机上就不一样了，因此这个问题还是第一次发现。</p>
<p>比如说：</p>
<pre><code class="language-javascript"><span class="hljs-string">'😋Emoji😋'</span>.substring(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 😋</span>
</code></pre>
<p>因此，如果对这个字符串做 <code>substring(0, 1)</code> 操作，就会截取到一个未知字符。</p>
<!-- more -->
<p>中间的探索过程就不谈了，Google 了一下解决方案，以及咨询同事们以后，发现最简单的办法是通过 <code>lodash</code> 自带的 <code>toArray</code> 方法，先将它转为数组，然后将整个逻辑改为数据的截取操作，最后再转回字符串。</p>
<pre><code class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">safeSubStr</span> (<span class="hljs-params">str, start, end</span>) </span>{
  <span class="hljs-keyword">const</span> charArr = _.toArray(str);
  <span class="hljs-keyword">return</span> _.slice(charArr, start, end).join(<span class="hljs-string">''</span>);
}
</code></pre>
<p>实际上解决问题的是 <code>_.toArray</code>，它帮我们把表情字符正确地截了出来：</p>
<pre><code class="language-javascript">_.toArray(<span class="hljs-string">'😋Emoji😋'</span>) <span class="hljs-comment">// ["😋", "E", "m", "o", "j", "i", "😋"]</span>
</code></pre>
<p>其实我也比较好奇它是怎么做的，通过观察源码，发现了真正的解决方案：</p>
<pre><code class="language-javascript"><span class="hljs-comment">// lodash/_unicodeToArray.js</span>
<span class="hljs-comment">/** Used to compose unicode character classes. */</span>
<span class="hljs-keyword">var</span> rsAstralRange = <span class="hljs-string">'\\ud800-\\udfff'</span>,
    rsComboMarksRange = <span class="hljs-string">'\\u0300-\\u036f'</span>,
    reComboHalfMarksRange = <span class="hljs-string">'\\ufe20-\\ufe2f'</span>,
    rsComboSymbolsRange = <span class="hljs-string">'\\u20d0-\\u20ff'</span>,
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = <span class="hljs-string">'\\ufe0e\\ufe0f'</span>;

<span class="hljs-comment">/** Used to compose unicode capture groups. */</span>
<span class="hljs-keyword">var</span> rsAstral = <span class="hljs-string">'['</span> + rsAstralRange + <span class="hljs-string">']'</span>,
    rsCombo = <span class="hljs-string">'['</span> + rsComboRange + <span class="hljs-string">']'</span>,
    rsFitz = <span class="hljs-string">'\\ud83c[\\udffb-\\udfff]'</span>,
    rsModifier = <span class="hljs-string">'(?:'</span> + rsCombo + <span class="hljs-string">'|'</span> + rsFitz + <span class="hljs-string">')'</span>,
    rsNonAstral = <span class="hljs-string">'[^'</span> + rsAstralRange + <span class="hljs-string">']'</span>,
    rsRegional = <span class="hljs-string">'(?:\\ud83c[\\udde6-\\uddff]){2}'</span>,
    rsSurrPair = <span class="hljs-string">'[\\ud800-\\udbff][\\udc00-\\udfff]'</span>,
    rsZWJ = <span class="hljs-string">'\\u200d'</span>;

<span class="hljs-comment">/** Used to compose unicode regexes. */</span>
<span class="hljs-keyword">var</span> reOptMod = rsModifier + <span class="hljs-string">'?'</span>,
    rsOptVar = <span class="hljs-string">'['</span> + rsVarRange + <span class="hljs-string">']?'</span>,
    rsOptJoin = <span class="hljs-string">'(?:'</span> + rsZWJ + <span class="hljs-string">'(?:'</span> + [rsNonAstral, rsRegional, rsSurrPair].join(<span class="hljs-string">'|'</span>) + <span class="hljs-string">')'</span> + rsOptVar + reOptMod + <span class="hljs-string">')*'</span>,
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsSymbol = <span class="hljs-string">'(?:'</span> + [rsNonAstral + rsCombo + <span class="hljs-string">'?'</span>, rsCombo, rsRegional, rsSurrPair, rsAstral].join(<span class="hljs-string">'|'</span>) + <span class="hljs-string">')'</span>;

<span class="hljs-comment">/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */</span>
<span class="hljs-keyword">var</span> reUnicode = <span class="hljs-built_in">RegExp</span>(rsFitz + <span class="hljs-string">'(?='</span> + rsFitz + <span class="hljs-string">')|'</span> + rsSymbol + rsSeq, <span class="hljs-string">'g'</span>);

<span class="hljs-comment">/**
 * Converts a Unicode `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unicodeToArray</span>(<span class="hljs-params">string</span>) </span>{
  <span class="hljs-keyword">return</span> string.match(reUnicode) || [];
}

<span class="hljs-built_in">module</span>.exports = unicodeToArray;
</code></pre>
<p>一大堆正则就不谈了，也不知道它是从哪里找来的这些值，最后组装了一个 <code>reUnicode</code> 正则来实现 unicode 转数组。话又说回来，这么做会不会有性能问题呢？我表示比较担忧。好在项目里面需要这么做的场景不多，字符串也不长，可以如此暴力解决。如果换个场景，还真不好说。也许又需要一种更高效的解决方案了。</p>
]]></description><pubDate>Thu Sep 06 2018 06:46:40 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/unicode-substring</link><guid isPermaLink="true">https://blog.wxsm.space/p/unicode-substring</guid></item><item><title>失望</title><description><![CDATA[<!-- 「」 -->
<p>今年的 TI 本子到目前为止已经充了 ￥850 左右，770 级。</p>
<ul>
<li>不朽 1 没有开到极其珍稀（PA），其它齐全</li>
<li>不朽 2 齐全，一件极其珍稀（黑鸟）</li>
<li>不朽 3 没有开到极其珍稀（巫医），其它齐全</li>
<li>宝瓶 1 一轮，一件稀有额外（术士）</li>
<li>宝瓶 2 一轮，一件稀有额外（大屁股）</li>
</ul>
<p>战绩可以说非常不尽人意。虽然中途 V 社承认自己失误（被迫？）发了一次补偿，但依然没我。</p>
<p>现在每周就肝肝幽穴风云，肝肝代币，箱子开了马上又是一次轮回，感觉除了中看不中用的等级以外什么都没留下。想要的东西永远开不到，除了失望以外说不出别的感受来。</p>
<p>今天中午又开了一个箱子，依然是熟悉的啥都没有，突然就觉得好累，有点不想肝了。人生啊。</p>
]]></description><pubDate>Wed Aug 08 2018 06:32:16 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/disappointed</link><guid isPermaLink="true">https://blog.wxsm.space/p/disappointed</guid></item><item><title>Gitlab CI Setup</title><description><![CDATA[<!-- 「」 -->
<p>Gitlab 有一套内置的 CI 系统，相比集成 Jenkins 来说更加方便一些，用法也稍为简单。以下是搭建过程。</p>
<p>前置准备：须要准备一台用来跑 CI 任务的机器（可以是 Mac / Linux / Windows 之一）。</p>
<!-- more -->
<h2 id="gitlab-ciyml">创建 <code>.gitlab-ci.yml</code> 文件 <a class="header-anchor" href="#gitlab-ciyml" aria-hidden="true">&#128279;</a></h2>
<p>和 Github CI 一样，Gitlab CI 也使用 <a href="https://en.wikipedia.org/wiki/YAML">YAML</a> 文件来定义项目的整个构建任务。只要在需要集成 CI 的项目根目录下添加这份文件并写入内容，默认情况下 Gitlab 就会为此项目启用构建。</p>
<p>配置文档：<a href="https://docs.gitlab.com/ee/ci/yaml/README.html">https://docs.gitlab.com/ee/ci/yaml/README.html</a></p>
<p>一份较为完整的配置文件样例：</p>
<pre><code class="language-yaml"><span class="hljs-comment"># 指定 docker 镜像</span>
<span class="hljs-attr">image:</span> <span class="hljs-attr">node:9.3.0</span>

<span class="hljs-comment"># 为 docker 镜像安装 ssh-agent 以执行部署任务</span>
<span class="hljs-attr">before_script:</span>
<span class="hljs-bullet">  -</span> <span class="hljs-string">'which ssh-agent || ( apt-get update -y &amp;&amp; apt-get install openssh-client -y )'</span>
<span class="hljs-bullet">  -</span> <span class="hljs-string">eval</span> <span class="hljs-string">$(ssh-agent</span> <span class="hljs-bullet">-s)</span>
<span class="hljs-bullet">  -</span> <span class="hljs-string">echo</span> <span class="hljs-string">"$SSH_PRIVATE_KEY"</span> <span class="hljs-string">| tr -d '\r' | ssh-add - &gt; /dev/null
  - mkdir -p ~/.ssh
  - echo -e "Host *\n\tStrictHostKeyChecking no\n\n" &gt; ~/.ssh/config
  - chmod 700 ~/.ssh

# 定义构建的三个阶段
</span><span class="hljs-attr">stages:</span>
<span class="hljs-bullet">  -</span> <span class="hljs-string">build</span>
<span class="hljs-bullet">  -</span> <span class="hljs-string">test</span>
<span class="hljs-bullet">  -</span> <span class="hljs-string">deploy</span>

<span class="hljs-comment"># 定义可缓存的文件夹</span>
<span class="hljs-attr">cache:</span>
<span class="hljs-attr">  paths:</span>
<span class="hljs-bullet">    -</span> <span class="hljs-string">node_modules/</span>

<span class="hljs-comment"># 构建任务</span>
<span class="hljs-attr">build-job:</span>
<span class="hljs-attr">  stage:</span> <span class="hljs-string">build</span>
<span class="hljs-attr">  script:</span>
<span class="hljs-bullet">    -</span> <span class="hljs-string">"npm install"</span>
<span class="hljs-bullet">    -</span> <span class="hljs-string">"npm run build"</span>
<span class="hljs-attr">  tags:</span>
<span class="hljs-bullet">    -</span> <span class="hljs-string">node</span>

<span class="hljs-comment"># 测试任务</span>
<span class="hljs-attr">test-job:</span>
<span class="hljs-attr">  stage:</span> <span class="hljs-string">test</span>
<span class="hljs-attr">  script:</span>
<span class="hljs-bullet">    -</span> <span class="hljs-string">"npm install"</span>
<span class="hljs-bullet">    -</span> <span class="hljs-string">"npm run lint"</span>
<span class="hljs-bullet">    -</span> <span class="hljs-string">"npm test"</span>
<span class="hljs-attr">  tags:</span>
<span class="hljs-bullet">    -</span> <span class="hljs-string">node</span>

<span class="hljs-comment"># 部署任务</span>
<span class="hljs-attr">deploy-job:</span>
<span class="hljs-attr">  stage:</span> <span class="hljs-string">deploy</span>
<span class="hljs-attr">  only:</span>
<span class="hljs-bullet">    -</span> <span class="hljs-string">release</span>
<span class="hljs-attr">  script:</span>
<span class="hljs-bullet">    -</span> <span class="hljs-string">"npm install"</span>
<span class="hljs-bullet">    -</span> <span class="hljs-string">"npm run build"</span>
<span class="hljs-bullet">    -</span> <span class="hljs-string">ssh</span> <span class="hljs-string">user@host</span> <span class="hljs-string">"[any shell commands]"</span>
<span class="hljs-attr">  tags:</span>
<span class="hljs-bullet">    -</span> <span class="hljs-string">node</span>
</code></pre>
<p>整个构建过程基本上一目了然，比 Jenkins 简便很多。Gitlab CI 会按顺序执行 build / test / deploy 三个 stage 的任务，遇到出错即中止，并不再往下执行。同个 stage 中的多个任务会并发执行。需要注意的是，各个 stage 的工作空间是独立的。</p>
<p>其中 <code>$SSH_PRIVATE_KEY</code> 是在相应 Gitlab 项目中配置的一个 Secret Value，是构建机的 ssh 私钥。后面再谈。</p>
<p>将 <code>.gitlab-ci.yml</code> 文件推送到服务器后，打开项目主页，点击 Commit 记录，会发现构建任务启动并处于 pending 状态：</p>
<p><img src="https://docs.gitlab.com/ee/ci/quick_start/img/new_commit.png" alt="img"></p>
<p>点击构建图标，则可以进入到 CI 详情页面：</p>
<p><img src="https://docs.gitlab.com/ee/ci/quick_start/img/single_commit_status_pending.png" alt="img"></p>
<p>点击具体任务查看 log 则提示项目没有配置相应的 runner 来执行构建任务。也就是下一步要做的事情。</p>
<h2 id="gitlab-runner">搭建 Gitlab runner <a class="header-anchor" href="#gitlab-runner" aria-hidden="true">&#128279;</a></h2>
<p><a href="https://docs.gitlab.com/runner/">Gitlab runner</a> 是用来执行 CI 任务的客户端，它可以在一台机器上搭建，并且同时为多个项目服务。<a href="https://docs.gitlab.com/runner/install/">安装教程</a>。</p>
<p>安装好 runner 后，还要为机器安装 <a href="https://www.docker.com/community-edition">Docker</a>，用来作为具体构建的容器。</p>
<p>以上均安装完成后，就可以开始配置 runner 了。配置过程中需要用到的一些信息可以在下图位置找到（项目主页 -&gt; Settings -&gt; CI / CD -&gt; Runners settings）。</p>
<p><img src="https://docs.gitlab.com/ee/ci/quick_start/img/runners_activated.png" alt="img"></p>
<pre><code>$ sudo gitlab-runner register

Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com )
(填写上图位置的地址)

Please enter the gitlab-ci token for this runner
(填写上图位置的token)

Please enter the gitlab-ci description for this runner
[hostame] my-runner

Please enter the gitlab-ci tags for this runner (comma separated):
node

Please enter the executor: ssh, docker+machine, docker-ssh+machine, kubernetes, docker, parallels, virtualbox, docker-ssh, shell:
docker

Please enter the Docker image (eg. ruby:2.1):
node:latest
</code></pre>
<p>其中 description 与 tags 将来都可以在 Gitlab UI 中更改。注意 tag 必须与 <code>.gitlab-ci.yml</code> 中各个 job 指定的 tag 一致，这个 job 才会分配到这个 runner 上去。</p>
<p>如此一来则大功告成，回到 Gitlab UI，在 Runner settings 内可以看到配置好的 runner，并且可以执行任务了。</p>
<p><img src="https://docs.gitlab.com/ee/ci/quick_start/img/pipelines_status.png" alt="img"></p>
<h2 id="">遇到的问题 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h2>
<p>其实本地构建基本上都没什么问题，遇到的坑基本集中在 deploy 阶段，即远程到服务器上去发布的这一步。按照 Gitlab 提供的<a href="https://docs.gitlab.com/ee/ci/ssh_keys/">文档</a>，走完了所有的步骤后，构建机总是无法使用 private key 直接登录，而是必须输入密码登录。尝试了查看 ssh 日志，重启服务器 sshd 服务，修改文件夹权限等等，debug 了半天还是没有解决该问题。后来偶然发现在部署服务器上使用 sshd 开启一个新的服务，用新的端口即可顺利登录，也不知道是为什么。</p>
<p>更新：另外一个方法，可以使用 <code>sshpass</code> 命令来进行登录。用法：</p>
<ol>
<li>在 docker 镜像中安装 <code>sshpass</code><pre><code>$ which sshpass || ( apt-get update -y &amp;&amp; apt-get install sshpass -y )
</code></pre>
其中 <code>-y</code> 是为了防止安装过程中出现需要选择的项目，一律选 YES</li>
<li>在项目 CI 变量中设置 ssh 密码</li>
<li>使用 <code>sshpass</code> 复制文件，或登录远程服务器<pre><code># scp
$ SSHPASS=$YOUR_PASSWORD_VAR sshpass -e scp -r local_folder user@host:remote_folder&quot;
# ssh
$ SSHPASS=$YOUR_PASSWORD_VAR sshpass -e ssh user@host
</code></pre>
</li>
</ol>
]]></description><pubDate>Thu Jul 19 2018 06:22:36 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/gitlab-ci-setup</link><guid isPermaLink="true">https://blog.wxsm.space/p/gitlab-ci-setup</guid></item><item><title>中国药神</title><description><![CDATA[<!-- 「」 -->
<p>《我不是药神》是一部好电影。</p>
<p>影片最打动我的一段，是小吕请勇哥去他家吃饭的那几分钟。这些小人物倾家荡产，拼了命地活着，到底只不过就是为了一些「小事」而已。不然何苦呢？得了绝症的小吕幸福吗？从某个角度看，他非常幸福：有一个至死都不离不弃的爱人，还有一个至少到现在为止都健健康康的孩子。但生活就是这样残酷。</p>
<p>吃不起特效药的人，去抗议药厂卖天价药，对于不幸的患者来说，我命都快没了，管你是对是错呢？影片故意刻画了一个近乎反派立场的药厂，是不得已而为之，但我们要记住：真正对人类社会的发展做出贡献的是药厂。它卖天价药，卖任何价格，都没有问题，你永远不知道药厂为了第一片药付出了多少。至于吃不起，那是你的问题。就像影片说的一样：穷病，没法治。</p>
<p>影片从「病」这个角度，揭露出了绝大部分人生活在这个社会上的一些无奈。除非你有钱到刘强东这种程度，否则这个世界上总有你付不起的代价，这一刻是公平的。</p>
<p>这部电影好就好在，它选取了一个能够引发共鸣，但又值得深思的角度，同时把故事给讲好了。其实真的不难，真心希望它能够赚一笔大的，让大家以后都有样学样，多拍点有营养的东西。</p>
<p>PS. 毕导可以出来点评一下了，我猜这绝对又是境外势力的阴谋？</p>
]]></description><pubDate>Mon Jul 09 2018 06:48:13 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/dying-to-survive</link><guid isPermaLink="true">https://blog.wxsm.space/p/dying-to-survive</guid></item><item><title>Simplest Wechat Client on Linux</title><description><![CDATA[<p>微信没有为 Linux 提供桌面客户端，可用的替代方式有：</p>
<ol>
<li>使用<a href="https://wx.qq.com/">网页版微信</a></li>
<li>使用第三方客户端，如 <a href="https://github.com/geeeeeeeeek/electronic-wechat">electronic-wechat</a></li>
<li>自己动手，将网页版微信封装为桌面应用程序</li>
</ol>
<p>但是每种方式都有不尽人意的地方。网页版总是嵌入在浏览器中，用起来不太方便；第三方客户端安全性无法保证；自己做一个客户端又太麻烦。</p>
<p>然而，实际上还有一种更简单的方式：通过 Chrome 将网页直接转化为桌面应用。</p>
<p>步骤：</p>
<ol>
<li>使用 Chrome 打开<a href="https://wx.qq.com/">网页版微信</a></li>
<li>右上角设置，<code>More tools</code> -&gt; <code>Create shortcut...</code></li>
<li>然后就可以在 Chrome Apps 中找到微信了</li>
</ol>
<p>通过此方式创建的 Apps 同时拥有桌面应用的表现以及网页版的功能，并且可以将它固定到 Dock 栏，以及独立于浏览器运行，只能用「完美」两个字形容。</p>
<p>除微信外，其它缺少 Linux 客户端但有网页客户端的应用亦可如法炮制，如有道云笔记等。</p>
]]></description><pubDate>Mon Jun 11 2018 07:26:45 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/simplest-wechat-client-on-linux</link><guid isPermaLink="true">https://blog.wxsm.space/p/simplest-wechat-client-on-linux</guid></item><item><title>React Native Text Inline Image</title><description><![CDATA[<p>原文地址（需科学上网）：<a href="https://medium.com/@yloeza/react-native-text-inline-image-6055dabd9399">medium.com</a></p>
<p>RN 版本：0.49</p>
<!-- 「」 -->
<p>图文混排（在文字中插入图片，并保持正确换行）是客户端普遍的需求，但在 RN 中它有一点问题，具体表现在 Android 平台下图片显得异常的小，并且相同系统不同设备之间的表现也不尽一样，而 ios 则表现正常。</p>
<!-- more -->
<p>就像这样：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> React, { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> {
  AppRegistry,
  StyleSheet,
  Text,
  View,
  Image,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'react-native'</span>;

<span class="hljs-keyword">const</span> styles = StyleSheet.create({
  <span class="hljs-attr">container</span>: {
    <span class="hljs-attr">flex</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">paddingTop</span>: <span class="hljs-number">50</span>,
    <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">'#f6f7f8'</span>,
  },
  <span class="hljs-attr">image</span>: {
    <span class="hljs-attr">width</span>: <span class="hljs-number">80</span>,
    <span class="hljs-attr">height</span>: <span class="hljs-number">80</span>,
  },
  <span class="hljs-attr">text</span>: {
    <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">'#dcdcde'</span>,
  },
});

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{

  render() {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.container}</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Text</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.text}</span>&gt;</span>
          Hello people!
          <span class="hljs-tag">&lt;<span class="hljs-name">Image</span>
            <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.image}</span>
            <span class="hljs-attr">source</span>=<span class="hljs-string">{{uri:</span> '<span class="hljs-attr">http:</span>//<span class="hljs-attr">s3.hilariousgifs.com</span>/<span class="hljs-attr">displeased-cat.jpg</span>'}}
          /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">Text</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span>
    );
  }
}

AppRegistry.registerComponent('App', () =&gt; App);
</span></code></pre>
<p>它在 ios 下看起来是这样的：</p>
<p><img src="https://raw.githubusercontent.com/wxsms/wxsms-img-holder/master/1_yUfZChrLszrpkaRaMX8NRA.png" alt="ios-before"></p>
<p>而在 Android 下看起来是这样的：</p>
<p><img src="https://raw.githubusercontent.com/wxsms/wxsms-img-holder/master/1_MWQWRMZEqy8TT_PtCzY30g.png" alt="android-before"></p>
<p><strong>可以看到，在 Android 下面这张图异常地小！</strong></p>
<p>实际上这与设备的像素比（pixel ratio）有关，是现版本 React Native 在渲染文字内联图片时的一个 Bug，为了解决这个问题，我们可以给图片设定一个基于设备像素比的宽高。</p>
<p>就像这样:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> React, { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> {
  AppRegistry,
  StyleSheet,
  Text,
  View,
  Image,
  Platform,
  PixelRatio,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'react-native'</span>;

<span class="hljs-keyword">const</span> width = <span class="hljs-number">80</span> * (Platform.OS === <span class="hljs-string">'ios'</span> ? <span class="hljs-number">1</span> : PixelRatio.get());
<span class="hljs-keyword">const</span> height = <span class="hljs-number">80</span> * (Platform.OS === <span class="hljs-string">'ios'</span> ? <span class="hljs-number">1</span> : PixelRatio.get());

<span class="hljs-keyword">const</span> styles = StyleSheet.create({
  <span class="hljs-attr">container</span>: {
    <span class="hljs-attr">flex</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">paddingTop</span>: <span class="hljs-number">50</span>,
    <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">'#f6f7f8'</span>,
  },
  <span class="hljs-attr">image</span>: {
    <span class="hljs-attr">width</span>: width,
    <span class="hljs-attr">height</span>: height,
  },
  <span class="hljs-attr">text</span>: {
    <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">'#dcdcde'</span>,
  },
});

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{

  render() {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.container}</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Text</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.text}</span>&gt;</span>
          Hello people!
          <span class="hljs-tag">&lt;<span class="hljs-name">Image</span>
            <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.image}</span>
            <span class="hljs-attr">source</span>=<span class="hljs-string">{{uri:</span> '<span class="hljs-attr">http:</span>//<span class="hljs-attr">s3.hilariousgifs.com</span>/<span class="hljs-attr">displeased-cat.jpg</span>'}}
          /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">Text</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span>
    );
  }
}

AppRegistry.registerComponent('App', () =&gt; App);
</span></code></pre>
<p>结果：</p>
<p><img src="https://raw.githubusercontent.com/wxsms/wxsms-img-holder/master/1_-g2_GF-__VQQAprdLAisHA.png" alt="android-after"></p>
<p>如此一来，内联图片在 Android 下就能以正常缩放比显示了。</p>
<p>方便起见，可以将这段逻辑封装到组件中去。</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> {
  StyleSheet,
  Image,
  Platform,
  PixelRatio,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'react-native'</span>;

<span class="hljs-comment">// This component fixes a bug in React Native with &lt;Image&gt; component inside of</span>
<span class="hljs-comment">// &lt;Text&gt; components.</span>
<span class="hljs-keyword">const</span> InlineImage = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> {
  <span class="hljs-keyword">let</span> style = props.style;
  <span class="hljs-keyword">if</span> (style &amp;&amp; Platform.OS !== <span class="hljs-string">'ios'</span>) {
    <span class="hljs-comment">// Multiply width and height by pixel ratio to fix React Native bug</span>
    style = <span class="hljs-built_in">Object</span>.assign({}, StyleSheet.flatten(props.style));
    [<span class="hljs-string">'width'</span>, <span class="hljs-string">'height'</span>].forEach(<span class="hljs-function">(<span class="hljs-params">propName</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (style[propName]) {
        style[propName] *= PixelRatio.get();
      }
    });
  }

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Image</span>
      {<span class="hljs-attr">...props</span>}
      <span class="hljs-attr">style</span>=<span class="hljs-string">{style}</span>
    /&gt;</span>
  );
};

// "Inherit" prop types from Image
InlineImage.propTypes = Image.propTypes;

export default InlineImage;
</span></code></pre>
]]></description><pubDate>Wed May 30 2018 02:09:05 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/react-native-text-inline-image</link><guid isPermaLink="true">https://blog.wxsm.space/p/react-native-text-inline-image</guid></item><item><title>Thoughts of ReactNative</title><description><![CDATA[<!-- 「」 -->
<p>使用 ReactNative 开发半年有余，本文是作为一些简单的感想。</p>
<p>官网简介：</p>
<blockquote>
<p>Build native mobile apps using JavaScript and React.</p>
</blockquote>
<p>简约，不简单。看着很牛逼，但实际用起来总是差了点意思。</p>
<p>总而言之：帮你节省时间的同时，隐藏着无处不在的坑。</p>
<!-- more -->
<h2 id="">关于框架本身 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h2>
<p>一个东西要辩证地看：ReactNative 的伟大之处在于它的定位，再一次验证了一句古老的预言：一切能用 JavaScript 实现的东西，终将被 JavaScript 实现。然而就目前的状态来看，还有许多问题。</p>
<p>使用 ReactNative 的目的是：让不会写原生 App 的人，通过 JavaScript 以及 React 也能编写出原生 App，并且跨 ios / Android 平台，乍一看相当美好。然而实际用过以后会发现，这其实是一个悖论，因为：</p>
<p>如果开发者真的完全对原生开发一窍不通，那么他根本不应该使用 ReactNative，因为他一旦遇到问题将完全没有任何解决能力，除了 Google -&gt; Try -&gt; Fail -&gt; Google 直到成功（大部分时候也许是“看起来成功”）以外毫无办法。</p>
<p>使用一项技术的前提是，至少对其有所了解。而普通 JavaScript 用户使用 ReactNative，简直就像是在对着一个黑盒子编程，没有任何可靠性可言。这也是我在开发初期的真实情况：出 bug 了，不知道为什么，解决了，也不知道为什么。处于一种非常恐慌的状态。</p>
<p>也许你会说，<a href="https://electronjs.org/">Electron</a> 不也是这种模式吗？那我为什么没有吐槽它呢？是的，他们俩“看起来”是一样的，但是实际上又完全不一样：</p>
<ul>
<li>Electron App 实际上是一个 Hybrid App，开发者写的 HTML 代码不需要经过任何处理，直接使用浏览器内核解析、显示，整个过程是透明的、可控的</li>
<li>ReactNative App 是一个真正的 Native App，开发者写的任何组件都会先被转化为原生组件，然后才显示给用户，而这个转化过程是一个黑盒子，是不可控的</li>
</ul>
<p>因此，理想与现实总是存在差距。ReactNative 开发者不能闭门造车，一定要不断地深入底层，才能真正明白自己“在干嘛”以及“该怎么干”。这也正是悖论所在：既然如此，我为什么不从一开始就使用原生方式编写 App 呢？当然，使用 ReactNative 还有另一个重要原因，即提供跨平台开发的可能性。但要知道，它在节省大量时间的同时，也给项目组带来了大量的限制和坑。</p>
<h2 id="-2">关于这个项目 <a class="header-anchor" href="#-2" aria-hidden="true">&#128279;</a></h2>
<p>ReactNative 毫无疑问是一个相当庞大的项目。</p>
<p>目前 ReactNative 还没有发布 1.0 版本，也就是说项目依旧在发展期。目前来说，我觉得<strong>最大的一个问题是项目升级问题</strong>。项目保持快速发展当然很棒，但是如何能够让现有的版本升级到最新版本呢？这对于实力不强的开发者来说几乎是不可能事件。</p>
<p>主要原因：</p>
<ul>
<li>MINOR version 会包含大量 breaking changes，无痛升级不存在的</li>
<li>也许要同时升级 React 版本</li>
<li>第三方库不一定兼容，尤其是涉及底层的</li>
</ul>
<p>另一方面，<strong>向 ReactNative 提 PR 可要比向其它 JavaScript 项目提 PR 门槛要高得多</strong>：JavaScript / ios / Android 你至少得会其中两个才行。</p>
<p>我说这个不是为了别的。我在 issues 下面最常看到的一句话就是：</p>
<blockquote>
<p>Hi there! This issue is being closed because it has been inactive for a while. Maybe the issue has been fixed in a recent release, or perhaps it is not affecting a lot of people. Either way, we're automatically closing issues after a period of inactivity. Please do not take it personally!</p>
</blockquote>
<p>可以说相当无情了。关闭一个 issue 的原因，可以是 <code>maybe</code>，可以是 <code>perhaps</code>，极少有 <code>resolved</code>，这就是现状。</p>
<p>我理解它是一个开源项目，开发者的时间有限，更没有义务。但这可以为使用者提供一些参考。ReactNative 存在超大量诸如此类的 issue，没有被 fix，更没有 fix 计划，有很大一部分其实是非常基础的诉求，比如图文混排，这在 Android 平台下已然是不可能事件。</p>
<p>因此，综上来说，如果你对 ios/ Android 并不精通，那你一旦遇到棘手的问题，只能祈祷：</p>
<ul>
<li>还有更多、非常多的人遇到了跟你同样的问题</li>
<li>并且引发了激烈的讨论</li>
<li>并且成功地被开发者修复了</li>
<li>并且没有跨很多版本</li>
</ul>
<p>否则还是歇着吧。</p>
<h2 id="-3">掉坑总结 <a class="header-anchor" href="#-3" aria-hidden="true">&#128279;</a></h2>
<p>正如上文所言，<strong>ReactNative App 最主要的功能之一是 Layout 绘制，而它自带的黑盒子属性，也正是最大的坑之所在</strong>。</p>
<p>简单来说，你写了一个控件，如果不经过测试的话：</p>
<ol>
<li>你不知道它是否能在 ios 下正常表现、工作</li>
<li>你也不知道它是否能在 Android 下正常表现、工作</li>
<li>你更不知道它是否能在两个平台之间保持一致</li>
</ol>
<p><strong>总而言之，如果你不真的去试试，那你什么都不知道</strong>。也许它在 ios 下完全正常，在 Android 就直接崩溃了。</p>
<p>ReactNative 提供了许多基础的跨平台组件，但是他们基本上都各有各的坑，更有组合坑。比如：</p>
<ul>
<li><code>&lt;Text&gt;</code> 中不能有 <code>&lt;View&gt;</code> （Android 崩溃）</li>
<li><code>&lt;Text&gt;</code> 中不能有 <code>&lt;Image&gt;</code> （Android 显示异常）</li>
<li><code>&lt;Image&gt;</code> 不能同时使用 <code>borderRadius</code> 与 <code>backgroundColor</code> 样式 （Android 显示异常）</li>
<li><code>overflow</code> 样式在 Android 下无效，始终表现为 <code>hidden</code></li>
<li>等等...</li>
</ul>
<p>（冰山一角）</p>
<p>以上所说的“异常”，是无法通过适配得到解决的异常，也就是说你一定不能这么用。这些有的在文档里会标为“已知问题”，有的则没有，如果你是一个新手，那么处处都存在着惊喜等待你去发掘。</p>
<p>除此以外，还有一个显著问题就是，<strong>在 ReactNative 的世界中，Debug 是不完全可靠的</strong>。因为它在 Debug 时用的是开发电脑上的 chrome 附带的 JavaScript 引擎，而在真正运行时则使用手机内置浏览器的 JavaScript 引擎。虽然大部分时候你感觉不到差异，但是一旦出现了差异则往往是致命的。</p>
]]></description><pubDate>Fri Apr 27 2018 08:24:25 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/thoughts-of-react-native</link><guid isPermaLink="true">https://blog.wxsm.space/p/thoughts-of-react-native</guid></item><item><title>Auto-height Webview of ReactNative</title><description><![CDATA[<!-- 「」 -->
<p>自动高的 Webview 实现方式其实跟 iframe 无二，无非是计算其内容高度后再赋值给容器样式。但是普通的办法实际上用起来差强人意，<strong>其问题主要体现在页面加载过慢，需要整个页面（包括图片）加载完成后才能计算出高度</strong>。而实际想要的效果往往是跟普通“网页”的表现一致，即：<strong>先加载文字，图片等内容异步加载、显示</strong>。在尝试了多款开源解决方案后，问题均没有得到解决，因此有了自己动手的想法。</p>
<p>不过本方案目前也只适用于自己拼接的 HTML，不适用于直接打开链接的 Webview，应用场景主要是在 ReactNative 应用内打开由 CMS 编辑的类新闻页面。</p>
<p>主要思路为：通过 Webview 提供的 <code>postMessage</code> 交互方式，不断地从 HTML 页面把自己计算好的高度抛送给 APP 端。但是这里其实有个问题，ReactNative Webview 的 <code>postMessage</code> 必须在页面加载完成以后才会注入，因此可以先加载一个空白页，待 <code>postMessage</code> 注入完成以后，再将实际文章内容插入到 <code>body</code> 中。</p>
<p>但是这么做有一个问题就是，页面将无法知道真正的内容“是否已加载完”，因为 <code>window.onload</code> 事件在加载开始之前就已经结束了。因此它只能不停地抛送高度信息，直到页面被销毁。</p>
<p>核心代码（HTML）：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"shortcut icon"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"data:image/x-icon;,"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"image/x-icon"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"content-type"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"text/html; charset=utf-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span>
          <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
      <span class="hljs-keyword">var</span> inserted = <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">var</span> interval = setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> body = <span class="hljs-built_in">document</span>.body, html = <span class="hljs-built_in">document</span>.documentElement;
        <span class="hljs-keyword">var</span> height = <span class="hljs-built_in">Math</span>.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.postMessage) {
          <span class="hljs-keyword">if</span> (!inserted) {
            <span class="hljs-built_in">document</span>.body.innerHTML = <span class="hljs-string">'${valueParsed}'</span>;
            inserted = <span class="hljs-literal">true</span>;
          }
          <span class="hljs-built_in">window</span>.postMessage(height + <span class="hljs-string">''</span>);
        }
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">document</span>.readyState === <span class="hljs-string">'complete'</span>) {
          <span class="hljs-comment">//clearInterval(interval)</span>
        }
      }, <span class="hljs-number">200</span>);
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p>核心代码（App）：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AutoHeightWebview</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PureComponent</span> </span>{
  <span class="hljs-keyword">constructor</span> (props) {
    <span class="hljs-keyword">super</span>(props);
    <span class="hljs-keyword">this</span>.state = {
      <span class="hljs-attr">webviewHeight</span>: <span class="hljs-number">0</span>
    };
  }

  assembleHTML = <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> {
    <span class="hljs-comment">// 组装HTML，略</span>
  };

  onMessage = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> webviewHeight = <span class="hljs-built_in">parseFloat</span>(event.nativeEvent.data);
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isNaN</span>(webviewHeight) &amp;&amp; <span class="hljs-keyword">this</span>.state.webviewHeight !== webviewHeight) {
      <span class="hljs-keyword">this</span>.setState({webviewHeight});
    }
  };

  render () {
    <span class="hljs-keyword">const</span> HTML = <span class="hljs-keyword">this</span>.assembleHTML(<span class="hljs-keyword">this</span>.props.html);
    <span class="hljs-keyword">const</span> onLoadEnd = <span class="hljs-keyword">this</span>.props.onLoadEnd || <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{};
    <span class="hljs-comment">// 防止 postMessage 与页面原有方法冲突</span>
    <span class="hljs-keyword">const</span> patchPostMessageFunction = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> originalPostMessage = <span class="hljs-built_in">window</span>.postMessage;
      <span class="hljs-keyword">var</span> patchedPostMessage = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">message, targetOrigin, transfer</span>) </span>{
        originalPostMessage(message, targetOrigin, transfer);
      };
      patchedPostMessage.toString = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>(<span class="hljs-built_in">Object</span>.hasOwnProperty).replace(<span class="hljs-string">'hasOwnProperty'</span>, <span class="hljs-string">'postMessage'</span>);
      };
      <span class="hljs-built_in">window</span>.postMessage = patchedPostMessage;
    };

    <span class="hljs-keyword">const</span> patchPostMessageJsCode = <span class="hljs-string">'('</span> + <span class="hljs-built_in">String</span>(patchPostMessageFunction) + <span class="hljs-string">')();'</span>;

    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">WebView</span>
        <span class="hljs-attr">injectedJavaScript</span>=<span class="hljs-string">{patchPostMessageJsCode}</span>
        <span class="hljs-attr">source</span>=<span class="hljs-string">{{html:</span> <span class="hljs-attr">HTML</span>, <span class="hljs-attr">baseUrl:</span> '<span class="hljs-attr">http:</span>'}}
        <span class="hljs-attr">scalesPageToFit</span>=<span class="hljs-string">{Platform.OS</span> !== <span class="hljs-string">'ios'</span>}
        <span class="hljs-attr">bounces</span>=<span class="hljs-string">{false}</span>
        <span class="hljs-attr">scrollEnabled</span>=<span class="hljs-string">{false}</span>
        <span class="hljs-attr">startInLoadingState</span>=<span class="hljs-string">{false}</span>
        <span class="hljs-attr">automaticallyAdjustContentInsets</span>=<span class="hljs-string">{true}</span>
        <span class="hljs-attr">onMessage</span>=<span class="hljs-string">{this.onMessage}</span>
        <span class="hljs-attr">onLoadEnd</span>=<span class="hljs-string">{onLoadEnd}</span>
      /&gt;</span>
    );
  }
}
</span></code></pre>
]]></description><pubDate>Tue Apr 24 2018 06:32:30 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/auto-height-webview-of-react-native</link><guid isPermaLink="true">https://blog.wxsm.space/p/auto-height-webview-of-react-native</guid></item><item><title>关于 Moment.js 的一些思考</title><description><![CDATA[<!-- 「」 -->
<p><a href="https://momentjs.com/">Moment.js</a> 是一个流行的基于 JavaScript 的时间处理工具库。应该是一个从 2011 年开始启动的项目，至今它的 <a href="https://github.com/moment/moment">Github repo</a> 也有了 3w+ 的星星，可以说在前端界人尽皆知了。反正我自从用了它基本上就没再接触过其它的相关库。</p>
<p>但最近我却对它的看法却产生了些许改变。原因是，它的 API 设计给使用者埋下了巨大无比的坑，简单来说：“名不副实”。</p>
<!-- more -->
<p>具体看图吧：</p>
<p><img src="https://raw.githubusercontent.com/wxsms/wxsms-img-holder/master/Selection_003.png" alt="strange-moment-js"></p>
<p>很明显，调用 Moment.js 的 API 产生了预期之外的副作用。函数在带有返回值的同时却又对原始值进行了修改，违反了基本的 OO 设计原则。</p>
<blockquote>
<p><strong>Command–query separation (CQS)</strong> is a principle of imperative computer programming. It was devised by Bertrand Meyer as part of his pioneering work on the Eiffel programming language. <strong>It states that every method should either be a command that performs an action, or a query that returns data to the caller, but not both.</strong> In other words, Asking a question should not change the answer. More formally, methods should return a value only if they are referentially transparent and hence possess no side effects.</p>
</blockquote>
<p>也就是说，设计一个函数，它应该：</p>
<ul>
<li>要么进行操作（Mutable）；</li>
<li>要么进行返回（Immutable）；</li>
<li>但，以上两点不能同时进行。</li>
</ul>
<p>这里的“返回”，我的理解不是所有类型的返回，而是特指与原始值相对应的返回。</p>
<p>比如说，在 JavaScript 世界中 <code>array.slice</code> 是一个 Immutable 类型的函数，它不会对输入值进行改变，而是返回一份 copy：</p>
<blockquote>
<p>The <code>slice()</code> method returns a shallow copy of a portion of an array into a new array object selected from begin to end (end not included). The original array will not be modified.</p>
</blockquote>
<p>但 <code>array.splice</code> 则不同（它虽然也有返回值，但跟输入值并不是对应的关系了）：</p>
<blockquote>
<p>The <code>splice()</code> method changes the contents of an array by removing existing elements and/or adding new elements. Return value: An array containing the deleted elements.</p>
</blockquote>
<p>同理还有 <code>array.push</code> / <code>array.pop</code> 等。</p>
<p><strong>而 Moment.js 是如何设计的呢？</strong></p>
<p>这里有一个 issue，通过它，基本可以看出来 Moment 有哪些 API 是有问题的：<a href="https://github.com/moment/moment/issues/1754">make moment mostly immutable #1754</a></p>
<p>比如一个简单的 <code>add</code> 方法，对日期进行“加”操作（比如日期加一天）。那么它应该是这样的：</p>
<ul>
<li>要么直接对输入进行“加”操作；</li>
<li>要么产生一份复制值，对复制进行“加”操作并返回。</li>
</ul>
<p>但是，Moment 真正的做法是，直接对输入进行“加”操作，并且返回。这样就很让人头疼了。</p>
<p>更过分的就是上图的例子，名如 <code>startOf</code> / <code>endOf</code> 这样的方法，看起来像是 Immutable 操作，实际上却还是 Mutable 的。所以说，如果用户使用了 Moment，那么所有的原始输入值基本上都是无法得到任何保证。你根本不知道输入值在什么时候就被修改了。</p>
<p>值得欣慰的是，在 Moment 发展了三年以后的 2014 年，终于有人提出了上述问题，并且被维护者认可并加入版本计划中了。但是，三年之后又三年，如今已经到了 2018，问题依旧没有得到解决。在 ES 发展如此迅速的时代，一个基本上处于垄断地位的流行库，以及一个三年都没能解决的问题，不知道是否还有救？</p>
<p>不过也许它已经完成曲线救国了（推倒重来总是比较简单）：<a href="https://github.com/moment/luxon">https://github.com/moment/luxon</a></p>
<blockquote>
<p>Features: Immutable, chainable, unambiguous API.</p>
</blockquote>
<p>不可否认 Moment.js 确实帮助开发者解决了很多问题，节省了大量时间。但是有一个问题：一个质量如此的库，是如何做到流行，如何拿到 3w 个 stars 的呢？是不是包括我在内的这些开发者，从根本上就存在软件开发基础知识的不足呢。</p>
]]></description><pubDate>Wed Jan 24 2018 06:40:18 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/some-thougths-about-momentjs</link><guid isPermaLink="true">https://blog.wxsm.space/p/some-thougths-about-momentjs</guid></item><item><title>Linux Setup for Work</title><description><![CDATA[<p>因为各种烦人的原因，公司搬家后到新办公室第一件事先把老电脑格了。犹豫了一下，最终还是放弃了重装 Windows，支持我做出选择的原因有几：</p>
<ul>
<li>不需要进行（纯）MS 系开发</li>
<li>没有必须使用的 Windows 软件</li>
<li>Windows 上跑 Android emulator 卡得头疼</li>
<li>NVIDIA 已有支持 Linux 的官方显卡驱动</li>
<li>Linux 开发效率更高</li>
<li>Linux 学习价值更高</li>
</ul>
<p>本文是办公室适用（对我来说）的安装记录。</p>
<!-- more -->
<h2 id="system-installation">System installation <a class="header-anchor" href="#system-installation" aria-hidden="true">&#128279;</a></h2>
<p>这次选择的发行版是 Ubuntu 16.04 LTS，从 <a href="https://www.ubuntu.com/download/desktop">https://www.ubuntu.com/download/desktop</a> 下载镜像安装包，复制到 u 盘后启动。</p>
<p>这里有一点问题是，我这台机器必须选择 UEFI 安装，Ubuntu 才能正常安装与启动。如果选择了 Legacy 安装，Ubuntu 可以正常安装，但启动后会一直停留在黑屏光标闪烁的状态，原因未知。</p>
<h2 id="nvidia-driver-setup">NVIDIA driver setup <a class="header-anchor" href="#nvidia-driver-setup" aria-hidden="true">&#128279;</a></h2>
<p>系统默认安装了一个第三方的显卡驱动，基本上没什么可用性，在桌面上都有点卡。因此官方驱动是必须的。但如果安装不正确，会导致系统重启后无限卡在登录界面。如果不幸已经发生了这种情况，可以按 Ctrl + Alt + F1 进入纯命令行操作界面进行修复。</p>
<p>（以下步骤应该在纯命令行界面下执行）</p>
<p>首先禁用开源驱动：</p>
<pre><code>$ sudo vim /etc/modprobe.d/blacklist.conf
</code></pre>
<p>添加以下内容：</p>
<pre><code>blacklist amd76x_edac
blacklist vga16fb
blacklist nouveau
blacklist nvidiafb
blacklist rivatv
</code></pre>
<p>然后，依次执行（注意先到 NVIDIA 官网查询适用自己显卡的版本号，比如我的辣鸡 GTX650 是适用 384）：</p>
<pre><code>$ sudo apt-get remove  --purge nvidia-*
$ sudo add-apt-repository ppa:graphics-drivers/ppa
$ sudo apt-get update
$ sudo service lightdm stop
$ sudo apt-get install nvidia-384 nvidia-settings nvidia-prime
$ sudo nvidia-xconfig
$ sudo update-initramfs -u
</code></pre>
<p>最后重启系统：</p>
<pre><code>$ sudo reboot
</code></pre>
<p>如此，显卡驱动就装好了。</p>
<h2 id="chrome-setup">Chrome setup <a class="header-anchor" href="#chrome-setup" aria-hidden="true">&#128279;</a></h2>
<p>虽然 Ubuntu App Store 有提供开源版本的 Chromium，但是经过实测它在有些情况下并不能完全替代 Chrome（比如有些工具会调用 <code>google-chrome</code> 来打开一个浏览器页，如果安装的是 Chromium 就会失败）。因此，还是建议到 <a href="https://www.google.com/chrome/browser/desktop/index.html">Google Chrome Downloads</a> 下载适用于 Linux 平台的 Chrome 完全体。</p>
<h2 id="secondary-drive-mount">Secondary drive mount <a class="header-anchor" href="#secondary-drive-mount" aria-hidden="true">&#128279;</a></h2>
<p>两块硬盘已经不是什么新鲜事了。痛苦的是系统盘以外的另一块硬盘需要手动挂载。</p>
<p>首先，使用 <code>sudo fdisk -l</code> 命令来显示目前可用的所有硬盘。假设 <code>/dev/sdb</code> 是未分区并且想要挂载的一块硬盘：</p>
<p>执行 <code>sudo fdisk /dev/sdb</code>：</p>
<ol>
<li>Press <kbd>O</kbd> and press <kbd>Enter</kbd> (creates a new table)</li>
<li>Press <kbd>N</kbd> and press <kbd>Enter</kbd> (creates a new partition)</li>
<li>Press <kbd>P</kbd> and press <kbd>Enter</kbd> (makes a primary partition)</li>
<li>Then press <kbd>1</kbd> and press <kbd>Enter</kbd> (creates it as the 1st partition)</li>
<li>Finally, press <kbd>W</kbd> (this will write any changes to disk)</li>
</ol>
<p>然后，执行 <code>sudo mkfs.ext4 /dev/sdb1</code></p>
<p>现在新硬盘就已经被分区并格式化了。接下来让系统在启动的时候自动挂载它，执行 <code>sudo gnome-disks</code> 打开一个 GUI 界面。</p>
<p><img src="https://i.stack.imgur.com/WZeoX.png" alt="img"></p>
<p>选择刚才添加的那块硬盘，点击配置按钮，选择目标挂载点，并点击 OK 即可。</p>
<p><img src="https://i.stack.imgur.com/h529h.png" alt="img"></p>
<p>需要注意的是，目前硬盘是只有读权限的，使用以下命令来给用户赋予读写权限：</p>
<pre><code>$ cd /mount/point
$ sudo chmod -R -v 777 *
$ sudo chown -R -v username:username *
</code></pre>
<h2 id="input-method-setup">Input method setup <a class="header-anchor" href="#input-method-setup" aria-hidden="true">&#128279;</a></h2>
<p>到 <a href="https://pinyin.sogou.com/linux/">https://pinyin.sogou.com/linux/</a> 下载合适的输入法包，并安装之。然后从 Settings -&gt; Language Support 中将 Keyboard input method system 从 iBus 切换为 fcitx（有可能会遇到语言包安装不完全的情况，输入 <code>sudo apt-get install -f</code> 可以修复），然后重启。</p>
<p>重启后，右键桌面右上角的 fcitx 图标，选择 ConfigureFcitx，点击 + 号添加输入法，<strong>去掉 Only show current language 的勾</strong>，然后输入 sogou 搜索即可看到安装好的搜狗输入法。添加即可。</p>
<h2 id="email-setup">Email setup <a class="header-anchor" href="#email-setup" aria-hidden="true">&#128279;</a></h2>
<p>因为我的公司邮箱是用的 Ms Exchange，所以设置步骤很简单：</p>
<ol>
<li>Ubuntu 自带 <a href="https://www.mozilla.org/en-US/thunderbird/">Mozilla Thunderbird</a> 邮件客户端，直接用这个就行了。</li>
<li>它本身是不支持 Exchange 配置的，需要添加一个插件 <a href="https://addons.mozilla.org/en-US/thunderbird/addon/exquilla-exchange-web-services/">ExQuilla for Microsoft Exchange</a> 以支持。</li>
<li>安装好插件后，从菜单栏的 Tools -&gt; ExQuilla for Microsoft Exchange -&gt; Add Microsoft Exchange Account 进入配置入口，然后就是正常的邮件配置了。</li>
</ol>
<h2 id="screenshot">Screenshot <a class="header-anchor" href="#screenshot" aria-hidden="true">&#128279;</a></h2>
<p>以下安装截图工具 Shutter，并设置快捷键：</p>
<pre><code>$ sudo add-apt-repository ppa:shutter/ppa
$ sudo apt-get update
$ sudo apt-get install shutter
</code></pre>
<p>打开 Settings -&gt; Keyboard -&gt; Shortcuts -&gt; Custom Shortcuts，点击 + 添加，输入 Name (Shutter Select) Command (shutter -s)，保存。然后点击刚才添加的项目，在快捷键那里按下 <kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>A</kbd> 即可。</p>
<p><img src="http://www.linuxidc.com/upload/2015_07/150711194568203.png" alt="shutter-1"></p>
<p><img src="http://www.linuxidc.com/upload/2015_07/150711194568205.png" alt="shutter-2"></p>
<h2 id="jdk-setup">JDK setup <a class="header-anchor" href="#jdk-setup" aria-hidden="true">&#128279;</a></h2>
<p>JDK 可以到 Oracle 网站下载，也可以通过 apt-get 安装 openjdk，以下是安装 openjdk 的过程：</p>
<pre><code>$ sudo apt-get install openjdk-8-jdk
$ apt-cache search jdk
$ export JAVA_HOME=/usr/lib/jvm/java-8-openjdk
$ export PATH=$PATH:$JAVA_HOME/bin
</code></pre>
<p>注意 JAVA_HOME 的 folder 可能有所变化，注意使用实际目录。</p>
<h2 id="nodejs-setup">Node.js setup <a class="header-anchor" href="#nodejs-setup" aria-hidden="true">&#128279;</a></h2>
<p>Node.js 不直接安装，而是选择使用 <a href="https://github.com/creationix/nvm">nvm</a> 进行管理。</p>
<pre><code>$ wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash
$ export NVM_DIR=&quot;$HOME/.nvm&quot;
  [ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm
$ command -v nvm
</code></pre>
<p>使用方法：<a href="https://github.com/creationix/nvm#usage">https://github.com/creationix/nvm#usage</a></p>
<h2 id="mongodb-setup">MongoDB setup <a class="header-anchor" href="#mongodb-setup" aria-hidden="true">&#128279;</a></h2>
<p>这里其实参照<a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-ubuntu/">官方文档</a>就行了。</p>
<pre><code>$ sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 2930ADAE8CAF5059EE73BB4B58712A2291FA4AD5
$ echo &quot;deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu xenial/mongodb-org/3.6 multiverse&quot; | sudo tee /etc/apt/sources.list.d/mongodb-org-3.6.list
$ sudo apt-get update
$ sudo apt-get install -y mongodb-org
$ sudo service mongod start
</code></pre>
<h2 id="change-launcher-position">Change launcher position <a class="header-anchor" href="#change-launcher-position" aria-hidden="true">&#128279;</a></h2>
<p>Ubuntu 默认的 Launcher 设置在了屏幕的左边，但是如果有三屏的话，那用起来其实并不方便。可以通过一个简单的命令将其下置：</p>
<pre><code>$ gsettings set com.canonical.Unity.Launcher launcher-position Bottom
</code></pre>
<p>这样 Launcher 就到了屏幕下方了，就像 Windows 默认的任务栏一样。Ubuntu 会记住这个设定，所以下次登录时也无需重新输入。</p>
<h2 id="enable-workspace">Enable workspace <a class="header-anchor" href="#enable-workspace" aria-hidden="true">&#128279;</a></h2>
<p>Ubuntu 16.04 默认关闭了 Workspace （即类似 OSX 的全屏切换功能），其实挺好用的。可以手动开启：</p>
<pre><code>Settings -&gt; Appearance -&gt; Behavior -&gt; Enable workspaces
</code></pre>
<p><img src="https://i.stack.imgur.com/wQ3hD.png" alt="enable-workspace"></p>
<p>如果有配置双屏的话，一般会想固定副屏的内容，只需在副屏标题栏右键，选择 <code>Always on Visible Workspace</code> 即可。</p>
<p><img src="https://i.stack.imgur.com/Xx7pQ.png" alt="always-on-visible-workspace"></p>
<p>默认的切换屏幕快捷键是 <kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>Arrow</kbd>，跟 Intellij 的快捷键冲突了，并且与 OSX 上的不一致。可以手动修复：</p>
<pre><code>Settings -&gt; Keyboard -&gt; Shortcuts -&gt; Navigation
</code></pre>
<p>找到 Switch workspace to left / right / up / down, 各自改成相应的 <kbd>Ctrl</kbd> + <kbd>Arrow</kbd> 即可。</p>
<h2 id="other-apps">Other apps <a class="header-anchor" href="#other-apps" aria-hidden="true">&#128279;</a></h2>
<ul>
<li><a href="https://github.com/geeeeeeeeek/electronic-wechat">微信</a></li>
<li><a href="http://cidian.youdao.com/index-linux.html">有道词典</a></li>
<li><a href="http://music.163.com/#/download">网易云音乐</a></li>
<li><a href="http://store.steampowered.com/about/">Steam</a></li>
</ul>
<p>Linux 下可玩的 Steam 游戏还是挺多的。玩 DOTA2 感觉跟 Windows 也没什么差别。</p>
]]></description><pubDate>Tue Jan 09 2018 12:56:59 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/linux-setup-for-work</link><guid isPermaLink="true">https://blog.wxsm.space/p/linux-setup-for-work</guid></item><item><title>2017</title><description><![CDATA[<p>今天是 2017 年的最后一个（法定）工作日。做个简单的总结。</p>
<p>先对比一下去年的自己与目标：</p>
<ul>
<li>关于工作，年初就换了。现在到了一个游戏公司（西山居）上班。对于去年吐槽最多的「业务」问题来说，如今算是彻底解决了。</li>
<li>关于学习，感觉自己从某些方面来说，是有一点进步的。</li>
<li>关于生活，今年入了两台主要设备，一台 RMBP，以及一台游戏主机。感觉都很值。</li>
</ul>
<p>大概就这些。</p>
<!--more-->
<h2 id="">职业 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h2>
<p>现在回头想想，自己通过公交车上下班已经快一年了，每天两个小时在路上，时间真的过得很快（好在公司马上要搬）。今年全勤，加上加班时间，略有困倦。</p>
<p>今年：</p>
<ul>
<li><strong>Vue</strong> 基本上已经轻车熟路；</li>
<li>接触了 <strong>Electron</strong> 开发框架，用它负责并完成了公司的一个 H5 + Canvas 视频工具客户端项目的开发；</li>
<li>接触了 <strong>React</strong> 全家桶以及 <strong>ReactNative</strong>，目前开发时间也有一月余了，略知一二，找个时间写个系统性的学习与使用总结（算是个人技术栈上的一个突破）；</li>
<li>对<strong>前端工具链</strong>有了更加深入的理解；</li>
<li>等等......</li>
</ul>
<p>此外，工作之余，还拥有了两个（真正意义上的）开源项目：</p>
<ul>
<li><a href="https://github.com/wxsms/uiv">https://github.com/wxsms/uiv</a></li>
<li><a href="https://github.com/wxsms/vue-md-loader">https://github.com/wxsms/vue-md-loader</a></li>
</ul>
<p>第一个，组件库，是我一直想做的，今年终于算是略有小成了。从一开始非常简陋的东西，变成了现在这副模样。在用户数量逐渐增加的同时，也得到了越来越多的反馈与支持。同时，在设计与改善的过程中，我也从其它的开源项目中得到了很多启发（如 Element / iView / Bootstrap-Vue 等）。</p>
<p>第二个，将 Markdown 转换为 Vue 组件的 Webpack loader，是为了解决组件库项目的一个问题（文档撰写）而产生的。这个功能很普通，但它能帮我（或者跟我有类似需求的人）解决一个突出的问题。详情请看：<a href="https://blog.wxsm.space/p/better-documents">Better Documents</a></p>
<p>开源项目的乐趣在于，开发者能够实实在在地从社区获得一些「认同感」。也就是，有人真的在使用我的项目。他们会给我提改进意见，给我贡献代码，还会对我说「谢谢」。虽然我做的事情根本微不足道，但每天看到项目的星星在一个个地变多，还是让我非常开心的事情。</p>
<h2 id="-2">生活 <a class="header-anchor" href="#-2" aria-hidden="true">&#128279;</a></h2>
<p>今年去了两次女朋友的家（五一、十一），见了家长。第二次还是跟自己这边的亲戚们一起去的，很多人。现在双方应该说是「认识了」。</p>
<p>如今很多亲戚经常会问我的事情是：结婚了没，什么时候结婚，怎么还不结婚。也许这就是顺理成章的事情，很正常。但我并没有觉得目前有这个必要（静纯应该也是这么认为的吧），现在这样不就挺好的吗。房子买了（虽然还未落定），工作正常，生活富足，过得开心，可以说现在我真的是无欲无求。所以我根本没想过「要结婚」这件事情。</p>
<p>有一点遗憾的是，公司原定的「塞班岛」旅行，后来取消了。本来我跟静纯纠结了好久才决定要去，很多东西都在准备了，结果因为工作原因不得不取消。后来补数的旅行线路，我觉得都没有这个好了，所以就干脆就没有再参与。</p>
<p>公司即将搬迁到唐家，这样一来我的生活圈子就又回到唐家了，而且还变得比一年前还更小了。不知道到时候我还能不能有买车的动力。我觉得车还是挺有必要的，没有它，不要说一线城市，在珠海这个二线城市都有点力不从心，去哪里都要担心回家的事情。而且，回家也不方便，东西带不了多，不能说走就走。</p>
<p>今年又有一些朋友从别的城市来看我了，我希望等到明年工作闲下来的时候，我也能去看看朋友。</p>
<p>老妈今年跟亲友到处游玩，我也觉得挺好的，有机会的时候就是要去玩。可惜的是我没有时间参与。前段时间比较冷，不想呆在房子里被冻僵，就买了个取暖器，后来想到家里没有，就给老妈也买了个。其实我为家里做过的事情真的很少，从现在起我要养成这样的习惯。</p>
<p>对了，如果年底发的奖金足够多，那么我今年就能还清借父母的首付了！</p>
<h2 id="-3">爱好 <a class="header-anchor" href="#-3" aria-hidden="true">&#128279;</a></h2>
<p>今年买的最值的一样东西就是 MacBook Pro (Retina, 13-inch, Early 2015)，基本替代了我办公室的台式电脑。原因有几：</p>
<ul>
<li>对于非 MS 系开发者来说，比 Windows 简单、易用、好用；</li>
<li>ReactNative 开发时可以进行 Emulator 调试；</li>
<li>软件齐全，且非常「干净」；</li>
<li>速度飞快；</li>
<li>屏幕好看。</li>
</ul>
<p>13 寸也是我非常喜欢的尺寸，极度轻便，搭配 Retina 屏幕，不要太完美。</p>
<p>此外，自己动手组装了一台游戏主机，花了大概 6k，自从那时开始，打开游戏第一件事，分辨率 MAX，特效 MAX，毫无压力（当然是对我的垃圾 1080P 来说）。再此外，买了一个 XBOX ONE 手柄。</p>
<p>有了设备，自然就有软件。在有限的游玩时间内，今年我最喜欢的两个游戏：</p>
<ul>
<li>DARK SOULS™ III「黑暗之魂 3」</li>
<li>NieR:Automata™「尼尔：机械纪元」</li>
</ul>
<p>之后我会单独写两篇文来记录感想。</p>
<p>下半年开始就没怎么玩 DOTA 了，一是工作繁忙，二是状态有点迷，跟不上节奏。</p>
<h2 id="-4">接下来 <a class="header-anchor" href="#-4" aria-hidden="true">&#128279;</a></h2>
<p>希望可以：</p>
<ul>
<li>大家都身体健康</li>
<li>在现有基础上继续钻研 React / ReactNative，至少达到「熟练」的程度</li>
<li>ReactNative 做多了以后，少不了要接触原生开发，希望至少可以「入门」</li>
<li>学习 GO 技术栈，希望至少可以「入门」</li>
<li>玩（买）更多的游戏！</li>
</ul>
]]></description><pubDate>Fri Dec 29 2017 07:41:21 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/2017</link><guid isPermaLink="true">https://blog.wxsm.space/p/2017</guid></item><item><title>《芳华》</title><description><![CDATA[<p>我个人非常喜欢冯导的这部电影。</p>
<p>我的理解，这部电影的内容、主题，就跟它的名字一样，芳华。虽然我不是生活在那个年代的人，但是我也许可以理解那些都是什么。电影把一代人最美的形象，最好的年华，最真的梦想，展示给了我们看。相信这一点没有争议，不用过多解释。</p>
<p>至于其它的，我觉得都不重要。</p>
<p>有些人在这个故事里看到的更多是人的「恶」。如林丁丁，如红二代，如政委。认为所谓的「战友情」不过是镜花水月。但是，生活不就是这样的吗？</p>
<p>在电影里面，最终没有任何事情被追究，就连「迫害」了刘峰的林丁丁，最后也能被拿来给受害人打趣，然而我并没有觉得有任何反感之处。</p>
<p>人不就是这样的吗？当你对形势做出了错误的判断，就理应承担造成的后果。认真就输了，可谓一语成谶。既然是自己酿成的错，有什么好追究的呢？</p>
<p>百年以后，没有人会记得这些人当年的那些点点滴滴的琐事，善也好，恶也罢，大概都已经如萧穗子散落的情书一般，仿佛从来就没有存在过。即使是残酷至极的战争，也终究会被人遗忘。</p>
<p>也许能留下来的，也不过存在于现实与记忆中的，一代又一代人的最美的芳华吧。</p>
]]></description><pubDate>Wed Dec 27 2017 10:46:46 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/youth</link><guid isPermaLink="true">https://blog.wxsm.space/p/youth</guid></item><item><title>Upgrade Projects Built by vue-cli</title><description><![CDATA[<p>使用 <a href="https://github.com/vuejs/vue-cli">vue-cli</a> 创建的脚手架项目，目前最大的问题是创建后无法自动地进行升级。虽然 3.0 版本已经计划将其作为头等大事来进行改善 (<a href="https://github.com/vuejs/vue-cli/issues/589">#589</a>)，但是现行的版本依然要面对它。以下基于 webpack template 来进行升级时的一些要点解析。</p>
<!-- more -->
<h2 id="">依赖 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h2>
<p>项目整体升级的一个重要目的体现在依赖的升级，如 webpack 从老版本 2 升级到 3，以及 babel / eslint 等各种配套工具的升级（至于 Vue 反倒不是什么大问题）。</p>
<p>在对依赖进行升级的时候主要有两个参考：</p>
<ul>
<li>目前最新的脚手架 (<a href="https://github.com/vuejs-templates/webpack">vuejs-templates/webpack</a>) 依赖版本</li>
<li><code>yarn outdated</code> (or npm) 给出的建议版本</li>
</ul>
<p>outed version 如果是 MINOR / PATCH 更新，直接 upgrade 即可。如果是 MAJOR 更新则需要到相应项目主页上确认一下 breaking changes 是否对自己有影响。</p>
<p>以下列举一些主要的依赖。</p>
<h3 id="webpack">Webpack <a class="header-anchor" href="#webpack" aria-hidden="true">&#128279;</a></h3>
<p>Webpack 2 -&gt; 3 其实是无痛升级的。也就是说基本不用更改什么配置。</p>
<h3 id="eslint">ESLint <a class="header-anchor" href="#eslint" aria-hidden="true">&#128279;</a></h3>
<p>ESlint 及其相关库的升级也没什么需要特别注意的地方，因为它并不参与最终构建。只不过升级以后可能会有 lint failed cases （因为新版本一般会添加新的 rules），注意修复即可。</p>
<h3 id="babel">Babel <a class="header-anchor" href="#babel" aria-hidden="true">&#128279;</a></h3>
<p>Babel 相关的升级是最麻烦（也是最头疼）的一部分。其主要问题体现在：</p>
<ul>
<li>其直接参与代码构建，影响巨大，需要特别谨慎</li>
<li>Babel 作为一个重要工具有一定的学习成本</li>
<li>Babel 相关库变更较为频繁，典型的如 <code>babel-preset-latest</code> 库废弃并被 <code>babel-preset-env</code> 替代，而后者在最新的版本中又变成了 <code>@babel/preset-env</code>，甚至 <code>babel-core</code> 也废弃了，变成了 <code>@babel/core</code></li>
</ul>
<p>在经过了几次的迁移尝试后，建议<strong>目前</strong>的方案是：</p>
<ul>
<li>进行 MINOR 升级，如果还在使用 <code>babel-preset-latest</code> 可以将其替换为 <code>babel-preset-env</code>（注意两者的配置大致一样，但略有不同，需要仔细比对）</li>
<li>暂时不要将 babel 升级至 7.x-beta</li>
<li>暂时也不要使用 <code>@babel</code> 类型的依赖（实测中出现奇怪的报错，难以追踪、搜索）</li>
<li>等待 Vue.js 社区给出解决方案</li>
</ul>
<h3 id="autoprefixer">AutoPrefixer <a class="header-anchor" href="#autoprefixer" aria-hidden="true">&#128279;</a></h3>
<p>将 <code>autoprefixer</code> 从 6.x 升级到 7.x 时，注意将 <code>package.json</code> 中的 <code>browserlist</code> 改成 <code>browserslist</code> （一个 s 的区别）</p>
<h2 id="-2">配置文件 <a class="header-anchor" href="#-2" aria-hidden="true">&#128279;</a></h2>
<p>这里说的配置文件主要有两方面：Babel 以及 Webpack</p>
<h3 id="babel-2">Babel <a class="header-anchor" href="#babel-2" aria-hidden="true">&#128279;</a></h3>
<p>最简单的操作是，直接到 <a href="https://github.com/vuejs-templates/webpack">vuejs-templates/webpack</a> 找到最新的 babel 文件，复制更新的内容下来即可。当然要注意自己已经更改过的内容不要被覆盖。</p>
<h3 id="webpack-2">Webpack <a class="header-anchor" href="#webpack-2" aria-hidden="true">&#128279;</a></h3>
<p>Webpack 配置稍微麻烦一些，主要体现在 <code>webpack.base.conf.js</code> 以及 <code>webpack.prod.conf.js</code>，个人总结的升级步骤：</p>
<ol>
<li>先升级 Webpack 相关工具到最新版本</li>
<li>打开官方项目，对文件进行比对并更新相应内容（一般 <code>webpack.prod.conf.js</code> 会有较多内容更新，而且主要是 <code>plugins</code> 配置项）</li>
<li>如果遇到目前没有安装的依赖则安装之</li>
</ol>
<p>当然这只适用于 Webpack 2 -&gt; 3 的升级，至于 1 -&gt; 2 或者 1-&gt; 3 没试过，不好说。</p>
<p>做完以上操作，跑过所有 npm scripts 一切正常的话，项目脚手架升级就基本完成了。这个过程说难不难，但是如果对 Webpack / Babel 不熟悉的话还是挺痛苦的，期待 vue-cli 3.0 可以带来更优秀的脚手架解决方案，达到类似 Nuxt.js 的效果，彻底解决升级烦恼。</p>
]]></description><pubDate>Mon Dec 18 2017 12:08:22 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/upgrade-projects-built-by-vue-cli</link><guid isPermaLink="true">https://blog.wxsm.space/p/upgrade-projects-built-by-vue-cli</guid></item><item><title>JSX in Vue.js</title><description><![CDATA[<p>在基于 Webpack 的 Vue 项目中添加 JSX 支持：</p>
<pre><code>$ yarn add babel-plugin-syntax-jsx babel-plugin-transform-vue-jsx babel-helper-vue-jsx-merge-props --dev
</code></pre>
<p>各依赖的作用：</p>
<ul>
<li><code>babel-plugin-syntax-jsx</code> 提供基础的 JSX 语法转换</li>
<li><code>babel-plugin-transform-vue-jsx</code> 提供基于 Vue 的 JSX 特殊语法</li>
<li><code>babel-helper-vue-jsx-merge-props</code> 是可选的，提供对类似 <code>&lt;comp {...props}/&gt;</code> 写法的支持</li>
</ul>
<p>然后在 <code>.babelrc</code> 中，增加：</p>
<pre><code>{
  ...
  &quot;plugins&quot;: [
    &quot;transform-vue-jsx&quot;,
    ...
  ]
  ...
}
</code></pre>
<p>注意如果有其它 env 也要如此加上 <code>transform-vue-jsx</code> 插件。</p>
<!-- more -->
<h2 id="difference-from-react-jsx">Difference from React JSX <a class="header-anchor" href="#difference-from-react-jsx" aria-hidden="true">&#128279;</a></h2>
<pre><code class="language-javascript">render (h) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>
      <span class="hljs-attr">id</span>=<span class="hljs-string">"foo"</span>
      <span class="hljs-attr">domPropsInnerHTML</span>=<span class="hljs-string">"bar"</span>
      <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.clickHandler}</span>
      <span class="hljs-attr">nativeOnClick</span>=<span class="hljs-string">{this.nativeClickHandler}</span>
      <span class="hljs-attr">class</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">foo:</span> <span class="hljs-attr">true</span>, <span class="hljs-attr">bar:</span> <span class="hljs-attr">false</span> }}
      <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">color:</span> '<span class="hljs-attr">red</span>', <span class="hljs-attr">fontSize:</span> '<span class="hljs-attr">14px</span>' }}
      <span class="hljs-attr">key</span>=<span class="hljs-string">"key"</span>
      <span class="hljs-attr">ref</span>=<span class="hljs-string">"ref"</span>
      <span class="hljs-attr">refInFor</span>
      <span class="hljs-attr">slot</span>=<span class="hljs-string">"slot"</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  )
}
</code></pre>
<p>需要注意的是，事件绑定中，还有另外一个跟 react 不一样的地方：<code>onMouseEnter</code> 是不起作用的，只能写 <code>onMouseenter</code> 或者 <code>on-mouseenter</code>，以此类推。</p>
<h2 id="vue-directives">Vue directives <a class="header-anchor" href="#vue-directives" aria-hidden="true">&#128279;</a></h2>
<p>除了 <code>v-show</code> 以外，所有的内置指令都<strong>不能</strong>在 JSX 中工作。</p>
<p>自定义指令可以使用 <code>v-name={value}</code> 的写法，但是这样会缺少修饰符以及参数。如果需要完整的指令功能，可以这么做：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> directives = [
  { <span class="hljs-attr">name</span>: <span class="hljs-string">'my-dir'</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">123</span>, <span class="hljs-attr">modifiers</span>: { <span class="hljs-attr">abc</span>: <span class="hljs-literal">true</span> } }
]

<span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> {<span class="hljs-attr">...</span>{ <span class="hljs-attr">directives</span> }}/&gt;</span>
</span></code></pre>
]]></description><pubDate>Wed Dec 13 2017 04:41:42 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/jsx-in-vuejs</link><guid isPermaLink="true">https://blog.wxsm.space/p/jsx-in-vuejs</guid></item><item><title>Serve static with PM2</title><description><![CDATA[<p>Command (2.4.0+):</p>
<pre><code>$ pm2 serve &lt;path&gt; &lt;port&gt;
</code></pre>
<p>For example:</p>
<pre><code>$ pm2 serve /dist 80
</code></pre>
<p>By default, it displays <code>404.html</code> from the serving directory when that happens (NOT configurable).</p>
]]></description><pubDate>Tue Dec 05 2017 11:10:49 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/serve-static-with-pm2</link><guid isPermaLink="true">https://blog.wxsm.space/p/serve-static-with-pm2</guid></item><item><title>Common-used Commands</title><description><![CDATA[<p>Personal common-used commands list, including windows, osx, git, etc.</p>
<!--more-->
<h2 id="git">Git <a class="header-anchor" href="#git" aria-hidden="true">&#128279;</a></h2>
<h3 id="clone">Clone <a class="header-anchor" href="#clone" aria-hidden="true">&#128279;</a></h3>
<p><strong>Full clone</strong></p>
<pre><code>$ git clone [url]
</code></pre>
<p><strong>Fast clone</strong></p>
<pre><code>$ git clone --depth=1 [url]
$ git fetch --unshallow
</code></pre>
<h3 id="fetch">Fetch <a class="header-anchor" href="#fetch" aria-hidden="true">&#128279;</a></h3>
<pre><code>$ git fetch [origin] [branch]
</code></pre>
<h3 id="pull">Pull <a class="header-anchor" href="#pull" aria-hidden="true">&#128279;</a></h3>
<pre><code>$ git pull [origin] [orinin-branch]:[local-branch]
</code></pre>
<h3 id="push">Push <a class="header-anchor" href="#push" aria-hidden="true">&#128279;</a></h3>
<pre><code>$ git push [origin] [orinin-branch]:[local-branch]
</code></pre>
<p><strong>Force push</strong></p>
<pre><code>$ git push --force origin 
</code></pre>
<p><strong>Tags push</strong></p>
<pre><code>$ git push --tags origin 
</code></pre>
<h3 id="config">Config <a class="header-anchor" href="#config" aria-hidden="true">&#128279;</a></h3>
<p><strong>Show</strong></p>
<pre><code>$ git config user.name
wxsm

$ git config --list
user.name=wxsm
user.email=wxsms@foxmail.com
</code></pre>
<p><strong>Set</strong></p>
<p>Repo level:</p>
<pre><code>$ git config user.name [name]
$ git config user.email [email]
$ git config http.proxy [proxy]
$ git config https.proxy [proxy]
</code></pre>
<p>Supports socks &amp; http proxy.</p>
<p>Global level:</p>
<pre><code>$ git config --global user.name [name]
$ git config --global user.email [email]
</code></pre>
<p><strong>Unset</strong></p>
<pre><code>$ git config --unset user.email
$ git config --global --unset user.email
</code></pre>
<h3 id="remote">Remote <a class="header-anchor" href="#remote" aria-hidden="true">&#128279;</a></h3>
<pre><code>$ git remote -v
origin  https://github.com/wxsms/uiv.git (fetch)
origin  https://github.com/wxsms/uiv.git (push)

$ git remote set-url origin git@github.com:wxsms/uiv.git

$ git remote -v
origin  git@github.com:wxsms/uiv.git (fetch)
origin  git@github.com:wxsms/uiv.git (push)
</code></pre>
<h2 id="osx">OSX <a class="header-anchor" href="#osx" aria-hidden="true">&#128279;</a></h2>
<h3 id="keys">Keys <a class="header-anchor" href="#keys" aria-hidden="true">&#128279;</a></h3>
<div class="table-responsive"><table class="table table-bordered table-hover"><thead>
<tr>
<th>Name</th>
<th>Symbol</th>
</tr>
</thead>
<tbody>
<tr>
<td>command</td>
<td>⌘</td>
</tr>
<tr>
<td>option</td>
<td>⌥</td>
</tr>
<tr>
<td>shift</td>
<td>⇧</td>
</tr>
<tr>
<td>caps lock</td>
<td>⇪</td>
</tr>
<tr>
<td>control</td>
<td>⌃</td>
</tr>
<tr>
<td>return</td>
<td>↩</td>
</tr>
<tr>
<td>enter</td>
<td>⌅</td>
</tr>
</tbody>
</table></div><h3 id="shortcuts">Shortcuts <a class="header-anchor" href="#shortcuts" aria-hidden="true">&#128279;</a></h3>
<div class="table-responsive"><table class="table table-bordered table-hover"><thead>
<tr>
<th>Name</th>
<th>Symbol</th>
</tr>
</thead>
<tbody>
<tr>
<td>search</td>
<td>⌘ + space</td>
</tr>
<tr>
<td>switch input</td>
<td>⌃ + space</td>
</tr>
<tr>
<td>delete</td>
<td>⌘ + delete</td>
</tr>
<tr>
<td>Lock screen</td>
<td>⌘ + ⌃ + Q</td>
</tr>
<tr>
<td>Screen shot (full)</td>
<td>⌘ + ⇧ + 3</td>
</tr>
<tr>
<td>Screen shot (custom)</td>
<td>⌘ + ⇧ + 4</td>
</tr>
<tr>
<td>Screen shot (window)</td>
<td>⌘ + ⇧ + 4 + space</td>
</tr>
<tr>
<td>Screen shot &amp; copy (full)</td>
<td>⌘ + ⇧ + ⌃ + 3</td>
</tr>
<tr>
<td>Screen shot &amp; copy (custom)</td>
<td>⌘ + ⇧ + ⌃ + 4</td>
</tr>
<tr>
<td>Screen shot &amp; copy (window)</td>
<td>⌘ + ⇧ + ⌃ + 4 + space</td>
</tr>
<tr>
<td>Hide window</td>
<td>⌘ + H</td>
</tr>
<tr>
<td>Minimize window</td>
<td>⌘ + M</td>
</tr>
<tr>
<td>Quit</td>
<td>⌘ + Q</td>
</tr>
</tbody>
</table></div><h3 id="proxy-command">Proxy command <a class="header-anchor" href="#proxy-command" aria-hidden="true">&#128279;</a></h3>
<pre><code>$ ALL_PROXY=socks5://127.0.0.1:9500 brew update
</code></pre>
<h3 id="toggle-hidden-files">Toggle hidden files <a class="header-anchor" href="#toggle-hidden-files" aria-hidden="true">&#128279;</a></h3>
<pre><code>$ defaults write com.apple.finder AppleShowAllFiles YES
$ defaults write com.apple.finder AppleShowAllFiles NO
</code></pre>
<h3 id="open-files">Open files <a class="header-anchor" href="#open-files" aria-hidden="true">&#128279;</a></h3>
<pre><code>$ open nginx.conf
$ open -a TextEdit nginx.conf
</code></pre>
]]></description><pubDate>Wed Nov 08 2017 10:41:01 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/common-used-commands</link><guid isPermaLink="true">https://blog.wxsm.space/p/common-used-commands</guid></item><item><title>Vue-Router Note</title><description><![CDATA[<p>Vue Router (<a href="https://github.com/vuejs/vue-router">https://github.com/vuejs/vue-router</a>) 使用笔记。虽然<a href="https://router.vuejs.org/">官方文档</a>比较详尽，但实际用起来依然有些地方需要特别注意的（其实主要是我的个人需求）。</p>
<!--more-->
<h2 id="scroll-behaviours">Scroll Behaviours <a class="header-anchor" href="#scroll-behaviours" aria-hidden="true">&#128279;</a></h2>
<p>文档上有 scroll behaviours 的示例，但实际上用起来不太完美，还需要自己改造一下。需要注意的是 <code>scrollBehavior</code> 必须搭配 <code>history</code> 模式，否则代码无效且无任何错误信息。</p>
<p>上面说到<strong>不完美</strong>的地方主要是在模拟 'scroll to anchor' 这一行为时，文档的代码是不够好的：</p>
<pre><code class="language-javascript">scrollBehavior (to, <span class="hljs-keyword">from</span>, savedPosition) {
  <span class="hljs-keyword">if</span> (to.hash) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">selector</span>: to.hash
    }
  }
}
</code></pre>
<p>这里实际上会调用 <code>querySelector(to.hash)</code> 来实现滚动，但是用起来会发现有些时候这段会报错，因为类似 <code>#1-anything</code> 这样的数字（或者其他非字母字符）打头的 hash 作为 selector 是 <strong>Invalid</strong> 的。但是要修复只需要稍微改动一下就好了：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">if</span> (to.hash) {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">selector</span>: <span class="hljs-string">`[id='<span class="hljs-subst">${to.hash.slice(<span class="hljs-number">1</span>)}</span>']`</span>
  }
}
</code></pre>
<p>所以一段完善的 scroll behaviour 代码应该是：</p>
<pre><code class="language-javascript">scrollBehavior (to, <span class="hljs-keyword">from</span>, savedPosition) {
  <span class="hljs-keyword">if</span> (to.hash) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">selector</span>: <span class="hljs-string">`[id='<span class="hljs-subst">${to.hash.slice(<span class="hljs-number">1</span>)}</span>']`</span>
    }
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (savedPosition) {
    <span class="hljs-keyword">return</span> savedPosition
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> {<span class="hljs-attr">x</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">0</span>}
  }
}
</code></pre>
<p>它可以做到在路由变化时：</p>
<ol>
<li>有锚点时滚动到锚点</li>
<li>有历史位置时滚动到历史位置</li>
<li>都没有时滚动到页头</li>
</ol>
<h2 id="lazy-loading">Lazy Loading <a class="header-anchor" href="#lazy-loading" aria-hidden="true">&#128279;</a></h2>
<p>官方的 Lazy load 示例代码换了很多茬，比如之前有类似 <code>require('...', resolve)</code> 的，还有用 <code>System.import</code> 的，但是它们并不能向后兼容，所以如果用的是新版本的话，并不能够直接 copy 旧项目的方式。目前感觉会稳定下来的方式是：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> Foo = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./Foo.vue'</span>)
</code></pre>
<p>但是这里又有一个注意点，以上语法必须引入一个 babel 插件 <a href="https://babeljs.io/docs/plugins/syntax-dynamic-import/">syntax-dynamic-import</a> 才行：</p>
<pre><code class="language-bash">npm install --save-dev babel-plugin-syntax-dynamic-import
</code></pre>
<p><strong>.babelrc</strong></p>
<pre><code class="language-json">{
  <span class="hljs-attr">"plugins"</span>: [<span class="hljs-string">"syntax-dynamic-import"</span>]
}
</code></pre>
<p>以上就可以在 webpack + babel 的环境下实现代码分块了。</p>
<h2 id="progress">Progress <a class="header-anchor" href="#progress" aria-hidden="true">&#128279;</a></h2>
<p>经常会有这样的需求（尤其是使用 lazy load 时）：路由跳转时提供一个进度条（像 Github 头部那种），然而 Vue Router 没有提供这方面的示例。经过实际使用发现，并不需要刻意使用 Vue 封装的进度条，比如说轻量级的 <a href="https://github.com/rstacruz/nprogress">nprogress</a> 也可以很好地搭配使用。</p>
<p>但是需要注意的是，Vue Router 会将 hash 跳转也视为一次 route 跳转，因此如果在全局钩子中注册 progress 方法的话，那么它也会在 hash 跳转中出现，实际上应该是不需要的。所以需要一点点判断：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> NProgress <span class="hljs-keyword">from</span> <span class="hljs-string">'nprogress'</span>

<span class="hljs-comment">// ...</span>

router.beforeEach(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> {
  <span class="hljs-comment">// not start progressbar on same path &amp;&amp; not the same hash</span>
  <span class="hljs-comment">// which means hash jumping inside a route</span>
  <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">from</span>.path === to.path &amp;&amp; <span class="hljs-keyword">from</span>.hash !== to.hash)) {
    NProgress.start()
  }
  next()
})

router.afterEach(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> {
  <span class="hljs-comment">// Finish progress</span>
  NProgress.done()
})
</code></pre>
<p>以上就是一个简单的页面跳转进度条示例，它会在<strong>除了同页 hash 跳转以外的所有页面跳转</strong>行为发生时，在页头显示一个简单的进度条。</p>
<h2 id="active-style">Active Style <a class="header-anchor" href="#active-style" aria-hidden="true">&#128279;</a></h2>
<p>当使用 <code>&lt;router-link&gt;</code> 的时候，Vue Router 会自动给当前路由的 link 加一个 active class，用来做 nav menu 时非常方便。但是有一点需要注意的是，它默认并不是一个精确匹配的模式，而是一个 <strong>matchStart</strong>，比如说 <code>&lt;router-link to=&quot;/a&quot;&gt;</code> 会被一个 <code>/a/b</code> 的路由激活，更甚者，<code>&lt;router-link to=&quot;/&quot;&gt;</code> 会被所有路由激活（真的）。然而这一般来说都不会是想要的结果。</p>
<p>在老旧版本（0.x）的 Vue-Router 中这个问题是无解的，现在则<strong>可以使用 <code>&lt;router-link exact&gt;</code> 来将它转换为精确匹配</strong>。</p>
<h2 id="route-reuse">Route Reuse <a class="header-anchor" href="#route-reuse" aria-hidden="true">&#128279;</a></h2>
<p>当使用 <code>&lt;router-view&gt;</code> 时，默认会启用组件复用，也就是说在可能的情况下，作为路由页面的组件不会被销毁重建，而是直接复用。</p>
<p>就好像一个博客的文章页面，一般来说会是给出这样的路由配置：<code>/post/:id</code>，那么在从 <code>/post/1</code> 跳转到 <code>/post/2</code> 的时候，实际上路由组件是不会重建的。</p>
<p>有时候我们会想要避免这样的事情发生，因为一个路由可能在创建的时候有比较多的逻辑（如数据动态获取、判断等），如果它在路由变化的时候直接复用的话，那么 <code>mount</code> 方法将不再被调用，我们还要为 <code>update</code> 再写一套类似的逻辑。<strong>更过分的是</strong>，其所用到的所有子组件也不再会执行 <code>mount</code> 方法，那么我们要为所有子组件编写 <code>update</code> 方法。非常麻烦。</p>
<p>不知道为什么，老版本的文档是有为这种情况提供解决方案的，但是在现在的文档里面找不到了。实际上很简单：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"$route.path"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span>
</code></pre>
<p>就这样就可以了。如此一来，<strong>只要在 <code>$route.path</code> 变化的时候，路由组件就会被销毁重建</strong>。用一点点的性能损耗，节省大量冗余代码。</p>
<p>当然这里也可以使用定制化逻辑来控制，比如使用 computed value 来实现更复杂的复用逻辑。</p>
]]></description><pubDate>Mon Nov 06 2017 02:47:50 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/vue-router-note</link><guid isPermaLink="true">https://blog.wxsm.space/p/vue-router-note</guid></item><item><title>Limit Prerender Plugin Workers By Webpack</title><description><![CDATA[<p><a href="https://github.com/chrisvfritz/prerender-spa-plugin">Prerender SPA Plugin</a> 是一个可以将 Vue 页面预渲染为静态 HTML 的 webpack 插件，对静态小站（比如博客）来说很棒棒。但是最近用的时候总发现一个问题：它的 build 失败率越来越高，尤其是在 CI 上。后来在其 repo 的一个 <a href="https://github.com/chrisvfritz/prerender-spa-plugin/issues/53">issue</a> 中发现了问题所在，就是它没有限制 PhantomJS workers 的数量，导致页面一多就直接全部卡死不动，然后超时。</p>
<blockquote>
<p>(Workers) Default is as many workers as routes.</p>
</blockquote>
<p>虽然有人已经发了 <a href="https://github.com/chrisvfritz/prerender-spa-plugin/pull/55">PR</a> 来修复这个问题，然而好几个月过去了也没有 merge，不知道是什么情况。于是我在自己的尝试中找到了一种可以接受的解决方案：虽然我不能限制你插件 workers 的数量，但是可以限制每个插件渲染的 route 数量呀。</p>
<p>具体思路就是：</p>
<ol>
<li>将所有的 route chunk 成小组，比如 10 个一组</li>
<li>针对每一个 chunk 创建一个 prerender 插件</li>
<li>将所有插件都加入到 webpack plugin 中去</li>
</ol>
<p>这样一来，就可以保证每个 plugin 最多同时创建 10 个 worker，全部渲染完成后再由下一个 plugin 接着工作。</p>
<p>简单的代码示例：</p>
<pre><code class="language-javascript"><span class="hljs-comment">// Generate url list for pre-render</span>
exports.generateRenderPlugins = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">let</span> paths = [] <span class="hljs-comment">// the routes</span>
  <span class="hljs-keyword">let</span> chunks = _.chunk(paths, <span class="hljs-number">10</span>) <span class="hljs-comment">// using lodash.chunk</span>
  <span class="hljs-keyword">let</span> plugins = []
  <span class="hljs-keyword">let</span> distPath = path.join(__dirname, <span class="hljs-string">'../dist'</span>)
  <span class="hljs-keyword">let</span> progress = <span class="hljs-number">0</span>
  chunks.forEach(<span class="hljs-function"><span class="hljs-params">chunk</span> =&gt;</span> {
    plugins.push(<span class="hljs-keyword">new</span> PrerenderSpaPlugin(distPath, chunk, {
        postProcessHtml (context) {
          <span class="hljs-comment">// need to log something after each route finish</span>
          <span class="hljs-comment">// or CI will fail if no log for 10 mins</span>
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`[PRE-RENDER] (<span class="hljs-subst">${++progress}</span> / <span class="hljs-subst">${paths.length}</span>) <span class="hljs-subst">${context.route}</span>`</span>)
          <span class="hljs-keyword">return</span> context.html
        }
      }
    ))
  })
  <span class="hljs-keyword">return</span> plugins
}
</code></pre>
]]></description><pubDate>Sun Oct 29 2017 02:51:17 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/limit-prerender-plugin-workers-by-webpack</link><guid isPermaLink="true">https://blog.wxsm.space/p/limit-prerender-plugin-workers-by-webpack</guid></item><item><title>Better Documents</title><description><![CDATA[<p>这篇文章记录了我是如何一步步地把 <a href="https://github.com/wxsms/uiv">https://github.com/wxsms/uiv</a> 这个项目的用户文档变得更优雅的。实际上，如何以一种<strong>高效又优雅</strong>的方式编写<strong>实例文档</strong>一直是我的一个疑惑，比如主要的问题体现在：</p>
<ul>
<li>如何使文档更易读？</li>
<li>如何使文档更易于维护？</li>
<li>如何减少编写文档的工作量？</li>
<li>实例代码无可避免地需要手工维护吗？</li>
</ul>
<p>最后一点是让我最头疼的地方。举个例子，我想要给用户展示一个组件的使用方式，以下代码可以在页面上创建一个 Alert：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">alert</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"success"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>Well done!<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span> You successfully read this important alert message.<span class="hljs-tag">&lt;/<span class="hljs-name">alert</span>&gt;</span>
</code></pre>
<p>那么，我总要给用户一个相对应的<strong>实例</strong>吧。我要在我的文档上面就创建一个这样的 Alert，同时告诉用户说你可以这么用。这是一个很普遍的展示方式，那么问题就在这里了，我是否要将<strong>同样的代码写两次</strong>呢？</p>
<p>一开始我确实就是这么做的，虽然我知道这不科学，不高效，更不优雅。但我实在是想不到更好的办法了。</p>
<p>但是，现在，我已经（几乎）把以上的问题都解决了。</p>
<!--more-->
<h2 id="stage-1">Stage-1 <a class="header-anchor" href="#stage-1" aria-hidden="true">&#128279;</a></h2>
<p>写文档这件事，实际上跟写文章差不多，写作体验很重要。</p>
<p>在最开始的时候，项目文档是直接用 Vue 文件编写的，没有经过任何处理，没有经验的我甚至还作死地加入了 i18n，可以说是非常有趣了。以至于到最近，在没有发生这次重构之前，我根本不想动它们。</p>
<p>可以想象，我给关键字句加个粗要手写 <code>&lt;b&gt;...&lt;/b&gt;</code>，标记一点代码要用 <code>&lt;code&gt;...&lt;/code&gt;</code>，每写一段话都要注意标签标签标签，文档里充斥这些东西，烦不胜烦。</p>
<p>这阶段的文档，存在的问题主要有：</p>
<ul>
<li>难以编写</li>
<li>无法在网站以外的地方阅读（因为是 Vue 源码）</li>
<li>给项目增加了许多额外代码</li>
<li>手工维护的实例代码</li>
</ul>
<h2 id="stage-2">Stage-2 <a class="header-anchor" href="#stage-2" aria-hidden="true">&#128279;</a></h2>
<p>以上提到的写作体验令人作呕，经过了漫长的时间后，在这一阶段得到了解决。某次机缘巧合，我发现了这样一个工具，它可以通过 webpack 将 Markdown 格式的文本直接转换成为 Vue 组件：<a href="https://github.com/QingWei-Li/vue-markdown-loader">vue-markdown-loader</a></p>
<p>比如：</p>
<pre><code class="language-javascript"><span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.md$/</span>,
        <span class="hljs-attr">loader</span>: <span class="hljs-string">'vue-markdown-loader'</span>
      }
    ]
  }
};
</code></pre>
<p>这样一来，就可以通过 <code>import [*].md</code> 的方式，得到一个内含 Markdown 内容（已转 HTML）的 Vue 组件。可以直接在页面上用了！</p>
<p>如果不考虑<strong>实例</strong>部分的话，这就已经完美了。准确地说，如果一开始就不需要实例这种东西，那么我肯定会直接用 Gitbook 了。也不需要这个 markdown to vue 来做什么。</p>
<hr>
<p>经过了长时间的折磨的我身心疲惫，最终还是决定尝试一下。</p>
<p>然而，就在这个尝试的过程中惊喜地发现：<strong>它居然还可以执行 Markdown 中的 Code block 中的代码！</strong></p>
<p>这是什么鬼。一开始发现这个的时候我还是很惊讶的。仿佛打开了新世界的大门。</p>
<p><strong>在后来的不断尝试 - 失败 - 尝试的过程中，我发现了它更多的 Feature：</strong></p>
<ul>
<li>可以执行 Code blocks 中的代码（<code>&lt;script&gt;</code>）</li>
<li>可以执行 Code blocks 中的样式（<code>&lt;style&gt;</code>）</li>
<li>可以通过插件给文档 header 加锚点</li>
</ul>
<p><strong>但是，也发现了以下问题：</strong></p>
<ul>
<li>多个 Code blocks 中的 <code>&lt;style&gt;</code> 可以合并，但 <code>&lt;script&gt;</code> 不行，<strong>它始终只会执行所找到的第一段 <code>&lt;script&gt;</code></strong></li>
</ul>
<p>通过查阅 <code>vue-loader</code> 的文档发现，这是 <code>.vue</code> 文件本身的限制：支持多个 <code>&lt;template&gt;</code>，多个 <code>&lt;style&gt;</code>，<strong>一个 <code>&lt;script&gt;</code></strong></p>
<p>也就是说，如果页面上有多个实例需要展示的话，给给。</p>
<p>如果这个问题能够解决的话，再结合我本身的需求，以下内容也需要实现：</p>
<ul>
<li>将实例代码中的 <code>&lt;template&gt;</code> 模板插入到其代码块之前，让其成为 Markdown 文件的一部分，然后 Vue 就会自动将它们统统实例化</li>
</ul>
<hr>
<p><strong>其实到了这里，也就是这两个问题需要解决了。</strong></p>
<p>首先是<strong>模板插入</strong>的问题。这个其实不难，在 Markdown 完成渲染前，通过一些手段找到这些需要渲染的模板，然后手动插入。幸而 loader 提供了 <code>preprocess</code> 钩子，让我能直接完成这件事情。</p>
<p>然后，关于 <code>&lt;script&gt;</code> 这块，我尝试了好久好久，实在是没办法。但是又真的舍不得因为这仅仅一个问题丢弃以上的那么多的好处。于是就想到了一个折中的办法：禁用 loader 的自动执行代码功能，并手动组装代码块。然而一个悲催的问题又出现了：禁用自动代码执行后，<code>&lt;style&gt;</code> 也无法自动执行了。</p>
<p>解决方案：我需要在 <code>preprocess</code> 中将 Code blocks 里面的 <code>&lt;style&gt;</code> 块全部切出来，贴到 code blocks 的外面（比如文件结尾处）去。一开始我还尝试了将它们的内容合并成为一个 <code>&lt;style&gt;</code>，后来发现其实不需要，因为 <code>vue-loader</code> 本身就支持一个文件多个 <code>&lt;style&gt;</code> 节点。</p>
<p>最后的最后，轮到了 <code>&lt;script&gt;</code> 的组装。我尝试了很久的自动合并，比如将它们的 export 内容转为 object 再 merge 啦，function 转为 object 再 merge 啦，toString 再 merge 啦，等等等等，然而各种方式都以失败告终。结论是：我无法将数个字符串代码块直接合并，也无法转为 object 再合并再转回字符串。实在的实在是没办法了，hard code 吧。</p>
<hr>
<p>至此，一个新的解决方案就出现了。简单来说，编写一片文档，我需要做以下的事情：</p>
<ul>
<li>用 Markdown 写文档以及实例代码</li>
<li>实例代码块中加入约定的标志</li>
<li>注意同一个 Markdown 中的实例代码块的 <code>&lt;script&gt;</code> 不能相互冲突</li>
<li>做完所有事情以后，用我自己用智商和爱将所有的实例代码合并成一份</li>
</ul>
<p>大功告成。</p>
<p>虽然依然有些麻烦，但相比与 Stage-1，我至少解决了以下的大事：</p>
<ul>
<li>文档编写体验大幅度提升！</li>
<li>文档可以在网站以外的地方被阅读（如 Github）</li>
<li>实例的 <code>&lt;template&gt;</code> 与 <code>&lt;style&gt;</code> 代码无需再有特殊照顾</li>
<li>维护工作量大大减少</li>
</ul>
<p>依然存在的问题是：</p>
<ul>
<li>实例的 <code>&lt;script&gt;</code> 代码需要维护两份，而且不能彼此冲突</li>
</ul>
<h2 id="stage-3">Stage-3 <a class="header-anchor" href="#stage-3" aria-hidden="true">&#128279;</a></h2>
<p>虽然解决了 80% 的问题，但 Stage-2 依然不完美。我始终想要解决最后一个问题：<strong>无需特殊照顾的实例 <code>&lt;script&gt;</code></strong></p>
<p>想要达到这个目标，有一个完美的办法就是：<strong>将实例也作为子组件来插入到 Markdown 父组件中去</strong>。这样一来，同一页面的实例代码无法冲突的问题也就一并解决了。</p>
<p>显然，通过目前的 loader 无法达到我想要的效果，它只能够简单地将代码插入 Markdown，并不能构建子组件。因此，要解决这个问题，<strong>我需要自己造轮子</strong>。</p>
<p>......</p>
<hr>
<p>于是就有了：</p>
<p><a href="https://github.com/wxsms/vue-md-loader">https://github.com/wxsms/vue-md-loader</a></p>
<p>关于这个轮子，它是原有 markdown-loader 的一个替代品，<strong>并且能够解决以上提出的所有问题</strong>。</p>
<p>除了完善的原有 Markdown 转换功能以外，它还可以将 Markdown 中的实例代码，比如：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"cls"</span>&gt;</span>{{msg}}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    data () {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">msg</span>: <span class="hljs-string">'Hello world!'</span>
      }
    }
  }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
  <span class="hljs-selector-class">.cls</span> {
    <span class="hljs-attribute">color</span>: red;
    <span class="hljs-attribute">background</span>: green;
  }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-comment">&lt;!-- some-live-demo.vue --&gt;</span>
</code></pre>
<p>变成类似这样的结构：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">some-live-demo</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span>
</code></pre>
<blockquote>
<p>A <strong>Vue component</strong> with all it's <code>&lt;template&gt;</code>, <code>&lt;script&gt;</code> and <code>&lt;style&gt;</code> settled will be <strong>inserted before it's source code block</strong>.</p>
</blockquote>
<p>毫无疑问，它<strong>支持同一文件中的多个代码块</strong>。</p>
<p>关于这个插件，其实就是一个典型的、简单的 webpack loader，将一个 markdown 文件转换成了可以被 <code>vue-loader</code> 识别并加载的 vue 文件。</p>
<p>它的实现思路主要有：</p>
<ul>
<li>将实例代码块中的 <code>&lt;style&gt;</code> 直接截取，并放到 Markdown 组件下</li>
<li>将实例代码块中的 <code>&lt;script&gt;</code> 中 <code>export default</code> 的内容截取，并作为各自的 Component options</li>
<li>加上相应代码块中的 <code>&lt;template&gt;</code> 中的内容，稍微组装一下，它就成为了一个 Vue component</li>
<li>在 Markdown 组件中局部注册该 component，并将它插入到代码块的前面去</li>
<li>对于 <code>export default</code> 外部的内容，把它们抽取出来，集中放到 Markdown 组件下</li>
</ul>
<p>以上这些操作，全部通过字符串与正则操作就足以完成了。</p>
<p>然而可以发现，这里面仍有一些有待解决的问题：</p>
<ul>
<li><code>&lt;style&gt;</code> 有可能冲突</li>
<li><code>export default</code> 之外的内容有可能冲突</li>
</ul>
<p>这两个问题目前也还没有想到有效的解决办法。但是，就目前来说，满足我的需求已经完全足够了。遗留问题通过后续的开发来逐步解决吧。</p>
<hr>
<p>至此，优雅地编写项目文档的全部要素就齐备了：</p>
<ul>
<li>纯文档编写体验（Markdown）</li>
<li>文档可以在网站以外的地方被阅读（如 Github）</li>
<li>实例代码均无需特殊照顾，所有过程自动完成</li>
<li>没有维护压力</li>
</ul>
<p><strong>Enjoy!</strong></p>
]]></description><pubDate>Fri Oct 27 2017 06:43:01 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/better-documents</link><guid isPermaLink="true">https://blog.wxsm.space/p/better-documents</guid></item><item><title>Difference Between NPM Dependencies Types</title><description><![CDATA[<p>ref: <a href="https://stackoverflow.com/questions/18875674/whats-the-difference-between-dependencies-devdependencies-and-peerdependencies">stackoverflow</a></p>
<p>Summary of important behavior differences:</p>
<ul>
<li><strong><code>dependencies</code></strong> are installed on both:
<ul>
<li><code>npm install</code> from a directory that contains <code>package.json</code></li>
<li><code>npm install $package</code> on any other directory</li>
</ul>
</li>
<li><strong><code>devDependencies</code></strong> are:
<ul>
<li>also installed on <code>npm install</code> on a directory that contains <code>package.json</code>, unless you pass the <code>--production</code> flag</li>
<li>not installed on <code>npm install $package</code> on any other directory, unless you give it the <code>--dev</code> option.</li>
<li>are not installed transitively.</li>
</ul>
</li>
<li><strong><code>peerDependencies</code></strong> are:
<ul>
<li>before 3.0: are always installed if missing, and raise an error if multiple incompatible versions of the dependency would be used by different dependencies.</li>
<li>expected starting on 3.0 (untested): give a warning if missing on <code>npm install</code>, and you have to solve the dependency yourself manually. When running, if the dependency is missing, you get an error.</li>
</ul>
</li>
<li><strong>Transitivity</strong>:
<ul>
<li><code>dependencies</code> are installed transitively: if A requires B, and B requires C, then C gets installed, otherwise B could not work, and neither would A.</li>
<li><code>devDependencies</code> are not installed transitively. E.g. we don't need to test B to test A, so B's testing dependencies can be left out.</li>
</ul>
</li>
</ul>
]]></description><pubDate>Mon Oct 16 2017 07:36:52 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/difference-between-npm-dependencies-types</link><guid isPermaLink="true">https://blog.wxsm.space/p/difference-between-npm-dependencies-types</guid></item><item><title>CORS Headers Note</title><description><![CDATA[<p>CORS HTTP Header 是解决 Ajax 跨域问题的方案之一。详情查看：<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS">MDN</a></p>
<p>这篇文章主要是记录使用过程中遇到的问题以及解决方案。</p>
<!--more-->
<h2 id="">客户端 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h2>
<p>客户端正常情况无需特殊配置。但有一些需要注意的地方。</p>
<h3 id="-2">请求预检 <a class="header-anchor" href="#-2" aria-hidden="true">&#128279;</a></h3>
<p>CORS 请求与非跨域请求不一样的是，它会将请求分成两种类型：<strong>Simple Request（简单请求）<strong>与</strong>Preflighted Request（预检请求）</strong>。</p>
<h4 id="simple-request">Simple Request <a class="header-anchor" href="#simple-request" aria-hidden="true">&#128279;</a></h4>
<p>满足<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS#Simple_requests">所有条件</a>的请求为简单请求。</p>
<p>看了文档以后发现跟普通请求别无二致。</p>
<h4 id="preflighted-request">Preflighted Request <a class="header-anchor" href="#preflighted-request" aria-hidden="true">&#128279;</a></h4>
<p>满足<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS#Preflighted_requests">任一条件</a>的请求为预检请求。</p>
<p>与简单请求不同，预检请求要求必须首先使用 <code>OPTIONS</code> 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求，以避免跨域请求对服务器的用户数据产生未预期的影响。</p>
<p><img src="https://mdn.mozillademos.org/files/14289/prelight.png" alt="预检请求示意图"></p>
<p>所以，实际上这种跨域请求会产生两次 HTTP Request：一个预检请求，以及预检成功后的真正的请求。由于预检请求使用 <code>OPTIONS</code> 方法而不是常见的 <code>POST</code> 等，因此服务器必须为跨域 API 提供能够正确返回的相应方法。</p>
<h3 id="-3">身份验证 <a class="header-anchor" href="#-3" aria-hidden="true">&#128279;</a></h3>
<p>如果需要进行 Cookie / Session / HTTP Authentication 等操作，则必须在进行 Ajax 请求时带上一个 <code>withCredentials</code> 参数。至于如何带这个参数，每个 Lib 应该都有自己的配置方式，下面是两个例子。</p>
<p>Raw Ajax Example:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> invocation = <span class="hljs-keyword">new</span> XMLHttpRequest();
<span class="hljs-keyword">var</span> url = <span class="hljs-string">'http://bar.other/resources/credentialed-content/'</span>;
    
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callOtherDomain</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-keyword">if</span>(invocation) {
    invocation.open(<span class="hljs-string">'GET'</span>, url, <span class="hljs-literal">true</span>);
    invocation.withCredentials = <span class="hljs-literal">true</span>;
    invocation.onreadystatechange = handler;
    invocation.send(); 
  }
}
</code></pre>
<p>Using Axios Example:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">let</span> corsAgent = axios.create({
  <span class="hljs-attr">withCredentials</span>: <span class="hljs-literal">true</span>
})
</code></pre>
<h2 id="-4">服务端 <a class="header-anchor" href="#-4" aria-hidden="true">&#128279;</a></h2>
<p>服务端的配置并不是只需要给请求响应加个 <code>Access-Control-Allow-Origin</code> Header 这么简单，还有其它需要处理的地方。因此自己做远不如直接使用相关 Lib 来得方便。比如：</p>
<ul>
<li><a href="https://github.com/expressjs/cors">Express CORS</a></li>
<li><a href="https://github.com/koajs/cors">Koa CORS</a></li>
</ul>
<h3 id="withcredentials">withCredentials <a class="header-anchor" href="#withcredentials" aria-hidden="true">&#128279;</a></h3>
<p>当启用 <code>withCredentials</code> 参数后，<code>Access-Control-Allow-Origin</code> 将不能设置为 <code>*</code> （允许所有域名），必须指定为唯一的域名，否则预期的效果将无法达到。由于这个规则不会产生 Warning 或 Error，出了问题不了解情况的话还是比较难发现的。</p>
<p>可以预见（事实）的是，当 <code>Access-Control-Allow-Origin</code> 指定了唯一域名后，使用其它域名访问该 API 也会出现无效的问题。不过相应地也有一个取巧的办法，就是将它设置为 Request 的 Origin Header，这样一来问题就解决了。</p>
]]></description><pubDate>Thu Oct 12 2017 06:44:39 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/cors-headers-note</link><guid isPermaLink="true">https://blog.wxsm.space/p/cors-headers-note</guid></item><item><title>终于要放假了</title><description><![CDATA[<p>最近事情有点多，导致好久没有更新过博客。过完后天终于要到国庆假期了，希望可以多点时间在家休息（睡觉）。经常加班到 10 点，周末也时常单休，连续下来还是挺累人的。</p>
<p>公司的饭菜开始吃腻了，每天都能找到不想吃的菜（或者找不到想吃的菜）。</p>
<p>假期一定要抽空把这几个月学到的东西总结一下。</p>
]]></description><pubDate>Fri Sep 29 2017 17:01:00 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/holiday-soon-finally</link><guid isPermaLink="true">https://blog.wxsm.space/p/holiday-soon-finally</guid></item><item><title>Koa Note</title><description><![CDATA[<blockquote>
<p>Koa是一个类似于 Express 的 Web 开发框架，创始人也是同一个人。它的主要特点是，使用了 ES6 的 Generator 函数，进行了架构的重新设计。也就是说，Koa的原理和内部结构很像 Express，但是语法和内部结构进行了升级。</p>
<p>—— <cite>阮一峰博客</cite></p>
</blockquote>
<p><strong>想要达到使用 Koa2 的完整体验，需要将 Node 版本升级到 v7.6+ 以支持 async 语法。</strong></p>
<p><strong>为什么是 Koa 而不是 Express 4.0？</strong></p>
<p>因为 Generator 带来的改动太大了，相当于推倒重来。</p>
<p><strong>以下内容基于 Koa2</strong></p>
<!--more-->
<h2 id="">应用 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h2>
<p>一个 Koa Application（以下简称 app）由一系列 generator 中间件组成。按照编码顺序在栈内依次执行，从这个角度来看，Koa app 和其他中间件系统（比如 Ruby Rack 或者 Connect / Express ）没有什么太大差别。</p>
<p>简单的 Hello World 应用程序:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> Koa = <span class="hljs-built_in">require</span>(<span class="hljs-string">'koa'</span>);
<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Koa();

<span class="hljs-comment">// response</span>
app.use(<span class="hljs-function"><span class="hljs-params">ctx</span> =&gt;</span> {
  ctx.body = <span class="hljs-string">'Hello Koa'</span>;
});

app.listen(<span class="hljs-number">3000</span>);
</code></pre>
<h2 id="-2">级联代码 <a class="header-anchor" href="#-2" aria-hidden="true">&#128279;</a></h2>
<p>Koa 中间件以一种非常传统的方式级联起来。</p>
<p>在以往的 Node 开发中，频繁使用回调不太便于展示复杂的代码逻辑，在 Koa 中，我们可以写出真正具有表现力的中间件。与 Connect 实现中间件的方法相对比，Koa 的做法不是简单的将控制权依次移交给一个又一个的中间件直到程序结束，而有点像“穿越一只洋葱”。</p>
<p><img src="https://camo.githubusercontent.com/d80cf3b511ef4898bcde9a464de491fa15a50d06/68747470733a2f2f7261772e6769746875622e636f6d2f66656e676d6b322f6b6f612d67756964652f6d61737465722f6f6e696f6e2e706e67" alt="图示 Koa 中间件级联"></p>
<p>下边这个例子展现了使用这一特殊方法书写的 Hello World 范例。</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> Koa = <span class="hljs-built_in">require</span>(<span class="hljs-string">'koa'</span>);
<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Koa();

<span class="hljs-comment">// x-response-time</span>
app.use(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ctx, next</span>) </span>{
  <span class="hljs-comment">// (1) 进入路由</span>
  <span class="hljs-keyword">const</span> start = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
  <span class="hljs-keyword">await</span> next();
  <span class="hljs-comment">// (5) 再次进入 x-response-time 中间件，记录2次通过此中间件「穿越」的时间</span>
  <span class="hljs-keyword">const</span> ms = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>() - start;
  <span class="hljs-comment">// (6) 返回 this.body</span>
  ctx.set(<span class="hljs-string">'X-Response-Time'</span>, <span class="hljs-string">`<span class="hljs-subst">${ms}</span>ms`</span>);
});

<span class="hljs-comment">// logger</span>
app.use(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ctx, next</span>) </span>{
  <span class="hljs-comment">// (2) 进入 logger 中间件</span>
  <span class="hljs-keyword">const</span> start = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
  <span class="hljs-keyword">await</span> next();
  <span class="hljs-comment">// (4) 再次进入 logger 中间件，记录2次通过此中间件「穿越」的时间</span>
  <span class="hljs-keyword">const</span> ms = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>() - start;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${ctx.method}</span> <span class="hljs-subst">${ctx.url}</span> - <span class="hljs-subst">${ms}</span>`</span>);
});

<span class="hljs-comment">// response</span>
app.use(<span class="hljs-function"><span class="hljs-params">ctx</span> =&gt;</span> {
  <span class="hljs-comment">// (3) 进入 response 中间件</span>
  ctx.body = <span class="hljs-string">'Hello World'</span>;
});

app.listen(<span class="hljs-number">3000</span>);
</code></pre>
<p>也许刚从 Express 过来的同学会一脸懵逼，实际上我们可以把它想象成这样的一个流程（类似 LESS 代码）：</p>
<pre><code class="language-less"><span class="hljs-selector-class">.x-response-time</span> {
  <span class="hljs-comment">// (1) do some stuff</span>
  <span class="hljs-selector-class">.logger</span> {
    <span class="hljs-comment">// (2) do some other stuff</span>
    <span class="hljs-selector-class">.response</span> {
      <span class="hljs-comment">// (3) NO next yield !</span>
      <span class="hljs-comment">// this.body = 'hello world'</span>
    }
    <span class="hljs-comment">// (4) do some other stuff later</span>
  }
  <span class="hljs-comment">// (5) do some stuff lastest and return</span>
}
</code></pre>
<p>这便是 Koa 中间件的一大特色了。另一点也能在例子中找到：即 Koa 支持 <code>async</code> 以及 <code>await</code> 语法，可以在中间件中进行任意方式的使用（比如 await mongoose 操作），这样对比起来 Express 其优点就十分明显了。</p>
<h2 id="-3">常用的中间件 <a class="header-anchor" href="#-3" aria-hidden="true">&#128279;</a></h2>
<ul>
<li><a href="https://www.npmjs.com/package/koa-bodyparser">koa-bodyparser</a></li>
<li><a href="https://www.npmjs.com/package/koa-favicon">koa-favicon</a></li>
<li><a href="https://www.npmjs.com/package/koa-helmet">koa-helmet</a></li>
<li><a href="https://www.npmjs.com/package/koa-lusca">koa-lusca</a></li>
<li><a href="https://www.npmjs.com/package/koa-morgan">koa-morgan</a></li>
<li><a href="https://www.npmjs.com/package/koa-multer">koa-multer</a></li>
<li><a href="https://www.npmjs.com/package/koa-passport">koa-passport</a></li>
<li><a href="https://www.npmjs.com/package/koa-router">koa-router</a></li>
<li><a href="https://www.npmjs.com/package/koa-session">koa-session</a></li>
<li><a href="https://www.npmjs.com/package/koa-static-cache">koa-static-cache</a></li>
</ul>
<p>（等等）</p>
<h2 id="-4">错误处理 <a class="header-anchor" href="#-4" aria-hidden="true">&#128279;</a></h2>
<p>除非 <code>app.silent</code> 被设置为 <code>true</code>，否则所有 error 都会被输出到 <code>stderr</code>，并且默认的 error handler 不会输出 <code>err.status === 404 || err.expose === true</code> 的错误。可以自定义「错误事件」来监听 Koa app 中发生的错误，比如一个简单的例子：记录错误日志</p>
<pre><code class="language-javascript">app.on(<span class="hljs-string">'error'</span>, err =&gt;
  log.error(<span class="hljs-string">'server error'</span>, err)
);
</code></pre>
<h2 id="-5">应用上下文 <a class="header-anchor" href="#-5" aria-hidden="true">&#128279;</a></h2>
<p>Koa 的上下文（Context）将 request 与 response 对象封装至一个对象中，并提供了一些帮助开发者编写业务逻辑的方法。</p>
<p>每个 request 会创建一个 Context，并且向中间件中传引用值。</p>
<pre><code class="language-javascript">app.use(<span class="hljs-keyword">async</span> (ctx, next) =&gt; {
  ctx; <span class="hljs-comment">// is the Context</span>
  ctx.request; <span class="hljs-comment">// is a koa Request</span>
  ctx.response; <span class="hljs-comment">// is a koa Response</span>
});
</code></pre>
<p><strong>需要注意的是，挂载在 Context 对象上的并不是 Node.js 原生的 Response 和 Request 对象，而是经过 Koa 封装过的。Koa 提供另外的方法来访问原生对象，但是并不建议这么做！</strong></p>
<p>为了使用方便，许多上下文属性和方法都被委托代理到他们的 <code>ctx.request</code> 或 <code>ctx.response</code>，比如访问 <code>ctx.type</code> 和 <code>ctx.length</code> 将被代理到 <code>response</code> 对象，<code>ctx.path</code> 和 <code>ctx.method</code> 将被代理到 <code>request</code> 对象。</p>
]]></description><pubDate>Fri Jul 07 2017 16:11:00 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/koa-note</link><guid isPermaLink="true">https://blog.wxsm.space/p/koa-note</guid></item><item><title>为 Vue 组件库实现国际化支持</title><description><![CDATA[<p>其实这部分代码主要是参考着 element ui 和 iview 做的（iview 又是抄的 element），对关键代码进行了一些简化。主要需要实现的需求有：</p>
<ol>
<li>用户可以更改、切换组件库使用的语言（应用级别）</li>
<li>用户可以自定义组件使用的措辞</li>
<li>兼容 <code>vue-i18n</code> 这个库</li>
</ol>
<!--more-->
<h2 id="">关键代码 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h2>
<h3 id="srclocalelangen-usjs">src/locale/lang/en-US.js <a class="header-anchor" href="#srclocalelangen-usjs" aria-hidden="true">&#128279;</a></h3>
<p>首先是 Locale 文件，把措辞映射到一个 key 上面去，比如说英文：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">uiv</span>: {
    <span class="hljs-attr">datePicker</span>: {
      <span class="hljs-attr">clear</span>: <span class="hljs-string">'Clear'</span>,
      <span class="hljs-attr">today</span>: <span class="hljs-string">'Today'</span>,
      <span class="hljs-attr">month</span>: <span class="hljs-string">'Month'</span>,
      <span class="hljs-attr">month1</span>: <span class="hljs-string">'January'</span>,
      <span class="hljs-attr">month2</span>: <span class="hljs-string">'February'</span>,
      <span class="hljs-comment">// ...</span>
    }
  }
}
</code></pre>
<p>对应的中文文件只需要把相应的 Value 翻译成中文即可。这里有一个最基本的设想就是，<strong>如果需要增加一种语言，应该是只需要增加一个这样的文件即可</strong>。</p>
<h3 id="srclocaleindexjs">src/locale/index.js <a class="header-anchor" href="#srclocaleindexjs" aria-hidden="true">&#128279;</a></h3>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> defaultLang <span class="hljs-keyword">from</span> <span class="hljs-string">'./lang/en-US'</span>
<span class="hljs-keyword">let</span> lang = defaultLang

<span class="hljs-keyword">let</span> i18nHandler = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> vuei18n = <span class="hljs-built_in">Object</span>.getPrototypeOf(<span class="hljs-keyword">this</span>).$t
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> vuei18n === <span class="hljs-string">'function'</span>) {
    <span class="hljs-keyword">return</span> vuei18n.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>)
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> t = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">path, options</span>) </span>{
  <span class="hljs-keyword">let</span> value = i18nHandler.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>)
  <span class="hljs-keyword">if</span> (value !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">'undefined'</span>) {
    <span class="hljs-keyword">return</span> value
  }
  <span class="hljs-keyword">const</span> array = path.split(<span class="hljs-string">'.'</span>)
  <span class="hljs-keyword">let</span> current = lang

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, j = array.length; i &lt; j; i++) {
    <span class="hljs-keyword">const</span> property = array[i]
    value = current[property]
    <span class="hljs-keyword">if</span> (i === j - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> value
    <span class="hljs-keyword">if</span> (!value) <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>
    current = value
  }
  <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> use = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">l</span>) </span>{
  lang = l || lang
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> i18n = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fn</span>) </span>{
  i18nHandler = fn || i18nHandler
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {use, t, i18n}
</code></pre>
<p>这段代码乍一看挺复杂，其实弄明白后就很简单：</p>
<ol>
<li><code>i18nHandler</code> 是用来检测并套用 <code>vue-i18n</code> 的，如果用户安装了这个插件，则会使用绑定在 Vue 实例上的 <code>$t</code> 方法进行取值</li>
<li><code>t</code> 方法是用来取值的。首先看能否用 <code>i18nHandler</code> 取到，如果能取到则直接用，取不到就要自行解决了。最后返回取到（或者取不到，则为空）的值。</li>
<li><code>use</code> 与 <code>i18n</code> 这两个方法是在整个组件库作为插件被 Vue 安装的时候调用的，主要用来让用户自定义语言等等。</li>
</ol>
<p>原版的 <code>t</code> 方法有一个与之配合的模板字符串替换的方法（比如说处理 <code>My name is ${0}</code> 这种 Value），这里简洁起见把它删掉了，实际上也暂时用不到。</p>
<h3 id="srcmixinslocalejs">src/mixins/locale.js <a class="header-anchor" href="#srcmixinslocalejs" aria-hidden="true">&#128279;</a></h3>
<p>一个 mixin，很简单：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { t } <span class="hljs-keyword">from</span> <span class="hljs-string">'../locale'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">methods</span>: {
    t (...args) {
      <span class="hljs-keyword">return</span> t.apply(<span class="hljs-keyword">this</span>, args)
    }
  }
}
</code></pre>
<p>就是给组件加上一个 <code>t</code> 方法。那么现在组件在需要根据语言切换的地方，只要加入这个 mixin 并在输出的地方使用 <code>t(key)</code> 即可，比如 <code>t('uiv.datePicker.month1')</code> 在默认的配置下会使用 <code>January</code>，而如果用户配置了中文则会使用 <code>一月</code>。</p>
<h3 id="srccomponentsindexjs">src/components/index.js <a class="header-anchor" href="#srccomponentsindexjs" aria-hidden="true">&#128279;</a></h3>
<p>最后一步：将上述的两个方法 <code>use</code> 和 <code>i18n</code> 写入到组件库入口的 <code>install</code> 方法中去。</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> install = <span class="hljs-function">(<span class="hljs-params">Vue, options = {}</span>) =&gt;</span> {
  locale.use(options.locale)
  locale.i18n(options.i18n)
  <span class="hljs-comment">// ...</span>
}
</code></pre>
<h2 id="-2">如何使用 <a class="header-anchor" href="#-2" aria-hidden="true">&#128279;</a></h2>
<h3 id="-3">简单用法 <a class="header-anchor" href="#-3" aria-hidden="true">&#128279;</a></h3>
<p>切换中文：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> uiv <span class="hljs-keyword">from</span> <span class="hljs-string">'uiv'</span>
<span class="hljs-keyword">import</span> locale <span class="hljs-keyword">from</span> <span class="hljs-string">'uiv/src/locale/lang/zh-CN'</span>

Vue.use(uiv, { locale })
</code></pre>
<p>显然, 如果对预设的措辞不满意，我们还可以自定义, 只需要创造一个 <code>locale</code> 对象并替换之即可。</p>
<h3 id="vue-i18n">配合 Vue I18n 使用 <a class="header-anchor" href="#vue-i18n" aria-hidden="true">&#128279;</a></h3>
<p>只要跟着 <code>vue-i18n</code> 的文档把自己的 App 配好就行，不用管组件库，会自动适配。<strong>但有一点要注意：需要先将 组件库的语言包合并到 App 语言包中去</strong>。比如：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> uivLocale <span class="hljs-keyword">from</span> <span class="hljs-string">'uiv/src/locale/lang/zh-CN'</span>

<span class="hljs-keyword">let</span> appLocale = <span class="hljs-built_in">Object</span>.assign({}, uivLocale, {
  <span class="hljs-comment">// ...</span>
})

<span class="hljs-comment">// 接下来该干嘛干嘛</span>
</code></pre>
]]></description><pubDate>Thu Jun 08 2017 15:27:00 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/vue-components-i18n</link><guid isPermaLink="true">https://blog.wxsm.space/p/vue-components-i18n</guid></item><item><title>Travis CI in Github</title><description><![CDATA[<p>Travis CI 是一款免费的持续集成工具，可以与 Github 无缝集成。能够自动完成项目代码的日常测试、编译、部署等工作。现在，我把它应用到了我的两个项目中。</p>
<p>首先，要在这个平台上做持续集成的前提是到它上面 <a href="https://travis-ci.org/">https://travis-ci.org/</a> 去注册个账号。实际上直接用 Github 账号进行 OAuth 登录就行了。登录以后可以在首页找到自己的所有仓库，在需要进行持续集成的项目前面的开关打开即可。开启后，Travis CI 会监听项目的代码推送与 PR，当发生改变时会立刻进行相应操作。</p>
<p>至于具体操作内容，由项目根目录的 <code>.travis.yml</code> 文件决定。这个文件的简单用法由下面两个具体例子来说明。</p>
<!--more-->
<h2 id="wxsmsgithubio"><a href="http://wxsms.github.io">wxsms.github.io</a> <a class="header-anchor" href="#wxsmsgithubio" aria-hidden="true">&#128279;</a></h2>
<p>该项目就是这个博客了。因为它是静态博客，所以代码上线前都要进行一次打包过程，在之前这个工作是手动完成的，主要的流程如下：</p>
<ol>
<li>在 <code>src</code> 分支上进行代码编辑，</li>
<li>在 <code>src</code> 分支上 push</li>
<li>在 <code>src</code> 分支上运行 <code>npm run post</code> 与 <code>npm run build</code> 分别生成文章与博客代码</li>
<li>切换到 <code>master</code> 分支，将上一步打包编译出来的东西覆盖到相应目录下</li>
<li>在 <code>master</code> 分支上 push</li>
<li>切换回 <code>src</code> 分支</li>
</ol>
<p>这些步骤看似简单却又容易出错，每次想要刷博客都必须做这么多事情，烦不胜烦。而且，Github 仓库会因为充斥了无意义的 <code>master</code> 历史记录而变得臃肿与难看。</p>
<p>现在有了 Travis CI，一切都将变得简单。</p>
<p><code>.travis.yml</code> 文件内容：</p>
<pre><code>language: node_js
cache:
  directories:
  - node_modules
node_js:
  - &quot;node&quot;
script:
  - npm run post
  - npm run build
  - npm run dist-config
deploy:
  - provider: pages
    skip_cleanup: true
    github_token: $GITHUB_TOKEN
    local_dir: dist
    target_branch: master
    on:
      branch: src
</code></pre>
<p>说明：</p>
<ul>
<li><code>language</code> 指项目代码的语言，这里使用 <code>node_js</code></li>
<li><code>cache</code> 是 Travis CI 会缓存的内容，比如一些依赖文件无需每次都完全安装。这里缓存了 <code>npm_modules</code> 这个目录</li>
<li><code>node_js</code> 这里指定 node 的版本，<code>node</code> 的意思是使用最新版</li>
<li><code>script</code> 则是 Travis CI 具体会去完成的工作，是有顺序关系的，如果没有指定，则默认是 <code>npm run test</code>，这里依次执行了 3 个脚本：
<ul>
<li><code>npm run post</code> 打包文章</li>
<li><code>npm run build</code> 打包代码</li>
<li><code>npm run dist-config</code> 生成配置文件以及 Readme 等。前两步显而易见，至于第三步，因为 Travis 部署会是一个 force push 的过程，会删除原有分支上的所有内容，因此需要手动生成 Github 的 <a href="http://README.md">README.md</a> 文件以及 Github Page 的 CNAME 文件。</li>
</ul>
</li>
<li><code>deploy</code> 则是项目在所有脚本执行完成后会进行的部署操作，部署只会在脚本全部执行成功（返回 0）后进行
<ul>
<li>这里使用 <code>page</code> 即 Github Page 方式部署。</li>
<li><code>skip_cleanup</code> 这个参数用来防止 Travis 删除脚本生成的文件（删掉了就没意义了）</li>
<li><code>github_token</code> 是我们 Github 账号的 Access Token，因为私密原因不能写在代码文件里，因此可以在此写一个变量 <code>$GITHUB_TOKEN</code>，然后在 Travis 相应的仓库设置中添加 <code>GITHUB_TOKEN</code> 环境变量，Travis 会在运行时自动替换</li>
<li><code>local_dir</code> 是指需要部署的打包出来的目录，设置为 <code>dist</code> 目录</li>
<li><code>target_branch</code> 即目标分支，Travis 会将为 <code>dist</code> 目录整个部署到 <code>master</code> 分支上去</li>
<li><code>on</code> 则是附加条件。这里的含义应该是只监听 <code>src</code> 分支上的更改</li>
</ul>
</li>
</ul>
<p>因此，Travis 可以帮我完成以下工作</p>
<ul>
<li>监听 <code>src</code> 分支上的改动</li>
<li>出现改动时，自动执行所有 build 步骤</li>
<li>如果 build 成功则将相应文件部署到 <code>master</code> 分支上去</li>
</ul>
<p>如此一来，我自己需要做的事情就只剩下简单的两步了：</p>
<ol>
<li>在 <code>src</code> 分支上进行代码编辑</li>
<li>在 <code>src</code> 分支上 push</li>
</ol>
<p>在我无需关注发布过程的同时，Travis 还能帮我保持整个代码仓库的整洁（<code>master</code> 分支始终进行的都是 force push，不存在无用的历史记录），简直完美！</p>
<h2 id="uiv">uiv <a class="header-anchor" href="#uiv" aria-hidden="true">&#128279;</a></h2>
<p>这个项目其实也差不多，有些许变化：</p>
<ul>
<li>脚本变为：
<ul>
<li><code>npm run test</code> 执行测试</li>
<li><code>npm run build</code> 打包代码</li>
<li><code>npm run build-docs</code> 打包文档</li>
</ul>
</li>
<li>需要将代码部署到 npm，而文档部署到 Github Page</li>
<li>代码与文档都只在版本发布时（Tagged）才进行部署</li>
</ul>
<p><code>.travis.yml</code> 文件内容：</p>
<pre><code>language: node_js
cache:
  directories:
  - node_modules
node_js:
  - &quot;node&quot;
script:
  - npm run test
  - npm run build
  - npm run build-docs
after_success: 'npm run coveralls'

deploy:
  - provider: npm
    skip_cleanup: true
    email: &quot;edisond@qq.com&quot;
    api_key: $NPM_TOKEN
    on:
      tags: true
      branch: master
  - provider: pages
    skip_cleanup: true
    github_token: $GITHUB_TOKEN
    local_dir: docs
    on:
      tags: true
      branch: master
</code></pre>
<p>这个配置文件多了一些内容：</p>
<ul>
<li><code>after_success: 'npm run coveralls'</code> 这个是在所有脚本成功以后执行的，目的是与 Coveralls 集成来在项目仓库上添加测试覆盖率的集成，这个在后面说</li>
<li><code>deploy</code> 中增加了 <code>npm</code> 一项，配置内容跟 <code>pages</code> 基本一致，其中不同的：
<ul>
<li><code>email</code> 是用来发布的 npm 账户邮箱名</li>
<li><code>api_key</code> 是用来发布的 npm 账户 token，可以在本地 <code>~/.npmrc</code> 文件中找到（前提是本地电脑的 npm 已登录）</li>
<li><code>on</code> -&gt; <code>tags: true</code> 这个标志是说只在带有标签的 Commit 推送时才进行 deploy</li>
</ul>
</li>
<li>Github Page 的部署配置中也加入了 <code>on</code> -&gt; <code>tags: true</code>，起的是一样的作用。这里的 Github Page 是从 master 分支的 docs 文件夹 deploy 到 gh-pages 分支（gh-pages 是 Github Page 的默认分支，所以不用配置 <code>target_branch</code> 项）</li>
</ul>
<p>这样一来，Travis 就可以：</p>
<ul>
<li>在日常 push 的时候执行 test and build 脚本，但不发布</li>
<li>在版本 push 的时候执行 test and build 脚本，全部成功则将内容分别发布到 NPM 与 Github Pages</li>
</ul>
<p>完美！</p>
<h2 id="coveralls">关于 Coveralls <a class="header-anchor" href="#coveralls" aria-hidden="true">&#128279;</a></h2>
<p>Coveralls <a href="https://coveralls.io/">https://coveralls.io/</a> 是一个将代码测试覆盖率集成到 Github 的工具，在 Travis 的加持下，算是锦上添花的一项。同样，到相应网站注册账号是第一步。</p>
<p>由于 vue-cli 生成的项目默认已经附带了代码测试覆盖率的检测，我要做的只是把这个结果上传而已。</p>
<p>步骤：</p>
<ol>
<li><code>npm install coveralls --save-dev</code></li>
<li>将 <code>&quot;coveralls&quot;: &quot;cat test/unit/coverage/lcov.info | ./node_modules/.bin/coveralls&quot;</code> 添加到 npm scripts 中。注意：cat 的路径是随项目不同而改变的</li>
<li>在 <code>.travis.yml</code> 中添加 <code>after_success: 'npm run coveralls'</code> 配置项</li>
</ol>
<p>它可以：</p>
<ol>
<li>在测试完成后生成覆盖率文件（这一步 vue-cli 已经做了）</li>
<li>将文件内容传给 <code>coveralls</code>，这个模块可以将结果从 Travis 上传到 Coveralls 平台</li>
<li>Github 上会 by commit 地显示测试率是增加还是降低了</li>
</ol>
<h2 id="">总结 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h2>
<p>持续集成的好处无需多言，反正 Travis 就是一个免费的、能与 Github 集成的持续集成工具（实际上其它开源平台也可以，以及可以付费为私有项目提供服务）。简单、易用。</p>
<p>这些配置看似简单，却花费了我大量时间去摸索。由于只能通过不断推送 commit 的方式来触发 build 并验证配置的正确性，其过程异常繁琐，但是现在看来是十分值得的！</p>
<p>BTW：测试用的 commit 事后可以用本地 reset 与 force push 干掉。</p>
]]></description><pubDate>Wed Apr 12 2017 17:35:00 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/travis-ci-in-github</link><guid isPermaLink="true">https://blog.wxsm.space/p/travis-ci-in-github</guid></item><item><title>基于 Vue 2 与 Bootstrap 3 的组件库 uiv 发布啦</title><description><![CDATA[<p>一点微小的工作。</p>
<p>Demo: <a href="https://uiv.wxsm.space">https://uiv.wxsm.space</a></p>
<p>Github: <a href="https://github.com/wxsms/uiv">https://github.com/wxsms/uiv</a></p>
<p>NPM: <a href="https://www.npmjs.com/package/uiv">https://www.npmjs.com/package/uiv</a></p>
<p>项目使用 MIT 许可，随便用。</p>
<!--more-->
<h2 id="">简单介绍 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h2>
<p>做这个东西的初衷是，想要一些简单的、基础的、常用的基于 Vue 2 与 Bootstrap 3 的可重用组件。因为我还有一个目标：一个灵活健壮的、类似 MEAN.js 这样的 Vue + Node.js + MongoDB 的 Seed 项目。没有一个简单的组件库，项目无法进行。</p>
<p>其实现在社区有很多开源作品了，但是简单来说，就是觉得不是很满意，怎么说呢：</p>
<ul>
<li>VueStrap 这个作品虽然出现的比较早也比较全，然而貌似止步在 Vue 1 了，更新比较慢，不客气地说，里面很多组件其实是不好用的。只要稍稍对比下 Angular UI Bootstrap 就能发现差距，有些东西从设计上就有问题。</li>
<li>Bootstrap-Vue 这个作品是基于 Bootstrap 4 的，不知道为什么，就是不太喜欢。</li>
<li>Material Design 的作品有两三个，但实际使用上，感觉还是 Bootstrap 的应用场景更多，也更轻量。</li>
<li>至于 ElementUI，做得非常好非常全，然而是自立门户做的，跟 Bootstrap 与 Material 都没有关联。</li>
</ul>
<p>我想要的是：</p>
<ul>
<li>能够完全使用到 Bootstrap CSS</li>
<li>很多方面只要像 Angular UI Bootstrap 靠齐就行，毕竟经过了 Angular 1 时代的考验，事实证明它是最好用的</li>
<li>最小的体积</li>
<li>纯净的依赖，没有除了 Vue 与 Bootstrap CSS 以外的东西</li>
<li>主流浏览器支持</li>
</ul>
<p>好吧，说白了就是想自己做。跟前辈们做的东西好与不好无关。反正开源作品，人畜无害。</p>
<p>做着做着，于是就有了这个东西。感谢静纯的参与，帮我完成了一部分工作。</p>
<h2 id="-2">项目现状 <a class="header-anchor" href="#-2" aria-hidden="true">&#128279;</a></h2>
<p>目前已完成的组件有：</p>
<ul>
<li>Alert （警告）</li>
<li>Carousel （轮播）</li>
<li>Collapse （收缩与展开）</li>
<li>Date Picker （日期选择）</li>
<li>Dropdown （下拉）</li>
<li>Modal （模态框）</li>
<li>Pagination （分页）</li>
<li>Popover （弹出框）</li>
<li>Tabs （标签页）</li>
<li>Time Picker （时间选择）</li>
<li>Tooltip （提示）</li>
<li>Typeahead （自动补全）</li>
</ul>
<p>共 12 个。</p>
<p>依赖只有 Vue 2 与 Bootstrap 3，最终打包压缩 + Gzip 后体积约 9 KB，应该算是比较轻比较小的啦。</p>
<p>所有组件在主流浏览器（Chrome / Firefox / Safari）与 IE 9 / 10 / 11 下都经过了测试，暂时没有发现问题。当然，由于 IE 9 不支持 Transition 属性，因此是没有动画效果的，不过功能正常，不影响使用流程。</p>
<p>当然，除了以上的浏览器环境测试以外，还进行了完善的单元测试，组件代码测试覆盖率达到 99%（Github 与项目主页上的测试率标签显示为 97%，因为其中包括了文档源码，与实际组件无关）。可以保证在大多数情况下正常工作。</p>
<h2 id="road-map">Road Map <a class="header-anchor" href="#road-map" aria-hidden="true">&#128279;</a></h2>
<p>接下来要做的事：</p>
<ul>
<li>把自动化的 E2E 测试搞起来，目前项目使用的自动测试只有单元测试，无法自动测试不同的浏览器，这个很重要，保证项目在跨浏览器上的质量</li>
<li>收集一些意见与反馈，完善一下现有的东西</li>
<li>将 Date Picker 与 Time Picker 组合</li>
<li>Multi Select （多选组件）</li>
<li>等等等等......</li>
</ul>
<p>有问题请提 issue，一定尽快解决。同时也欢迎 PR</p>
<p>最后，欢迎使用。</p>
]]></description><pubDate>Thu Mar 30 2017 12:03:00 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/uiv-release</link><guid isPermaLink="true">https://blog.wxsm.space/p/uiv-release</guid></item><item><title>使用 Vue Transition 实现高度渐变动画</title><description><![CDATA[<p>CSS Transition 中的高度从 0 到 auto 以及从 auto 到 0 是个艰难的任务（相比于其它属性的 transition 而言），原因也很简单：就是浏览器不支持此类 CSS 动画，无论在何种情况下，它都不会成功。</p>
<p>但是高度渐变是个很常用的动画效果，如果绕过纯 CSS <code>height</code> 属性，有如下方式来实现：</p>
<ul>
<li>使用 <code>max-height</code> 属性，为元素设置一个不可能达到的最大高度，然后将 transition 转换为 <code>max-height</code> 从 0 到某个固定的值；</li>
<li>使用 <code>transform: scaleY</code> 实现；</li>
<li>使用 JavaScript 动画。</li>
</ul>
<p>上面的解决方案都从某种程度上解决了问题，但是，各有各的限制于缺点：</p>
<ul>
<li>使用 <code>max-height</code> 会造成动画效果与预期有些许出入（加速与延迟），实际体验是，它与实际 <code>height</code> 区别越大，这种感觉就会越明显，原因也很容易想到，因为 transition 的起点与终点均不在实际的起点与终点上；</li>
<li>使用 <code>scaleY</code> 有两个问题：一是动效与高度渐变不一样，元素的内容看上去是被压缩了（而不是被收起或展开），这个倒可以忍耐。可恶的是第二点，它虽然看起来是渐变了，然而高度却并没有被渐变！意思是，在它下面的元素会在动画结束后&quot;跳&quot;到另一个位置而不是平滑地渐变到这个位置；</li>
<li>使用 JavaScript 动画其实已经可以完美地实现高度渐变了，然而，问题是我们需要引入额外的 lib 来做成这件事，我可没心情纯 js 手写动画。</li>
</ul>
<p>所以，我的目标是：</p>
<ol>
<li>使用 css transition 完成动画；</li>
<li>动画效果必须完美；</li>
<li>与 vue transition 组件集成。</li>
</ol>
<p>这实际上是一个很艰难的任务。经过了大量的失败尝试，最终还是 google 救了我。。下面先直接上解决方案。</p>
<!--more-->
<p>css 部分非常简单，因为它不可以完成从 0 到 auto 的渐变，却可以完成从 0 到固定值的渐变，因此，思路是渐变仍由 css 完成，但会通过钩子给元素做些魔法操作：</p>
<pre><code class="language-css"><span class="hljs-selector-class">.collapse</span> {
  <span class="hljs-attribute">transition</span>: height .<span class="hljs-number">3s</span> ease-in-out;
  <span class="hljs-attribute">overflow</span>: hidden;
}
</code></pre>
<p>下面是重点 vue transition 部分：</p>
<pre><code class="language-js">on: {
  enter (el) {
    el.style.height = <span class="hljs-string">'auto'</span>
    <span class="hljs-comment">// noinspection JSSuspiciousNameCombination</span>
    <span class="hljs-keyword">let</span> endWidth = <span class="hljs-built_in">window</span>.getComputedStyle(el).height
    el.style.height = <span class="hljs-string">'0px'</span>
    el.offsetHeight <span class="hljs-comment">// force repaint</span>
    <span class="hljs-comment">// noinspection JSSuspiciousNameCombination</span>
    el.style.height = endWidth
  },
  afterEnter (el) {
    el.style.height = <span class="hljs-literal">null</span>
  },
  leave (el) {
    el.style.height = <span class="hljs-built_in">window</span>.getComputedStyle(el).height
    el.offsetHeight <span class="hljs-comment">// force repaint</span>
    el.style.height = <span class="hljs-string">'0px'</span>
  },
  afterLeave (el) {
    el.style.height = <span class="hljs-literal">null</span>
  }
}
</code></pre>
<p>这些钩子大概是这样的：</p>
<ul>
<li><code>enter</code> 会在元素从无到有的时候触发，即我们期望的高度从 0 到 auto 的时候；</li>
<li><code>afterEnter</code> 会在 <code>enter</code> 结束后触发；</li>
<li><code>leave</code> 会在元素从有到无，即高度从 auto 到 0 的时候触发；</li>
<li><code>afterLeave</code> 同理</li>
</ul>
<p>这些钩子内的代码真的很魔性，大概是这样的：</p>
<p><strong>enter</strong></p>
<p>这个方法被调用的时候，元素实际上已经被插入到 dom 中（ <code>v-if</code> ）或者 display 属性不为 none 了（ <code>v-show</code> ），因此，是可以获取到它的实际高度的。</p>
<ol>
<li>先将其高度设置为 <code>auto</code>，然后通过 <code>getComputedStyle</code> 方法来获取其实际高度；</li>
<li>将其高度设置为 <code>0</code>；</li>
<li>将其高度设置为第一步取得的实际高度。</li>
</ol>
<p>但是！这么做有个致命问题，我是在同一个方法内同步完成这些步骤的，因此，第二步和第三步执行的结果看起来就像跳过了第二步而只执行了第三步一样，这样就没有高度从 0 到某个值的过程，自然也就没有渐变动画了。</p>
<p><strong>重点！</strong></p>
<p><strong>这里说的魔法，实际上就是那一句看似啥都没做的 <code>el.offsetHeight</code>，它使浏览器强制进入了一个 repaint 流程。至于它为什么能实现这个功能，真的不太清楚，google 一波也只是知其然不知其所以然，我们甚至不用给它赋值，只要引用一次就行了。可以看做一个非常神奇的技巧。实测在 IE 10 以上 / Chrome / Firefox / Safari 上均能工作。</strong></p>
<p>因此，enter 的流程变为：</p>
<ol>
<li>先将其高度设置为 <code>auto</code>，然后通过 <code>getComputedStyle</code> 方法来获取其实际高度；</li>
<li>将其高度设置为 <code>0</code>；</li>
<li>强制浏览器重绘；</li>
<li>将其高度设置为第一步取得的实际高度。</li>
</ol>
<p>这样动画就成功执行了！</p>
<p>理解了 <code>enter</code> 过程，剩下的 <code>afterEnter</code> / <code>leave</code> / <code>afterLeave</code> 钩子，里面的内容就很容易理解了。</p>
<p>效果演示：<a href="https://uiv.wxsm.space/collapse">https://uiv.wxsm.space/collapse</a></p>
<p>回过头来看一下实现原理其实很简单粗暴，因此，除了在 vue 上面可以这么玩，其实其他支持 css transition 的框架肯定也是可以的（如 angular 中有 ngAnimate 可以实现），最终达到的动画效果十分完美，并且没有借助主框架以外的任何额外 js 库。</p>
]]></description><pubDate>Thu Mar 16 2017 16:17:00 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/vue-transition-height</link><guid isPermaLink="true">https://blog.wxsm.space/p/vue-transition-height</guid></item><item><title>Change SOCKS Proxy to HTTP</title><description><![CDATA[<h2 id="osx">OSX <a class="header-anchor" href="#osx" aria-hidden="true">&#128279;</a></h2>
<p>Use <code>brew</code> to install <code>polipo</code> via socks proxy:</p>
<pre><code class="language-bash">$ ALL_PROXY=socks5://127.0.0.1:9500 brew install polipo
</code></pre>
<p>Create <code>polipo.config</code> file under <code>Document</code>:</p>
<pre><code>socksParentProxy = &quot;127.0.0.1:9500&quot;
socksProxyType = socks5
proxyAddress = &quot;::0&quot;
proxyPort = 8123
</code></pre>
<p>Start polipo server:</p>
<pre><code class="language-bash">$ polipo -c ~/Documents/polipo.config
Established listening socket on port 8123.
</code></pre>
<p>Verify it at <code>http://localhost:8123</code>.</p>
<h2 id="windows">Windows <a class="header-anchor" href="#windows" aria-hidden="true">&#128279;</a></h2>
<p>Use <a href="http://www.privoxy.org/">privoxy</a> tool. Download: <a href="http://www.privoxy.org/sf-download-mirror/Win32/">http://www.privoxy.org/sf-download-mirror/Win32/</a></p>
<p>Install it, find the config file at <code>\Privoxy\config.txt</code>, append following to the bottom of it:</p>
<pre><code>forward-socks5 / 127.0.0.1:9500 .
</code></pre>
<p>(Mind the dot at the end)</p>
<p>The default port is <code>8118</code>, search from the config file to replace it.</p>
]]></description><pubDate>Fri Mar 10 2017 12:00:00 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/change-socks-proxy-to-http</link><guid isPermaLink="true">https://blog.wxsm.space/p/change-socks-proxy-to-http</guid></item><item><title>Egret Note</title><description><![CDATA[<p>Egret Engine 的学习笔记。</p>
<p>Egret Engine 是一款基于 JavaScript 的游戏制作引擎，支持 2D 与 3D 模式，支持 Canvas 与 WebGL 渲染，目前使用 TypeScript 编写。</p>
<!--more-->
<h2 id="">显示对象 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h2>
<p>“显示对象”，准确的含义是可以在舞台上显示的对象。可以显示的对象，既包括可以直接看见的图形、文字、视频、图片等，也包括不能看见但真实存在的显示对象容器。</p>
<p>在Egret中，视觉图形都是由显示对象和显示对象容器组成的。</p>
<h3 id="-2">对象树 <a class="header-anchor" href="#-2" aria-hidden="true">&#128279;</a></h3>
<ul>
<li>根：舞台 <code>DisplayObjectContainer:Stage</code></li>
<li>茎：主容器（文档类） <code>DisplayObjectContainer</code></li>
<li>树枝：容器 <code>DisplayObjectContainer</code></li>
<li>树叶：显示对象 <code>DisplayObject</code></li>
</ul>
<h3 id="-3">对象类型 <a class="header-anchor" href="#-3" aria-hidden="true">&#128279;</a></h3>
<ul>
<li><code>DisplayObject</code>	显示对象基类，所有显示对象均继承自此类</li>
<li><code>Bitmap</code>	位图，用来显示图片</li>
<li><code>Shape</code>	用来显示矢量图，可以使用其中的方法绘制矢量图形</li>
<li><code>TextField</code>	文本类</li>
<li><code>BitmapText</code>	位图文本类</li>
<li><code>DisplayObjectContainer</code>	显示对象容器接口，所有显示对象容器均实现此接口</li>
<li><code>Sprite</code>	带有矢量绘制功能的显示容器</li>
<li><code>Stage</code>	舞台类</li>
</ul>
<h3 id="-4">基本概念 <a class="header-anchor" href="#-4" aria-hidden="true">&#128279;</a></h3>
<p>二维坐标系。原点位于<strong>左上角</strong>。</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> shape:egret.Shape = <span class="hljs-keyword">new</span> egret.Shape();
shape.x = <span class="hljs-number">100</span>;
shape.y = <span class="hljs-number">20</span>;
</code></pre>
<p>支持的操作：</p>
<ul>
<li>alpha：透明度</li>
<li>width：宽度</li>
<li>height：高度</li>
<li>rotation：旋转角度</li>
<li>scaleX：横向缩放</li>
<li>scaleY：纵向缩放</li>
<li>skewX：横向斜切</li>
<li>skewY：纵向斜切</li>
<li>visible：是否可见</li>
<li>x：X 轴坐标值</li>
<li>y：Y 轴坐标值</li>
<li>anchorOffsetX：对象绝对锚点 X</li>
<li>anchorOffsetY：对象绝对锚点 Y</li>
</ul>
<h4 id="-5">锚点 <a class="header-anchor" href="#-5" aria-hidden="true">&#128279;</a></h4>
<p>Display Object 显示在舞台上的的位置需要通过 Anchor 来计算（初始值位于 Display Object 的左上角），可以通过 <code>anchorOffsetX</code> 和 <code>anchorOffsetY</code> 方法来改变对象的锚点（比如移至中点）。</p>
<h4 id="-6">定位 <a class="header-anchor" href="#-6" aria-hidden="true">&#128279;</a></h4>
<p>Display Object 的初始坐标为 <strong>(0, 0)</strong>，即位于<strong>容器的左上角</strong>（而非舞台）。</p>
<ul>
<li>相对于容器的位置可以类比作 <code>position: relative</code></li>
<li>相对于舞台的位置可以类比作 <code>position: absolute</code></li>
</ul>
<p>如果要获取绝对位置，需要调用 <code>container.globalToLocal(x, y)</code> 方法，参数代表舞台坐标，返回值为容器坐标。</p>
<p>至于 <code>z-index</code> 则跟 svg 的处理类似。</p>
<h4 id="-7">尺寸 <a class="header-anchor" href="#-7" aria-hidden="true">&#128279;</a></h4>
<p>两种方法更改尺寸：</p>
<ul>
<li>height / width</li>
<li>scaleX / scaleY</li>
</ul>
<h4 id="-8">斜切 <a class="header-anchor" href="#-8" aria-hidden="true">&#128279;</a></h4>
<p>斜切可以造成类似矩形变形为平行四边形的效果。</p>
<ul>
<li>skewX：横向斜切</li>
<li>skewY：纵向斜切</li>
</ul>
<h2 id="-9">对象容器 <a class="header-anchor" href="#-9" aria-hidden="true">&#128279;</a></h2>
<p><code>DisplayObjectContainer</code> 是 <code>DisplayObject</code> 的子类。</p>
<p>向 Container 中添加 DisplayObject：</p>
<pre><code class="language-js">container.addChild(displayObject);
</code></pre>
<blockquote>
<p>同一个显示对象无论被代码加入显示列表多少次，在屏幕上只绘制一次。如果一个显示对象 A 被添加到了 B 这个容器中，然后 A 又被添加到了 C 容器中。那么在第二次执行 C.addChild(A) 的时候，A 自动的从 B 容器中被删除，然后添加到 C 容器中。</p>
</blockquote>
<p>移除：</p>
<pre><code class="language-js">container.removeChild(displayObject);
</code></pre>
<h3 id="-10">深度管理 <a class="header-anchor" href="#-10" aria-hidden="true">&#128279;</a></h3>
<p>DisplayObject 的 <code>z-index</code> 由其插入到容器中的顺序决定。后插入的显示在上层。</p>
<p>插入到指定位置使用 <code>container.addChildAt(object, index)</code> 方法。</p>
<p>同时也有 <code>container.removeChileAt(index)</code> 方法。</p>
<p>删除全部对象使用 <code>container.removeChildren()</code> 方法。</p>
<p>交换 DisplayObject 的位置有两个方法：</p>
<ul>
<li><code>container.swapChildren(object, object)</code></li>
<li><code>container.swapChildrenAt(index, index)</code></li>
</ul>
<p>手动设置 z-index 使用 <code>container.setChildIndex( object, index )</code> 方法。</p>
<h3 id="-11">子对象选择 <a class="header-anchor" href="#-11" aria-hidden="true">&#128279;</a></h3>
<p>通过 z-index 获取：<code>container.getChildAt(index)</code></p>
<p>通过 name 获取（需要预先给 DisplayObject 设置 name 属性）：<code>container.getChildByName(name)</code></p>
<blockquote>
<p>通过 z-index 获取子对象性能更佳。</p>
</blockquote>
<h2 id="-12">矢量绘图 <a class="header-anchor" href="#-12" aria-hidden="true">&#128279;</a></h2>
<blockquote>
<p>Egret中可以直接使用程序来绘制一些简单的图形，这些图形在运行时都会进行实时绘图。要进行绘图操作，我们需要使用 Graphics 这个类。但并非直接使用。 一些显示对象中已经包含了绘图方法，我们可以直接调用这些方法来进行绘图。 Graphics 中提供多种绘图方法。</p>
</blockquote>
<p>已有的绘图方法包括：矩形、圆形、直线、曲线、圆弧。</p>
<p>以下的 <code>shp</code> 代表 shape，即一个 Shape 对象的实例。</p>
<p><code>shp.graphics.clear()</code> 是通用的清楚绘图方法。</p>
<h3 id="-13">基本图形 <a class="header-anchor" href="#-13" aria-hidden="true">&#128279;</a></h3>
<h4 id="-14">矩形 <a class="header-anchor" href="#-14" aria-hidden="true">&#128279;</a></h4>
<pre><code class="language-js"><span class="hljs-keyword">var</span> shp:egret.Shape = <span class="hljs-keyword">new</span> egret.Shape();
shp.graphics.beginFill( <span class="hljs-number">0xff0000</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">//color and alpha</span>
shp.graphics.drawRect( <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">200</span> ); <span class="hljs-comment">// x y width height</span>
shp.graphics.lineStyle( <span class="hljs-number">10</span>, <span class="hljs-number">0x00ff00</span> ); <span class="hljs-comment">// border-width and border-color</span>
shp.graphics.endFill();
<span class="hljs-keyword">this</span>.addChild( shp );
</code></pre>
<h4 id="-15">圆形 <a class="header-anchor" href="#-15" aria-hidden="true">&#128279;</a></h4>
<pre><code class="language-js">shp.graphics.lineStyle( <span class="hljs-number">10</span>, <span class="hljs-number">0x00ff00</span> );
shp.graphics.beginFill( <span class="hljs-number">0xff0000</span>, <span class="hljs-number">1</span>);
shp.graphics.drawCircle( <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">50</span> ); <span class="hljs-comment">// x y r</span>
</code></pre>
<blockquote>
<p>此处需要注意的是，圆形的X轴和Y轴位置是相对于Shape对象的锚点计算的。</p>
</blockquote>
<h4 id="-16">直线 <a class="header-anchor" href="#-16" aria-hidden="true">&#128279;</a></h4>
<pre><code class="language-js">shp.graphics.lineStyle( <span class="hljs-number">2</span>, <span class="hljs-number">0x00ff00</span> );
shp.graphics.moveTo( <span class="hljs-number">10</span>,<span class="hljs-number">10</span> ); <span class="hljs-comment">// 起点</span>
shp.graphics.lineTo( <span class="hljs-number">100</span>, <span class="hljs-number">20</span> ); <span class="hljs-comment">// 终点（可以多次执行 lineTo）</span>
</code></pre>
<h4 id="-17">曲线 <a class="header-anchor" href="#-17" aria-hidden="true">&#128279;</a></h4>
<pre><code class="language-js">shp.graphics.lineStyle( <span class="hljs-number">2</span>, <span class="hljs-number">0x00ff00</span> );
shp.graphics.moveTo( <span class="hljs-number">50</span>, <span class="hljs-number">50</span>);
shp.graphics.curveTo( <span class="hljs-number">100</span>,<span class="hljs-number">100</span>, <span class="hljs-number">200</span>,<span class="hljs-number">50</span>); <span class="hljs-comment">// 控制点 x y ，终点 x y</span>
</code></pre>
<h4 id="-18">圆弧 <a class="header-anchor" href="#-18" aria-hidden="true">&#128279;</a></h4>
<pre><code class="language-js">drawArc( x:number, <span class="hljs-attr">y</span>:number, <span class="hljs-attr">radius</span>:number, <span class="hljs-attr">startAngle</span>:number, <span class="hljs-attr">endAngle</span>:number, <span class="hljs-attr">anticlockwise</span>:boolean ):<span class="hljs-keyword">void</span>
</code></pre>
<p>前面的参数跟前面绘制圆形的一样，圆弧路径的圆心在 (x, y) 位置，半径为 radius 。后面的参数表示根据 anticlockwise ： 如果为 true，逆时针绘制圆弧，反之，顺时针绘制。</p>
<blockquote>
<p>需要注意是传入的 startAngle 和 endAngle 均为弧度而不是角度。</p>
</blockquote>
<h2 id="-19">遮罩 <a class="header-anchor" href="#-19" aria-hidden="true">&#128279;</a></h2>
<p>DisplayObject 有一个 <code>mask</code> 属性，简单来说，就是类似蒙版上面的一个洞。但这个 <code>mask</code> 是洞而不是蒙版。如果添加了 <code>mask</code> 属性，则 Object 只能显示这个“洞中”的内容。</p>
<p>用作遮罩的显示对象可设置动画、动态调整大小。遮罩显示对象不一定需要添加到显示列表中。<strong>但是，如果希望在缩放舞台时也缩放遮罩对象，或者如果希望支持用户与遮罩对象的交互（如调整大小），则必须将遮罩对象添加到显示列表中</strong>。</p>
<blockquote>
<p>不能使用一个遮罩对象来遮罩另一个遮罩对象。</p>
</blockquote>
<p>通过将 mask 属性设置为 null 可以删除遮罩。</p>
<pre><code class="language-js">mySprite.mask = <span class="hljs-literal">null</span>;
</code></pre>
<h2 id="-20">碰撞检测 <a class="header-anchor" href="#-20" aria-hidden="true">&#128279;</a></h2>
<ul>
<li>非精确：<code>var isHit:boolean = shp.hitTestPoint( 10, 10 );</code></li>
<li>精确：<code>shp.hitTestPoint( 10, 10，ture);</code></li>
</ul>
<p>非精确大概可以看做面积相交，精确则是边缘相交。</p>
<blockquote>
<p>大量使用精确碰撞检测，会消耗更多的性能。</p>
</blockquote>
<h2 id="-21">文本 <a class="header-anchor" href="#-21" aria-hidden="true">&#128279;</a></h2>
<p>Egret 提供三种不同的文本类型，不同类型具有以下特点：</p>
<ul>
<li>普通文本：用于显示标准文本内容的文本类型</li>
<li>输入文本：允许用户输入的文本类型</li>
<li>位图文本：借助位图字体渲染的文本类型</li>
</ul>
<h3 id="-22">样式 <a class="header-anchor" href="#-22" aria-hidden="true">&#128279;</a></h3>
<pre><code class="language-js"><span class="hljs-keyword">var</span> label:egret.TextField = <span class="hljs-keyword">new</span> egret.TextField(); 
label.text = <span class="hljs-string">"这是一个文本"</span>;
label.size = <span class="hljs-number">20</span>; <span class="hljs-comment">// 全局默认值 egret.TextField.default_size，下同</span>
label.width = <span class="hljs-number">70</span>;
label.height = <span class="hljs-number">70</span>;
label.textAlign = egret.HorizontalAlign.RIGHT; <span class="hljs-comment">// CENTER LEFT</span>
label.verticalAlign = egret.VerticalAlign.BOTTOM; <span class="hljs-comment">// MIDDLE TOP</span>
label.fontFamily = <span class="hljs-string">"KaiTi"</span>; <span class="hljs-comment">// default_fontFamily</span>
label.textColor = <span class="hljs-number">0xff0000</span>; <span class="hljs-comment">// default_textColor</span>

<span class="hljs-comment">//设置粗体与斜体</span>
label.bold = <span class="hljs-literal">true</span>;
label.italic = <span class="hljs-literal">true</span>;

<span class="hljs-comment">//设置描边属性</span>
label.strokeColor = <span class="hljs-number">0x0000ff</span>;
label.stroke = <span class="hljs-number">2</span>;
<span class="hljs-keyword">this</span>.addChild( label );
</code></pre>
<p>支持格式混排：</p>
<pre><code class="language-js"><span class="hljs-comment">// JSON 模式</span>
label.textFlow = &lt;Array&lt;egret.ITextElement&gt;&gt;[
    {text: "妈妈再也不用担心我在", style: {"size": 12}}
    , {text: "Egret", style: {"textColor": 0x336699, "size": 60, "strokeColor": 0x6699cc, "stroke": 2}}
    , {text: "里说一句话不能包含各种", style: {"fontFamily": "楷体"}}
    , {text: "五", style: {"textColor": 0xff0000}}
    , {text: "彩", style: {"textColor": 0x00ff00}}
    , {text: "缤", style: {"textColor": 0xf000f0}}
    , {text: "纷", style: {"textColor": 0x00ffff}}
    , {text: "、\n"}
    , {text: "大", style: {"size": 36}}
    , {text: "小", style: {"size": 6}}
    , {text: "不", style: {"size": 16}}
    , {text: "一", style: {"size": 24}}
    , {text: "、"}
    , {text: "格", style: {"italic": true, "textColor": 0x00ff00}}
    , {text: "式", style: {"size": 16, "textColor": 0xf000f0}}
    , {text: "各", style: {"italic": true, "textColor": 0xf06f00}}
    , {text: "样", style: {"fontFamily": "楷体"}}
    , {text: ""}
    , {text: "的文字了！"}
];

// HTML 模式 （标签与属性部分支持）
label.textFlow = (new egret.HtmlTextParser).parser(
    '没有任何格式初始文本，' +
    '&lt;font color="#0000ff" size="30" fontFamily="Verdana"&gt;Verdana blue large&lt;/font&gt;' +
    '&lt;font color="#ff7f50" size="10"&gt;珊瑚色&lt;b&gt;局部加粗&lt;/b&gt;小字体&lt;/font&gt;' +
    '&lt;i&gt;斜体&lt;/i&gt;'
);
</code></pre>
<h3 id="-23">事件与链接 <a class="header-anchor" href="#-23" aria-hidden="true">&#128279;</a></h3>
<pre><code class="language-js">tx.textFlow = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>&lt;egret.ITextElement&gt;(
    { <span class="hljs-attr">text</span>:<span class="hljs-string">"这段文字有链接"</span>, <span class="hljs-attr">style</span>: { <span class="hljs-string">"href"</span> : <span class="hljs-string">"event:text event triggered"</span> } }
    ,{ <span class="hljs-attr">text</span>:<span class="hljs-string">"\n这段文字没链接"</span>, <span class="hljs-attr">style</span>: {} }
);
tx.touchEnabled = <span class="hljs-literal">true</span>;
tx.addEventListener( egret.TextEvent.LINK, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> evt:egret.TextEvent </span>)</span>{
    <span class="hljs-built_in">console</span>.log( evt.text );
}, <span class="hljs-keyword">this</span> );
</code></pre>
<p>也可以直接将 <code>href</code> 设置为 url，这样不需要事件监听，将直接打开链接。但<strong>只适用 Web 端</strong>。</p>
<h3 id="-24">文本输入 <a class="header-anchor" href="#-24" aria-hidden="true">&#128279;</a></h3>
<p>关键代码是设置其类型为 INPUT。</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> txInput:egret.TextField = <span class="hljs-keyword">new</span> egret.TextField;
txInput.type = egret.TextFieldType.INPUT;
</code></pre>
<p>绘制输入背景可以用其它 DisplayObject，目前没有内置实现。</p>
<p>获取焦点使用 <code>textIput.setFocus();</code> 方法。</p>
<p>除此以外，还有 <code>inputType</code> 属性表示输入内容的区别，这个主要用于移动端弹出相应的键盘。</p>
<h2 id="-25">事件处理 <a class="header-anchor" href="#-25" aria-hidden="true">&#128279;</a></h2>
<p>事件类：<code>egret.Event</code></p>
<h3 id="-26">执行流程 <a class="header-anchor" href="#-26" aria-hidden="true">&#128279;</a></h3>
<blockquote>
<p>事件机制包含4个步骤：注册侦听器，发送事件，侦听事件，移除侦听器。这四个步骤是按照顺序来执行的。</p>
</blockquote>
<h3 id="-27">事件类 <a class="header-anchor" href="#-27" aria-hidden="true">&#128279;</a></h3>
<p>其构建器可以传 3 个参数：事件类型、是否冒泡、是否可取消（什么是取消？）。</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DateEvent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">egret</span>.<span class="hljs-title">Event</span>
</span>{
    public <span class="hljs-keyword">static</span> DATE:string = <span class="hljs-string">"约会"</span>;
    public _year:number = <span class="hljs-number">0</span>;
    public _month:number = <span class="hljs-number">0</span>;
    public _date:number = <span class="hljs-number">0</span>;
    public _where:string = <span class="hljs-string">""</span>;
    public _todo:string = <span class="hljs-string">""</span>;
    public <span class="hljs-keyword">constructor</span>(type:string, bubbles:boolean=false, cancelable:boolean=false)
    {
        <span class="hljs-keyword">super</span>(type,bubbles,cancelable);
    }
}
</code></pre>
<h3 id="-28">监听器 <a class="header-anchor" href="#-28" aria-hidden="true">&#128279;</a></h3>
<p>跟常见的情况不太一样，Egret 的事件<strong>绑定在发送者上</strong>（而不是接收者）。</p>
<h4 id="-29">监听器函数 <a class="header-anchor" href="#-29" aria-hidden="true">&#128279;</a></h4>
<blockquote>
<p>一个侦听器必须是函数，它可以是一个独立函数，也可以是一个实例的方法。侦听器必须有一个参数，并且这个参数必须是 Event 类实例或其子类的实例， 同时，侦听器的返回值必须为空（void）。</p>
</blockquote>
<h4 id="-30">注册与移除事件监听 <a class="header-anchor" href="#-30" aria-hidden="true">&#128279;</a></h4>
<p>注册侦听器</p>
<pre><code class="language-js">eventDispatcher.addEventListener(eventType, listenerFunction, <span class="hljs-keyword">this</span>);
</code></pre>
<p>移除侦听器</p>
<pre><code class="language-js">eventDispatcher.removeEventListener(eventType, listenerFunction, <span class="hljs-keyword">this</span>);
</code></pre>
<p>检测侦听器</p>
<pre><code class="language-js">eventDispatcher.hasEventListener(eventType);
</code></pre>
<h4 id="-31">优先级 <a class="header-anchor" href="#-31" aria-hidden="true">&#128279;</a></h4>
<pre><code class="language-js">public addEventListener(type:string, <span class="hljs-attr">listener</span>:<span class="hljs-built_in">Function</span>, <span class="hljs-attr">thisObject</span>:any, <span class="hljs-attr">useCapture</span>:boolean = <span class="hljs-literal">false</span>, <span class="hljs-attr">priority</span>:number = <span class="hljs-number">0</span>)
</code></pre>
<blockquote>
<p>该属性为一个number类型，当数字越大，则优先级越大。在触发事件的时候优先级越高。</p>
</blockquote>
]]></description><pubDate>Wed Feb 22 2017 16:17:00 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/egret-note</link><guid isPermaLink="true">https://blog.wxsm.space/p/egret-note</guid></item><item><title>MEAN.JS 在 0.5 版本下发现的 NG-REPEAT 闪动问题</title><description><![CDATA[<p>如题，经过长期痛苦的观察以及 debug 过程，以下原因被一一排除：</p>
<ul>
<li>浏览器差异问题</li>
<li>数据更新问题</li>
<li><code>ng-repeat</code> 没有添加 <code>track by key</code> 导致的性能问题</li>
<li>Angular 版本问题</li>
<li>MEAN.js 架构问题</li>
</ul>
<p><strong>实际原因却是因为 MEAN.js 在全局引入了 <code>ngAnimate</code> 依赖。</strong>（也算是一个架构问题？）</p>
<p>因此解决办法：</p>
<ul>
<li>要么将全局依赖去掉，改为各自添加依赖</li>
<li>要么使用 <code>transition: none !important</code></li>
</ul>
]]></description><pubDate>Mon Feb 20 2017 10:14:00 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/meanjs-5-x-ng-repeat-flashing</link><guid isPermaLink="true">https://blog.wxsm.space/p/meanjs-5-x-ng-repeat-flashing</guid></item><item><title>React Note - Basic</title><description><![CDATA[<p>React 学习笔记（基础篇）。</p>
<!--more-->
<h2 id="">安装 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h2>
<pre><code class="language-bash">npm install -g create-react-app
create-react-app hello-world
<span class="hljs-built_in">cd</span> hello-world
npm start
</code></pre>
<p>实践：create 这一步会同时执行 <code>npm install</code> 因此有失败的可能，多尝试几次就成功了。</p>
<p>这个程序跟 vue-loader 很像，会造出一个简单的手脚架，包含了 Babel 编译器以及打包工具等等。但是细看它的 <code>package.json</code> 文件并没有包含上述内容：</p>
<pre><code class="language-json">"devDependencies": {
  "react-scripts": "0.8.5"
},
"dependencies": {
  "react": "^15.4.2",
  "react-dom": "^15.4.2"
}
</code></pre>
<p>因此，跟 vue-loader 不一样的是，react 这个手脚架把无关内容都封装了。这么做我觉得有利有弊：它让人用起来更方便，然而不可能达到直接使用原组件的自由度了。相比之下，这里我更喜欢 vue-loader 的处理方式。</p>
<h2 id="hello-world">Hello World <a class="header-anchor" href="#hello-world" aria-hidden="true">&#128279;</a></h2>
<p>最简示例：</p>
<pre><code class="language-js">ReactDOM.render(
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, world!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>,
  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>)
);
</code></pre>
<h2 id="jsx">JSX 语法 <a class="header-anchor" href="#jsx" aria-hidden="true">&#128279;</a></h2>
<p>JSX 是 JavaScript 的一种语法扩展，实际上可以看做是语法糖。通过编译器，以下语法：</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> element = (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"greeting"</span>&gt;</span>
    Hello, world!
  <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>
);
</code></pre>
<p>相当于：</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> element = {
  <span class="hljs-attr">type</span>: <span class="hljs-string">'h1'</span>,
  <span class="hljs-attr">props</span>: {
    <span class="hljs-attr">className</span>: <span class="hljs-string">'greeting'</span>,
    <span class="hljs-attr">children</span>: <span class="hljs-string">'Hello, world'</span>
  }
};
</code></pre>
<p>后者就是编译后的结果，JSX 语法块变成了一个对象（称之为 <code>React element</code>）。</p>
<p>（JB 家的 IDE 已经对 JSX 语法提供了默认支持，不然这篇笔记就到此为止了）</p>
<p>JSX 支持一些稍微高级的用法，如：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formatName</span>(<span class="hljs-params">user</span>) </span>{
  <span class="hljs-keyword">return</span> user.firstName + <span class="hljs-string">' '</span> + user.lastName;
}

<span class="hljs-keyword">const</span> user = {
  <span class="hljs-attr">firstName</span>: <span class="hljs-string">'Harper'</span>,
  <span class="hljs-attr">lastName</span>: <span class="hljs-string">'Perez'</span>
};

<span class="hljs-keyword">const</span> element = (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>
    Hello, {formatName(user)}!
  <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>
);

ReactDOM.render(
  element,
  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>)
);
</code></pre>
<p>在任何地方使用 JSX：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getGreeting</span>(<span class="hljs-params">user</span>) </span>{
  <span class="hljs-keyword">if</span> (user) {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, {formatName(user)}!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;
  }
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, Stranger.<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;
}
</code></pre>
<h2 id="-2">元素 <a class="header-anchor" href="#-2" aria-hidden="true">&#128279;</a></h2>
<p>上面有说到 <code>React element</code>（元素），<strong>元素</strong>的概念与<strong>组件</strong>不同：元素是组件的组成部分。</p>
<h3 id="-3">元素渲染 <a class="header-anchor" href="#-3" aria-hidden="true">&#128279;</a></h3>
<pre><code class="language-js"><span class="hljs-keyword">const</span> element = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, world<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;
ReactDOM.render(
  element,
  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>)
);
</code></pre>
<p>显然，它掌控了 DOM 中一个 ID 为 root 的节点，并往里面插入了元素。</p>
<h3 id="-4">元素更新 <a class="header-anchor" href="#-4" aria-hidden="true">&#128279;</a></h3>
<p><strong>已创建的元素是无法更新属性的</strong>。因此，如果要改变它，只能够重新创建并渲染一次。</p>
<p>然而，托虚拟 DOM 的福，重新渲染并不代表重新渲染整个 DOM，React 会查找并只更新有改变的节点。</p>
<p>但是一般不回这么做。因为有一点很重要：在设计一个元素的时候就要考虑到它在所有状态下的表现。这个其实在其它框架下也是一样的。</p>
<h2 id="-5">组件 <a class="header-anchor" href="#-5" aria-hidden="true">&#128279;</a></h2>
<p>React 是组件化框架，因此组件是组成一个应用的基础。组件的特点：独立、可重用。</p>
<p>组件有两种定义方法：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Welcome</span>(<span class="hljs-params">props</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, {props.name}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;
}
</code></pre>
<p>或者：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Welcome</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  render() {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, {this.props.name}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;
  }
}
</code></pre>
<h3 id="-6">组件渲染 <a class="header-anchor" href="#-6" aria-hidden="true">&#128279;</a></h3>
<p>一个简单的例子：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Welcome</span>(<span class="hljs-params">props</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, {props.name}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;
}

<span class="hljs-keyword">const</span> element = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Welcome</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"Sara"</span> /&gt;</span>;

ReactDOM.render(
  element,
  document.getElementById('root')
);
</span></code></pre>
<p>可以看到元素组成了组件，组件又组成了元素，最后渲染在 DOM 上的是元素。</p>
<p>这个跟 Vue 很像了，区别是 Vue 没有区分所谓的“元素”跟“组件”，通通都是组件。</p>
<p>需要注意的是，在 React 世界中有个约定：自定义控件以大写字母打头。这是为了跟 HTML 元素有所区分。</p>
<h3 id="-7">组件使用与拆解 <a class="header-anchor" href="#-7" aria-hidden="true">&#128279;</a></h3>
<p>一个简单的例子：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Welcome</span>(<span class="hljs-params">props</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, {props.name}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> (
    &lt;div&gt;
      &lt;Welcome name="Sara" /&gt;
      &lt;Welcome name="Cahal" /&gt;
      &lt;Welcome name="Edite" /&gt;
    &lt;/div&gt;
  );
}

ReactDOM.render(
  &lt;App /&gt;,
  document.getElementById('root')
);
</code></pre>
<p>需要注意的是，组件只能有一个根节点。（如例子中的 3 个 <code>Welcome</code> 必须包裹在 <code>div</code> 中）</p>
<h3 id="-8">参数只读 <a class="header-anchor" href="#-8" aria-hidden="true">&#128279;</a></h3>
<p>简单地说，React 不允许在控件内修改参数（包括值的修改以及对象修改）。允许修改的称之为“状态”（约等于 Vue 中的 component data）</p>
<h2 id="-9">状态管理与生命周期 <a class="header-anchor" href="#-9" aria-hidden="true">&#128279;</a></h2>
<h3 id="-10">添加状态管理 <a class="header-anchor" href="#-10" aria-hidden="true">&#128279;</a></h3>
<p>组件的更新依赖于状态，因此需要实时更新的组件应在其内部建立状态管理机制（低耦合高内聚）。</p>
<p>需要状态管理机的组件，必须使用 ES6 方式声明，如：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Clock</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  <span class="hljs-keyword">constructor</span>(props) {
    <span class="hljs-keyword">super</span>(props);
    <span class="hljs-keyword">this</span>.state = {<span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()};
  }

  render() {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, world!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>It is {this.state.date.toLocaleTimeString()}.<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    );
  }
}

ReactDOM.render(
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Clock</span> /&gt;</span>,
  document.getElementById('root')
);
</span></code></pre>
<p>但是，此时，组件是无法更新的：因为状态在创建时就已经被决定了。</p>
<h3 id="-11">添加生命周期 <a class="header-anchor" href="#-11" aria-hidden="true">&#128279;</a></h3>
<p>代码有注释：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Clock</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  <span class="hljs-keyword">constructor</span>(props) {
    <span class="hljs-keyword">super</span>(props);
    <span class="hljs-keyword">this</span>.state = {<span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()};
  }

  <span class="hljs-comment">// 组件渲染到 DOM 后调用</span>
  componentDidMount() {
    <span class="hljs-keyword">this</span>.timerID = setInterval(
      <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.tick(),
      <span class="hljs-number">1000</span>
    );
  }

  <span class="hljs-comment">// 组件将销毁后调用</span>
  componentWillUnmount() {
    clearInterval(<span class="hljs-keyword">this</span>.timerID);
  }
  
  tick() {
    <span class="hljs-keyword">this</span>.setState({
      <span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()
    });
  }

  render() {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, world!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>It is {this.state.date.toLocaleTimeString()}.<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    );
  }
}

ReactDOM.render(
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Clock</span> /&gt;</span>,
  document.getElementById('root')
);
</span></code></pre>
<p>整个流程很简单清晰了：</p>
<ol>
<li>ReactDOM 渲染 <code>Clock</code>，并对 state 做第一次初始化</li>
<li><code>render</code> 方法被调用，插入 DOM</li>
<li><code>componentDidMount</code> 方法被调用，计时器启动，<code>tick</code> 每秒钟执行一次</li>
<li>每次 <code>tick</code> 执行都调用 <code>setState</code> 方法去更新状态，这样 React 就知道需要更新 DOM 了</li>
<li>当组件被从 DOM 移除后，<code>componentWillUnmount</code> 执行</li>
</ol>
<h3 id="-12">正确使用状态 <a class="header-anchor" href="#-12" aria-hidden="true">&#128279;</a></h3>
<p>直接更改 state 属性是不会触发 UI 更新的。因此，有一些规则需要遵守。</p>
<h4 id="-13">不直接修改状态 <a class="header-anchor" href="#-13" aria-hidden="true">&#128279;</a></h4>
<p>在组件内进行修改状态操作，使用 <code>setState</code> 方法：</p>
<pre><code class="language-js"><span class="hljs-comment">// Wrong</span>
<span class="hljs-keyword">this</span>.state.comment = <span class="hljs-string">'Hello'</span>;

<span class="hljs-comment">// Correct</span>
<span class="hljs-keyword">this</span>.setState({<span class="hljs-attr">comment</span>: <span class="hljs-string">'Hello'</span>});
</code></pre>
<h4 id="-14">关于异步更新 <a class="header-anchor" href="#-14" aria-hidden="true">&#128279;</a></h4>
<pre><code class="language-js"><span class="hljs-comment">// Wrong</span>
<span class="hljs-keyword">this</span>.setState({
  <span class="hljs-attr">counter</span>: <span class="hljs-keyword">this</span>.state.counter + <span class="hljs-keyword">this</span>.props.increment,
});

<span class="hljs-comment">// Correct</span>
<span class="hljs-keyword">this</span>.setState(<span class="hljs-function">(<span class="hljs-params">prevState, props</span>) =&gt;</span> ({
  <span class="hljs-attr">counter</span>: prevState.counter + props.increment
}));
</code></pre>
<h4 id="-15">状态合并 <a class="header-anchor" href="#-15" aria-hidden="true">&#128279;</a></h4>
<p>在进行 <code>setState</code> 的时候，只关心需要更改的属性即可，没有传入的属性会被保留。就好像新的状态被“合并”进入旧状态一样。</p>
<h3 id="-16">数据流 <a class="header-anchor" href="#-16" aria-hidden="true">&#128279;</a></h3>
<p>在 React 世界，组件与组件之间的状态传递是单向的，传值的方式就是将 state 当做 prop 传给子组件。</p>
<h2 id="-17">事件处理 <a class="header-anchor" href="#-17" aria-hidden="true">&#128279;</a></h2>
<p>跟 DOM 操作很像，区别：</p>
<ol>
<li>事件命名使用驼峰式</li>
<li>直接向 JSX 中传入方法</li>
<li>不支持 <code>return false</code> 操作</li>
</ol>
<p>例：</p>
<pre><code class="language-js">// DOM
&lt;button onclick="activateLasers()"&gt;
  Activate Lasers
&lt;/button&gt;

// React
&lt;button onClick={activateLasers}&gt;
  Activate Lasers
&lt;/button&gt;

// A prevent default sample
function ActionLink() {
  function handleClick(e) {
    e.preventDefault();
    console.log('The link was clicked.');
  }

  return (
    &lt;a href="#" onClick={handleClick}&gt;
      Click me
    &lt;/a&gt;
  );
}

// A class sample
class Toggle extends React.Component {
  constructor(props) {
    super(props);
    this.state = {isToggleOn: true};

    // This binding is necessary to make `this` work in the callback
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    this.setState(prevState =&gt; ({
      isToggleOn: !prevState.isToggleOn
    }));
  }

  render() {
    return (
      &lt;button onClick={this.handleClick}&gt;
        {this.state.isToggleOn ? 'ON' : 'OFF'}
      &lt;/button&gt;
    );
  }
}
</code></pre>
<p>注意：这个 <code>e</code> 是 React 封装过的，但遵循 W3C 标准，因此无需做浏览器差异化处理。</p>
<p>另外，<code>this.handleClick.bind</code> 方法是为了保证在 <code>onClick</code> 中调用了正确的 <code>this</code>，但使用箭头函数可以避免这个累赘的方法：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoggingButton</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  <span class="hljs-comment">// This syntax ensures `this` is bound within handleClick.</span>
  <span class="hljs-comment">// Warning: this is *experimental* syntax.</span>
  handleClick = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'this is:'</span>, <span class="hljs-keyword">this</span>);
  }

  render() {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.handleClick}</span>&gt;</span>
        Click me
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
    );
  }
}
</code></pre>
<h2 id="-18">条件渲染 <a class="header-anchor" href="#-18" aria-hidden="true">&#128279;</a></h2>
<p>例子：</p>
<pre><code class="language-js">render() {
  <span class="hljs-keyword">const</span> isLoggedIn = <span class="hljs-keyword">this</span>.state.isLoggedIn;
  
  <span class="hljs-keyword">let</span> button = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">if</span> (isLoggedIn) {
    button = &lt;LogoutButton onClick={this.handleLogoutClick} /&gt;;
  } else {
    button = &lt;LoginButton onClick={this.handleLoginClick} /&gt;;
  }
  
  return (
    &lt;div&gt;
      &lt;Greeting isLoggedIn={isLoggedIn} /&gt;
      {button}
    &lt;/div&gt;
  );
}
</code></pre>
<h3 id="-19">行内判断 <a class="header-anchor" href="#-19" aria-hidden="true">&#128279;</a></h3>
<p>例子：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Mailbox</span>(<span class="hljs-params">props</span>) </span>{
  <span class="hljs-keyword">const</span> unreadMessages = props.unreadMessages;
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
      {unreadMessages.length &gt; 0 &amp;&amp;
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>
          You have {unreadMessages.length} unread messages.
        <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
      }
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}

<span class="hljs-keyword">const</span> messages = [<span class="hljs-string">'React'</span>, <span class="hljs-string">'Re: React'</span>, <span class="hljs-string">'Re:Re: React'</span>];
ReactDOM.render(
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Mailbox</span> <span class="hljs-attr">unreadMessages</span>=<span class="hljs-string">{messages}</span> /&gt;</span>,
  document.getElementById('root')
);
</span></code></pre>
<p>这段代码的工作方式跟 JavaScript 一致：</p>
<ul>
<li><code>true &amp;&amp; expression</code> -&gt; <code>expression</code></li>
<li><code>false &amp;&amp; expression</code> -&gt; <code>false</code></li>
</ul>
<p>因此，当 <code>unreadMessages.length &gt; 0</code> 为真时，后面的 JSX 会被渲染，反则不会。</p>
<p>除此以外还有三元表达式：</p>
<pre><code class="language-js">render() {
  <span class="hljs-keyword">const</span> isLoggedIn = <span class="hljs-keyword">this</span>.state.isLoggedIn;
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      The user is <span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>{isLoggedIn ? 'currently' : 'not'}<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span> logged in.
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre>
<h3 id="-20">阻止渲染 <a class="header-anchor" href="#-20" aria-hidden="true">&#128279;</a></h3>
<p>在组件的 <code>render</code> 方法内 <code>return null</code> 会阻止组件的渲染，但是其生命周期不受影响。</p>
<h2 id="-21">循环 <a class="header-anchor" href="#-21" aria-hidden="true">&#128279;</a></h2>
<p>一个简单的例子：</p>
<pre><code class="language-js">const numbers = [1, 2, 3, 4, 5];
const listItems = numbers.map((number) =&gt;
  &lt;li&gt;{number}&lt;/li&gt;
);

ReactDOM.render(
  &lt;ul&gt;{listItems}&lt;/ul&gt;,
  document.getElementById('root')
);
</code></pre>
<h3 id="-22">循环组件 <a class="header-anchor" href="#-22" aria-hidden="true">&#128279;</a></h3>
<p>一个列表组件示例：</p>
<pre><code class="language-js">function NumberList(props) {
  const numbers = props.numbers;
  const listItems = numbers.map((number) =&gt;
    &lt;li key={number.toString()}&gt;
      {number}
    &lt;/li&gt;
  );
  return (
    &lt;ul&gt;{listItems}&lt;/ul&gt;
  );
}

const numbers = [1, 2, 3, 4, 5];
ReactDOM.render(
  &lt;NumberList numbers={numbers} /&gt;,
  document.getElementById('root')
);
</code></pre>
<p>注意，这里对列表项添加了一个 <code>key</code> 属性。</p>
<h3 id="key">Key <a class="header-anchor" href="#key" aria-hidden="true">&#128279;</a></h3>
<p><code>Key</code> 是 React 用来追踪列表项的一个属性。跟 angular 以及 vue 中 <code>track-by</code> 的概念一样。</p>
<p>如果列表项没有唯一标识，也可以用索引作为 key （不推荐）：</p>
<pre><code class="language-js">const todoItems = todos.map((todo, index) =&gt;
  // Only do this if items have no stable IDs
  &lt;li key={index}&gt;
    {todo.text}
  &lt;/li&gt;
);
</code></pre>
<p>注意：<code>Key</code> 只能直接在数组循环体内定义。如：</p>
<pre><code class="language-js">function ListItem(props) {
  const value = props.value;
  return (
    // Wrong! There is no need to specify the key here:
    &lt;li key={value.toString()}&gt;
      {value}
    &lt;/li&gt;
  );
}

function NumberList(props) {
  const numbers = props.numbers;
  const listItems = numbers.map((number) =&gt;
    // Wrong! The key should have been specified here:
    &lt;ListItem value={number} /&gt;
  );
  return (
    &lt;ul&gt;
      {listItems}
    &lt;/ul&gt;
  );
}
</code></pre>
]]></description><pubDate>Wed Feb 08 2017 11:33:00 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/react-note-basic</link><guid isPermaLink="true">https://blog.wxsm.space/p/react-note-basic</guid></item><item><title>2016</title><description><![CDATA[<p>刚刚过完了一个非常无聊的元旦。虽然像是很快过了一年的样子，但是又感觉过了很久。因为我已经想不起来年初我在做些什么了。</p>
<p>这次主要说些职业生涯和工作上的东西。其它的，想到再说。</p>
<!--more-->
<h2 id="">工作 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h2>
<p>真的要翻看以前写的每周 report 才能想起来自己上半年做了些什么，不过也都是些没多大意思的项目。比较可喜的是，目前我已经从对内支持工具开发转为了对外产品开发。也算是公司对我的一种肯定吧。</p>
<p>公司下半年好像一直在寻找传统商业模式下的新方向，也尝试了一些新的项目，我基本上都有参与。开发任务基本都可以按时保质完成，然而，目前来说，有些事情于我而言还是比较困难的。比如说思考行业未来，探索可能性等等。说到底，我对公司的业务方向（航运）还是不太感兴趣（或者说完全不感兴趣），再加上本身就不够了解，因此这种事情都是一头雾水。</p>
<p>我们干的是互联网的活，实际却跟这互联网世界相差甚远。这也是我不太满意的地方。在互联网公司工作，做的事情往往比较贴近生活，自己也能有些想法，然而，在这样一家业务深度极大的公司则不然。有种感觉就是，做什么都完全看 PM 怎么说，做完了也不清楚它的价值在哪里，工作就变成了纯粹的开发开发开发。一个项目开发完了紧接着就是下一个项目。</p>
<p>这样子，对公司来说也许足够了，但对个人来说感觉不是一种好的发展模式。不过，最大的问题还是在于兴趣。对业务不感兴趣。</p>
<p>毕业以来，加上实习期，在公司呆了也两年多了，感觉自己在渐渐成长。但，长久呆在一个地方，思维必会僵化。有时候也会想，是不是该换个环境，去看看更大的世界。</p>
<h2 id="-2">学习 <a class="header-anchor" href="#-2" aria-hidden="true">&#128279;</a></h2>
<p>因为工作关系，主攻 Web 开发，因此，2016 年，我认为自己最大的进步是在 ES6 的学习以及组件化开发思想的学习上。</p>
<p>上半年我还是在用传统的 NG 1.x 做前端开发的，Node 也是写 ES5，那时候我还觉得，Angular 是世界上最好的前端框架，ES5 已经足够优秀，完全没有必要再去学新的东西了，一套技术可以用到死。然而拜公司强制所赐，我在一次新项目里面不得不使用 Vue 这个更轻量的东西。</p>
<p>说起来，这事也得感谢公司，人还是太容易满足。就像我现在也开始觉得，Vue 是世界上最优雅的东西，没有必要再用其它的一样。</p>
<p>不过话说回来，我这么喜欢 Vue，以至于远胜谷歌大爹的 Angular，不是空穴来风，最主要的原因是：Vue-loader 实在是非常优秀，将组件化思想以及 ES6 的使用均发挥到了目前看来较高的程度。组件化的开发体验是非常优秀的，这点真的是亲身用过才会有所感悟。</p>
<p>此外，我个人觉得，有所加分的是，Vue 是一个单人项目：只有一个作者，维护者也是作者本人。我认为，一个能力超强的人，远胜五个能力优秀的人。这也是 Vue 能够保持优雅的原因之一。</p>
<p>而 ES6，作为下一代的 JavaScript，虽然看起来大多是语法糖，但是不得不说用还是挺好用。代码量缩减了不少，莫名其妙的问题也少了许多。我个人还是比较希望 Async / Await 早日进入标准，早日实现，这样 JS 也能真正变成优雅且好用的编程语言。如此一来，JavaScript 的天下，必将更大了。</p>
<h2 id="-3">生活 <a class="header-anchor" href="#-3" aria-hidden="true">&#128279;</a></h2>
<p>今年就年底一件大事：买房。把自己的积蓄花光了，父母的积蓄也花了不少，如今过上了吃土的日子。从前都是别人向我借钱，今天也到我跟别人借钱度日的时候。</p>
<p>不过，压力其实不大，就是这俩月会较为难过，能不能活下去就看公司按不按时发工资。</p>
<p>毕业工作一年，我好像也变成了一个无趣的人。曾经日夜鏖战天梯，如今也是要等死了才能醒悟自己身上还有一枚芒果。不过不得不承认的是，很多事情我确实没有天赋，再怎么做，也不过是熟练，熟悉。</p>
<p>前两天元旦假期的时候，过于无聊，把几件有些价值的装备卖了，到 steam 去买了几款好评游戏。100M 的网速下载是快，但我进入游戏后放弃得更快。提不起劲。</p>
<p>有时候也会觉得好笑，我从小就饱受垃圾电脑和网络所带来的痛苦，简直是苦不堪言。可为什么我到今天，进入游戏第一件事依然是把所有配置调到最低呢？</p>
<h2 id="-4">展望 <a class="header-anchor" href="#-4" aria-hidden="true">&#128279;</a></h2>
<p>新的一年，首先希望自己可以继续学习，更甚者，换个紧张些的工作环境去学习。我对目前自己的评价是：基础还行，但知识面不够广。像 React / RN 等东西，我将标注为上半年重点学习对象。虽然 JSX 脱离了历史的进程，我不喜欢，但用的人越来越多，说明它自有好处，因此有必要深入了解一番。</p>
<p>学到的东西多了起来，我也会想自己做点什么。目前来说，Vue 的组件库太少，且质量也非常一般，是阻碍其被广泛使用的一大因素，尤其是 Vue2，因此，我有较大的冲动去开发一个基于 Boostrap 风格或 Material 风格的 Vue2 组件库。来弥补自己对开源社区贡献为 0 的尴尬。</p>
<p>CSS3 某些前沿属性是我目前的基础短板，Codepen 上面很多酷炫的作品如此亮瞎，希望可以找个时间好好学习一番。</p>
<p>希望可以多些涉及移动端开发。不要再在 Web 领域固步自封（当然，也许是通过 RN 或者其它基于 JS 的工具）。</p>
<p>希望新的一年可以赚到更多的钱，还起房贷来没那么大压力，欠父母的钱早日还清。如果还有余钱，考虑买个代步工具。</p>
]]></description><pubDate>Tue Jan 03 2017 08:59:00 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/2016</link><guid isPermaLink="true">https://blog.wxsm.space/p/2016</guid></item><item><title>Fix Outlook Wrong Unread Number Issue</title><description><![CDATA[<p>Sometimes we can see unread numbers on inbox label, but can't actually find them.</p>
<p>Fix steps:</p>
<ol>
<li>In the &quot;Search Current Mailbox (Ctrl+E)&quot; box, type: <code>read:no</code> and hit <kbd>Enter</kbd>.</li>
<li>When it shows &quot;Find More on Server&quot; link, click it. Then the unread email(s) should appear.</li>
</ol>
<p><img src="https://raw.githubusercontent.com/wxsms/wxsms-img-holder/master/outlook-wrong-unread-num.png" alt=""></p>
]]></description><pubDate>Thu Dec 22 2016 09:17:00 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/outlook-wrong-unread-num</link><guid isPermaLink="true">https://blog.wxsm.space/p/outlook-wrong-unread-num</guid></item><item><title>Github Pages and SSL</title><description><![CDATA[<p>经过一些努力，把博客迁移到了 Github Pages，将域名改成了自定义，并且成功启用了 SSL，以下是步骤（就不截图了）。</p>
<h2 id="">部署代码 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h2>
<p>Github Pages 支持两种级别的部署：</p>
<ol>
<li><strong>user / organization</strong> 方式
<ul>
<li>repo 名字必须为 <code>&lt;user-name or org-name&gt;.github.io</code></li>
<li>pages build branch 固定为 <code>master</code></li>
<li>部署后的发布域名即为 repo 名</li>
</ul>
</li>
<li><strong>project</strong> 方式
<ul>
<li>repo 名字没有限制</li>
<li>pages build branch 可以任意指定</li>
<li>发布域名为 <code>&lt;user-name or org-name&gt;.github.io/&lt;project-name&gt;</code></li>
</ul>
</li>
</ol>
<p>因此，如果要做个人页面则必然选择第一种方式。</p>
<p>因为 build branch 限制为 master，因此我一开始选择了重建 repo，实际上没有必要，可以直接 rename 旧的 repo</p>
<p>rename 后，到 repo settings -&gt; options -&gt; Github Pages，即可发现自动部署已经开始了。即刻访问 <code>&lt;user-name or org-name&gt;.github.io</code> 可以看到部署结果。</p>
<h2 id="-2">自定义域名 <a class="header-anchor" href="#-2" aria-hidden="true">&#128279;</a></h2>
<ol>
<li>在 repo settings -&gt; options -&gt; Github Pages -&gt; Custom Domain 中，填入自己的域名，如 <code>wxsm.space</code>，保存</li>
<li>在自己的域名供应商处修改域名解析，添加两条 A 记录（此处可以参考最新<a href="https://help.github.com/articles/setting-up-an-apex-domain/">文档</a>）：
<ul>
<li><code>192.30.252.153</code></li>
<li><code>192.30.252.154</code></li>
</ul>
</li>
<li>等待记录生效</li>
</ol>
<p>过一会就可以发现，使用自定义域名可以访问网站了，并且原 <code>&lt;user-name or org-name&gt;.github.io</code> 会重定向到自定义域名。</p>
<h2 id="ssl">启用 SSL <a class="header-anchor" href="#ssl" aria-hidden="true">&#128279;</a></h2>
<p>这里是最麻烦的。虽然 Github Pages 原生支持 SSL，但是只针对 <code>*.github.io</code> 域名，对于自定义域名，无法直接启用。因此需要找一个支持 SSL 的 CDN 供应商。考虑到免费这个关键因素，选择了 CloudFlare（以下简称 CF）</p>
<ol>
<li>前往 CF 官网，注册账号，填入自己的域名，点几个 Continue</li>
<li>到注册的最后一步时，需要将域名的 DNS 服务器切换为 CF 服务器（CF 会提供两个，两个都要填上），到原域名供应商处修改域名 DNS 服务器即可，24 小时内生效</li>
<li>生效后可以打开网站查看是否正常。控制台页面上方有一个 Crypto Tab，点开，SSL 选择 <code>Flexible</code> 或者 <code>Full</code>，同样需要等待一段时间生效</li>
<li>生效后即可以通过 <code>https</code> 访问网站了，如果需要强制 SSL，可以到 Page Rules Tab，添加一些记录，为某些域名段设置强制 SSL <code>Aways use https</code></li>
</ol>
]]></description><pubDate>Thu Dec 08 2016 17:00:00 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/github-pages-and-ssl</link><guid isPermaLink="true">https://blog.wxsm.space/p/github-pages-and-ssl</guid></item><item><title>D3 Note - Interpolate</title><description><![CDATA[<p><code>d3-interpolate</code> 是 D3 的核心模块之一，与比例尺有些类似，<code>interpolate</code> （插值）所做的也是一些数值映射的工作。区别是，<code>interpolate</code> 的定义域始终是 <strong>0 ~ 1</strong>，并且始终为线性的。所以，更多时候它用来与 D3 的一些其他模组集成使用（如 transition, scale 等）。</p>
<p>举个例子：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> i = d3.interpolateNumber(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>); <span class="hljs-comment">// 10 as a, and 20 as b</span>
i(<span class="hljs-number">0.0</span>); <span class="hljs-comment">// 10</span>
i(<span class="hljs-number">0.2</span>); <span class="hljs-comment">// 12</span>
i(<span class="hljs-number">0.5</span>); <span class="hljs-comment">// 15</span>
i(<span class="hljs-number">1.0</span>); <span class="hljs-comment">// 20</span>
</code></pre>
<p>返回的函数 <code>i</code> 称作 <code>interpolator</code> （插值器）。给定值域 <strong>a</strong> 与 <strong>b</strong>，并且传入 <strong>[0, 1]</strong> 这个闭区间内的任意值，插值器将返回对应的结果。通常情况下，<strong>a 对应参数 0，b 对应参数 1</strong></p>
<p>跟比例尺一样，插值器也可以接受其他类型的参数，如：</p>
<pre><code class="language-js">d3.interpolateLab(<span class="hljs-string">"steelblue"</span>, <span class="hljs-string">"brown"</span>)(<span class="hljs-number">0.5</span>); <span class="hljs-comment">// "rgb(142, 92, 109)"</span>
</code></pre>
<p>甚至对象、数组：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> i = d3.interpolate({<span class="hljs-attr">colors</span>: [<span class="hljs-string">"red"</span>, <span class="hljs-string">"blue"</span>]}, {<span class="hljs-attr">colors</span>: [<span class="hljs-string">"white"</span>, <span class="hljs-string">"black"</span>]});
i(<span class="hljs-number">0.0</span>); <span class="hljs-comment">// {colors: ["rgb(255, 0, 0)", "rgb(0, 0, 255)"]}</span>
i(<span class="hljs-number">0.5</span>); <span class="hljs-comment">// {colors: ["rgb(255, 128, 128)", "rgb(0, 0, 128)"]}</span>
i(<span class="hljs-number">1.0</span>); <span class="hljs-comment">// {colors: ["rgb(255, 255, 255)", "rgb(0, 0, 0)"]}</span>
</code></pre>
<h2 id="d3interpolate">d3.interpolate <a class="header-anchor" href="#d3interpolate" aria-hidden="true">&#128279;</a></h2>
<p><code>interpolate</code> 模块提供了很多子方法，然而，大多数情况下，直接调用这个就足够了。因为 D3 会根据传入的数据类型自动匹配子方法（注意：是基于参数 <strong>b</strong> 的数据类型）。</p>
<p>决定算法：</p>
<ol>
<li>如果 b 是 <code>null</code>, <code>undefined</code> 或 <code>boolean</code>，则函数返回的是常量 b</li>
<li>如果 b 是数字，则使用 <code>interpolateNumber</code> 方法</li>
<li>如果 b 是颜色或者可以转换为颜色的字符串，则使用 <code>interpolateRgb</code> 方法</li>
<li>如果 b 是时间，则使用 <code>interpolateDate</code> 方法</li>
<li>如果 b 是字符串，则使用 <code>interpolateString</code> 方法</li>
<li>如果 b 是数组，则使用 <code>interpolateArray</code> 方法</li>
<li>如果 b 可以强转为数字，则使用 <code>interpolateNumber</code> 方法</li>
<li>使用 <code>interpolateObject</code> 方法</li>
<li>基于 b 的类型，将 a 强转为相同类型</li>
</ol>
<p>各个方法可以直接查看文档获取用法，大同小异。比较有趣的是 <code>interpolateString</code>，它可以检测字符串中的数字，并且做类似这样的事情：</p>
<blockquote>
<p>For example, if a is &quot;300 12px sans-serif&quot;, and b is &quot;500 36px Comic-Sans&quot;, two embedded numbers are found. The remaining static parts of the string are a space between the two numbers (&quot; &quot;), and the suffix (&quot;px Comic-Sans&quot;). The result of the interpolator at t = 0.5 is &quot;400 24px Comic-Sans&quot;.</p>
</blockquote>
<p>至于插值函数的用处，比较多，举一个例子：<strong>d3-transition</strong> 有一些平滑动画的实现函数需要用到插值，比如说地球的动画滚动效果：</p>
<pre><code class="language-js">d3.transition()
  .duration(<span class="hljs-number">1000</span>)
  .tween(<span class="hljs-string">'rotate'</span>, () =&gt; {
    <span class="hljs-keyword">let</span> r = d3.interpolate(projection.rotate(), [-geo[<span class="hljs-number">0</span>], -geo[<span class="hljs-number">1</span>]])
    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">t</span>) =&gt;</span> {
      rotateGlobeByAngle(r(t))
    }
  })
  .on(<span class="hljs-string">'end'</span>, () =&gt; {
     <span class="hljs-comment">// do something...        </span>
  })
</code></pre>
]]></description><pubDate>Mon Dec 05 2016 14:17:00 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/d3-note-interpolate</link><guid isPermaLink="true">https://blog.wxsm.space/p/d3-note-interpolate</guid></item><item><title>D3 Note - Scale</title><description><![CDATA[<p>之前做的柱状图例子：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> data = [<span class="hljs-number">250</span>, <span class="hljs-number">210</span>, <span class="hljs-number">170</span>, <span class="hljs-number">100</span>, <span class="hljs-number">190</span>]

<span class="hljs-keyword">let</span> rectWidth = <span class="hljs-number">25</span>

svg.selectAll(<span class="hljs-string">'rect'</span>)
 .data(data)
 .enter()
 .append(<span class="hljs-string">'rect'</span>)
 .attr(<span class="hljs-string">'y'</span>, (d, i) =&gt; height - d)
 .attr(<span class="hljs-string">'x'</span>, (d, i) =&gt; i * rectWidth)
 .attr(<span class="hljs-string">'height'</span>, d =&gt; d)
 .attr(<span class="hljs-string">'width'</span>, rectWidth - <span class="hljs-number">2</span>)
 .attr(<span class="hljs-string">'fill'</span>, <span class="hljs-string">'steelblue'</span>)
</code></pre>
<p>有一个严重的问题，就是没有比例尺的概念，柱状图的高度完全由数据转换成像素值来模拟。这明显是不科学的：如果数据的值过小或过大，作出来的图就会很奇怪，同时也无法做到非线性的映射。</p>
<p>就跟地图需要比例尺一样，绝大多数的数据图表也需要比例尺。</p>
<blockquote>
<p>Scales are a convenient abstraction for a fundamental task in visualization: mapping a dimension of abstract data to a visual representation.</p>
</blockquote>
<p><strong>比例尺 - Scale - “将某个维度的抽象数据做可视化映射”</strong></p>
<p>至于可视化映射的具体实现，<code>d3-scale</code> 模块提供了许多方案，大致可以分为两类：</p>
<ul>
<li>Continuous Scales（连续映射）</li>
<li>Ordinal Scales（散点映射）</li>
</ul>
<!--more-->
<h2 id="continuous-scales">Continuous Scales <a class="header-anchor" href="#continuous-scales" aria-hidden="true">&#128279;</a></h2>
<p>Continuous Scales（连续映射）将连续的、定量的 <strong>Input Domain</strong>（定义域）映射为一个连续的 <strong>Output Range</strong>（值域）。如果 Range 也是一个数值范围，那么映射操作可以被反转（即从值域到定义域）。</p>
<p>连续值映射是一个抽象的概念，不能直接构造。因此，<code>d3-scale</code> 提供了一些具体实现，如线性、次方、对数等。</p>
<p>一个简单的例子：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> x = d3.scaleLinear()
    .domain([<span class="hljs-number">10</span>, <span class="hljs-number">130</span>])
    .range([<span class="hljs-number">0</span>, <span class="hljs-number">960</span>]);

x(<span class="hljs-number">20</span>); <span class="hljs-comment">// 80</span>
x(<span class="hljs-number">50</span>); <span class="hljs-comment">// 320</span>
</code></pre>
<p>这里构造了一个 <code>scaleLinear</code> （线性比例尺），并设置了输入及输出范围。构造器将会返回一个函数，这个函数接受输入值，并且返回对应的输出值。</p>
<p>如果输入值超出了预定义的范围，那么自然而然地，函数返回的输出值也会超出范围。但是，D3 提供了一个选项 <code>clamp</code>, 可以将输出范围保持在定义值内：</p>
<pre><code class="language-js">x.clamp(<span class="hljs-literal">true</span>);
x(<span class="hljs-number">-10</span>); <span class="hljs-comment">// 0, clamped to range</span>
</code></pre>
<p>Output Domain 除了可以为数字，也可以是其它东西。比如颜色：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> color = d3.scaleLinear()
    .domain([<span class="hljs-number">10</span>, <span class="hljs-number">100</span>])
    .range([<span class="hljs-string">"brown"</span>, <span class="hljs-string">"steelblue"</span>]);

color(<span class="hljs-number">20</span>); <span class="hljs-comment">// "#9a3439"</span>
color(<span class="hljs-number">50</span>); <span class="hljs-comment">// "#7b5167"</span>
</code></pre>
<p>同时，Continuous Scales 也支持<strong>插值</strong>（interpolate）操作，这是 D3 的另一个模块。</p>
<h3 id="linear-scales">Linear Scales <a class="header-anchor" href="#linear-scales" aria-hidden="true">&#128279;</a></h3>
<p><strong>线性比例尺</strong>，顾名思义，输出值对于输入值而言是线性变化的。</p>
<blockquote>
<p>y = ax + b</p>
</blockquote>
<h3 id="power-scales">Power Scales <a class="header-anchor" href="#power-scales" aria-hidden="true">&#128279;</a></h3>
<p><strong>次方比例尺</strong>，与 Linear Scales 类似，但是需要多加一个参数：<code>exponent</code> （次方）</p>
<blockquote>
<p>y = mx^k + b</p>
</blockquote>
<pre><code class="language-js">pow.exponent([exponent]) <span class="hljs-comment">// default 1</span>
</code></pre>
<p>在需要做次方根的时候，使 <code>exponent = 0.x</code> 就可以了，对于 0.5 这个特值，D3 还提供了快捷方式：<code>d3.scaleSqrt()</code>，这将直接构造 <code>exponent = 0.5</code> 的 Power Scale</p>
<h3 id="log-scales">Log Scales <a class="header-anchor" href="#log-scales" aria-hidden="true">&#128279;</a></h3>
<p><strong>对数比例尺</strong>，与 Power Scales 类似，参数变为 <code>base</code> （底数）</p>
<blockquote>
<p>y = m log(x) + b</p>
</blockquote>
<p>因为 log(0) = -∞，Log Scales 的 Input Domain 不能够跨越 0，即要么全为正，要么全为负</p>
<h3 id="identity-scales">Identity Scales <a class="header-anchor" href="#identity-scales" aria-hidden="true">&#128279;</a></h3>
<p><strong>全等比例尺</strong>，特殊的线性比例尺。定义域与值域完全相等。因此，它的 <code>invert</code> 方法也就是它本身。</p>
<blockquote>
<p>y = x</p>
</blockquote>
<h3 id="time-scales">Time Scales <a class="header-anchor" href="#time-scales" aria-hidden="true">&#128279;</a></h3>
<p><strong>时间比例尺</strong>，线性比例尺的变体。例子：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> x = d3.scaleTime()
    .domain([<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2000</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>), <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2000</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)])
    .range([<span class="hljs-number">0</span>, <span class="hljs-number">960</span>]);

x(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2000</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>,  <span class="hljs-number">5</span>)); <span class="hljs-comment">// 200</span>
x(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2000</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">16</span>)); <span class="hljs-comment">// 640</span>
x.invert(<span class="hljs-number">200</span>); <span class="hljs-comment">// Sat Jan 01 2000 05:00:00 GMT-0800 (PST)</span>
x.invert(<span class="hljs-number">640</span>); <span class="hljs-comment">// Sat Jan 01 2000 16:00:00 GMT-0800 (PST)</span>
</code></pre>
<h2 id="sequential-scales">Sequential Scales <a class="header-anchor" href="#sequential-scales" aria-hidden="true">&#128279;</a></h2>
<p><strong>Sequential Scales</strong> 与 <strong>Continuous Scales</strong> 类似，区别是，这个比例尺的值域是由 <code>interpolator</code> 决定的，不可控制。同时，<code>invert</code>, <code>range</code>, <code>rangeRound</code> 以及 <code>interpolate</code> 都不可用。</p>
<p>D3 提供了一系列的颜色插值器，因此其应用场景多与连续的颜色值域有关。</p>
<h2 id="quantize-scales">Quantize Scales <a class="header-anchor" href="#quantize-scales" aria-hidden="true">&#128279;</a></h2>
<p><strong>Quantize Scales</strong> 与 <strong>Linear Scales</strong> 类似，区别是，其值域是离散的。定义域将基于值域元素的个数被切割为<strong>相等的线段</strong>，输出值为线段到值域的<strong>一对一映射</strong>。</p>
<blockquote>
<p>y = m round(x) + b</p>
</blockquote>
<p>例子：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> color = d3.scaleQuantize()
    .domain([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>])
    .range([<span class="hljs-string">"brown"</span>, <span class="hljs-string">"steelblue"</span>]);

color(<span class="hljs-number">0.49</span>); <span class="hljs-comment">// "brown"</span>
color(<span class="hljs-number">0.51</span>); <span class="hljs-comment">// "steelblue"</span>
</code></pre>
<h2 id="quantile-scales">Quantile Scales <a class="header-anchor" href="#quantile-scales" aria-hidden="true">&#128279;</a></h2>
<p><strong>Quantile scales</strong> 与 <strong>Quantize Scales</strong> 类似，区别是，其值域是“离散连续的”，即“<strong>离散的连续片段</strong>”。</p>
<p>首先，构造器会对定义域进行排序操作，然后根据值域元素的个数切分为<strong>相等的片段</strong>。如果无法等分，多余的元素将被加入到最后一组。</p>
<p>如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> quantile = d3.scaleQuantile()
  .domain([<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">16</span>])
  .range([<span class="hljs-string">'blue'</span>, <span class="hljs-string">'white'</span>, <span class="hljs-string">'red'</span>]);

quantile(<span class="hljs-number">3</span>)   <span class="hljs-comment">// will output "red"</span>
quantile(<span class="hljs-number">16</span>)  <span class="hljs-comment">// will output "red"</span>
</code></pre>
<p>解析：</p>
<p>其定义域将先被排序，而后被切分为 3 个片段：<code>[1, 1], [2, 2], [3, 3, 16]</code></p>
<p>此时，如果执行 <code>quantile.quantiles()</code>，将得到一个数组 <code>[2, 3]</code>，长度为值域长度减一。假设将其赋值为 <code>quantiles</code>，其含义为：</p>
<ul>
<li>定义域中小于 <code>quantiles[0]</code> 的值的，将被划分到第一个片段</li>
<li>大于等于数组元素 <code>quantiles[0]</code> 的值但是小于数组元素 <code>quantiles[1]</code> 的值的，将被划分到第二个片段</li>
<li>以此类推</li>
</ul>
<p>划分线段后，定义域就与值域成为一一对应的关系了。因此就有了以上结果。</p>
<h2 id="threshold-scales">Threshold Scales <a class="header-anchor" href="#threshold-scales" aria-hidden="true">&#128279;</a></h2>
<p><strong>Threshold scales</strong> 与 <strong>Quantile Scales</strong> 类似，区别是，我们将往 <code>domain</code> 中 直接传入与前者类似的 <code>quantiles</code>，也就是说，真正的定义域不做限制，限制的是它<strong>划分片段的方式</strong>。</p>
<p>例子：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> color = d3.scaleThreshold()
    .domain([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>])
    .range([<span class="hljs-string">"red"</span>, <span class="hljs-string">"white"</span>, <span class="hljs-string">"green"</span>]);

color(<span class="hljs-number">-1</span>);   <span class="hljs-comment">// "red"</span>
color(<span class="hljs-number">0</span>);    <span class="hljs-comment">// "white"</span>
color(<span class="hljs-number">0.5</span>);  <span class="hljs-comment">// "white"</span>
color(<span class="hljs-number">1</span>);    <span class="hljs-comment">// "green"</span>
color(<span class="hljs-number">1000</span>); <span class="hljs-comment">// "green"</span>
</code></pre>
<h2 id="ordinal-scales">Ordinal Scales <a class="header-anchor" href="#ordinal-scales" aria-hidden="true">&#128279;</a></h2>
<p><strong>Ordinal Scales</strong>（散点映射）</p>
<p>与连续映射不同，散点映射接受<strong>离散的定义域与值域</strong>。比如在一个博客中把不同的标签映射到一组颜色上去等。如果值域的元素量比定义域少，那么值域会“重复使用”。如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> ordinal = d3.scaleOrdinal()
  .domain([<span class="hljs-string">"apple"</span>, <span class="hljs-string">"orange"</span>, <span class="hljs-string">"banana"</span>, <span class="hljs-string">"grapefruit"</span>])
  .range([<span class="hljs-number">0</span>, <span class="hljs-number">100</span>]);

ordinal(<span class="hljs-string">"apple"</span>); <span class="hljs-comment">// 0</span>
ordinal(<span class="hljs-string">"orange"</span>); <span class="hljs-comment">// 100</span>
ordinal(<span class="hljs-string">"banana"</span>); <span class="hljs-comment">// 0</span>
ordinal(<span class="hljs-string">"grapefruit"</span>); <span class="hljs-comment">// 100</span>
</code></pre>
<h3 id="band-scales">Band Scales <a class="header-anchor" href="#band-scales" aria-hidden="true">&#128279;</a></h3>
<p><strong>Band Scales</strong> 与 <strong>Ordinal Scales</strong> 类似，区别是，其<strong>值域是连续的数值</strong>。例子：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> band = d3.scaleBand()
  .domain([<span class="hljs-string">"apple"</span>, <span class="hljs-string">"orange"</span>, <span class="hljs-string">"banana"</span>, <span class="hljs-string">"grapefruit"</span>])
  .range([<span class="hljs-number">0</span>, <span class="hljs-number">100</span>]);

band(<span class="hljs-string">"apple"</span>); <span class="hljs-comment">// 0</span>
band(<span class="hljs-string">"orange"</span>); <span class="hljs-comment">// 25</span>
band(<span class="hljs-string">"banana"</span>); <span class="hljs-comment">// 50</span>
band(<span class="hljs-string">"grapefruit"</span>); <span class="hljs-comment">// 75</span>
</code></pre>
<p>Band Scales 提供了一些实用方法，用于控制映射的结果。比如获取 Band Width，强制转换整数，添加 Padding 等。</p>
<h3 id="point-scales">Point Scales <a class="header-anchor" href="#point-scales" aria-hidden="true">&#128279;</a></h3>
<p><strong>Point Scales</strong> 是 <strong>Band Scales</strong> 的特例，它的 <strong>Band Width 始终为 0</strong></p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> point = d3.scalePoint()
  .domain([<span class="hljs-string">"apple"</span>, <span class="hljs-string">"orange"</span>, <span class="hljs-string">"banana"</span>, <span class="hljs-string">"grapefruit"</span>])
  .range([<span class="hljs-number">0</span>, <span class="hljs-number">100</span>]);

point(<span class="hljs-string">"apple"</span>); <span class="hljs-comment">// 0</span>
point(<span class="hljs-string">"orange"</span>); <span class="hljs-comment">// 33.333333333333336</span>
point(<span class="hljs-string">"banana"</span>); <span class="hljs-comment">// 66.66666666666667</span>
point(<span class="hljs-string">"grapefruit"</span>); <span class="hljs-comment">// 100</span>
</code></pre>
]]></description><pubDate>Tue Nov 22 2016 09:00:00 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/d3-note-scale</link><guid isPermaLink="true">https://blog.wxsm.space/p/d3-note-scale</guid></item><item><title>Static Blog Built with Vue</title><description><![CDATA[<p>博客再次迁移，这次是从 Wordpress 转向静态博客（自建）。</p>
<p>技术栈:</p>
<ul>
<li>前端：vue + vue-router + vuex + bootstrap + webpack</li>
<li>服务端：没有</li>
<li>数据库：没有</li>
</ul>
<p>整站打包后，一次加载所有资源（HTML + CSS + JS + DATA）300K 不到（gzip 后 80K+），秒速渲染，与先前真的是天差地别。</p>
<p>图片资源从本地服务器搬迁到免费云。 写作使用 Markdown，从此 IDE 写博客不是梦。</p>
<p>代码地址：<a href="https://github.com/wxsms/wxsms.github.io/tree/src">https://github.com/wxsms/wxsms.github.io/tree/src</a></p>
]]></description><pubDate>Wed Nov 16 2016 16:55:00 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/static-blog-built-with-vue</link><guid isPermaLink="true">https://blog.wxsm.space/p/static-blog-built-with-vue</guid></item><item><title>D3 Note - Enter, Update and Exit</title><description><![CDATA[<p>在 D3 的使用过程中，我们见得最多的应当是类似如下的代码：</p>
<pre><code>let div = d3.select('body')
  .selectAll('p')
  .data([3, 6, 9, 12, 15])
  .enter()
  .append('p')
  .text(d =&gt; d);
</code></pre>
<p>将得到：</p>
<pre><code>&lt;body&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;p&gt;12&lt;/p&gt;
&lt;p&gt;15&lt;/p&gt;
&lt;/body&gt;
</code></pre>
<p>光看代码完全不能理解 D3 到底做了些什么，其实这里关键是 <code>enter</code> 的使用。</p>
<!--more-->
<h2 id="overall">Overall <a class="header-anchor" href="#overall" aria-hidden="true">&#128279;</a></h2>
<p><code>enter</code> 其实是一个选择集（selection），与其对应的还有 <code>update</code> 与 <code>exit</code>，选择集中的元素由原始选择集与绑定的数据决定。</p>
<p><img src="https://raw.githubusercontent.com/wxsms/wxsms-img-holder/master/4-4-81.png" alt=""></p>
<h2 id="selectionenter">selection.enter <a class="header-anchor" href="#selectionenter" aria-hidden="true">&#128279;</a></h2>
<blockquote>
<p>Returns the enter selection: placeholder nodes for each datum that had no corresponding DOM element in the selection. The enter selection is determined by selection.data, and is empty on a selection that is not joined to data.</p>
<p>The enter selection is typically used to create “missing” elements corresponding to new data.</p>
</blockquote>
<p>简述就是，<code>enter</code> 会根据现有 selection 与绑定的数据量，自动“补齐”所缺失的元素。</p>
<p>比如，例子中，如果 <code>.selectAll('p')</code> 返回的 selection 中包含 3 个元素，那么因为 data 的长度为 5，<code>enter</code> 就会补齐缺失的 2 个元素，并返回包含这三个补齐元素的 selection，接下来的操作，就是针对这个 selection 进行的。</p>
<p>因此，在进行 <code>enter</code> 操作时，一般会事先把相关现有元素尽数清除，以免出现漏操作的情况。</p>
<p>至于再对 <code>enter</code> 选择集进行 <code>append</code> 操作时为什么会追加到 body 节点上去，这里就涉及到另一个概念：<code>selection.update</code></p>
<h2 id="selectionupdate">selection.update <a class="header-anchor" href="#selectionupdate" aria-hidden="true">&#128279;</a></h2>
<p>理解了 <code>enter</code>，<code>update</code> 就很简单了，顾名思义，所指就是已有的，能够与绑定 data 一一对应上的元素的选择集。</p>
<p>因此，实际上并没有 <code>selection.update</code> 这个方法，因为没有必要，当前选到的就是 <code>update</code> 集了。</p>
<p>至于为什么例子中的 <code>enter</code> 集能够追加到 <code>body</code> 中去，根据 D3 文档：</p>
<blockquote>
<p>If the specified type is a string, appends a new element of this type (tag name) as the last child of each selected element, or the next following sibling in the update selection if this is an enter selection.</p>
</blockquote>
<p>当进行 <code>selection.append</code> 操作时，如果 selection 是一个 <code>enter</code> 集，那么 <code>append</code> 就会向相应 <code>update</code> 集的末尾追加。那么，自然，如果 <code>update</code> 集为空，就会往父元素内追加。</p>
<h2 id="selectionexit">selection.exit <a class="header-anchor" href="#selectionexit" aria-hidden="true">&#128279;</a></h2>
<blockquote>
<p>Returns the exit selection: existing DOM elements in the selection for which no new datum was found.</p>
</blockquote>
<p>对于已有 DOM 元素但没有 data 与之绑定的集合，使用 <code>selection.exit</code> 来获取。</p>
<p>如果集合没有绑定 data，则返回空集合。如果多次调用 <code>exit</code>，之后的 <code>exit</code> 会返回空集合。</p>
<p>通常，对于 <code>exit</code> 集的操作，都是 <code>remove</code>：</p>
<pre><code>selection.exit().remove()
</code></pre>
<p> </p>
]]></description><pubDate>Thu Nov 10 2016 11:43:10 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/d3-note-enter-update-and-exit</link><guid isPermaLink="true">https://blog.wxsm.space/p/d3-note-enter-update-and-exit</guid></item><item><title>Webpack HMR Not Work in IDEA</title><description><![CDATA[<ol>
<li>goto 'File | Settings | Appearance &amp; Behavior | System Settings';</li>
<li>uncheck 'Use save write' option</li>
</ol>
<p><img src="https://raw.githubusercontent.com/wxsms/wxsms-img-holder/master/hmr-idea-issue.jpg" alt=""></p>
<p>Problem solved.</p>
]]></description><pubDate>Mon Nov 07 2016 09:44:41 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/webpack-hmr-not-work-in-idea</link><guid isPermaLink="true">https://blog.wxsm.space/p/webpack-hmr-not-work-in-idea</guid></item><item><title>Node.js Web Spider Note - 2</title><description><![CDATA[<h2 id="cookie-session">Cookie &amp; Session <a class="header-anchor" href="#cookie-session" aria-hidden="true">&#128279;</a></h2>
<p>HTTP 是一种无状态协议，服务器与客户端之间储存状态信息主要靠 Session，但是，Session 在浏览器关闭后就会失效，再次开启先前所储存的状态都会丢失，因此还需要借助 Cookie</p>
<p>一般来说，网络爬虫不是浏览器，因此，只能靠手动记住 Cookie 来与服务器“保持联系”。</p>
<h3 id="cookie">Cookie <a class="header-anchor" href="#cookie" aria-hidden="true">&#128279;</a></h3>
<p>Cookie 是 HTTP 协议的一部分，处理流程为：</p>
<ul>
<li>服务器向客户端发送 cookie
<ul>
<li>通常使用 HTTP 协议规定的 set-cookie 头操作</li>
<li>规范规定 cookie 的格式为 name = value 格式，且必须包含这部分</li>
</ul>
</li>
<li>浏览器将 cookie 保存</li>
<li>每次请求浏览器都会将 cookie 发向服务器</li>
</ul>
<p>因此，爬虫要做的工作就是模拟浏览器，识别服务端发来的 Cookie 并保存，之后每次请求都带上 Cookie 头。</p>
<p>在 Node.js 中有很多与 Cookie 处理相关的 package，就不再赘述。</p>
<h3 id="session">Session <a class="header-anchor" href="#session" aria-hidden="true">&#128279;</a></h3>
<p>Cookie 虽然方便，但是由于保存在客户端，可保存的长度有限，且可以被伪造。因此，为了解决这些问题，就有了 Session</p>
<p>区别：</p>
<ul>
<li>Cookie 保存在客户端</li>
<li>Session 保存在服务端</li>
</ul>
<p>Cookie 与 Session 储存的都是客户端与服务器之间的会话状态信息，它们之间主要靠一个秘钥来进行匹配，称之为 <code>SESSION_ID</code> ，如 express 中默认为 <code>connect.sid</code> 字段。只要浏览器发出的 SESSION_ID 与服务器储存的字段匹配上，那么服务器就将其认作为一个 Session，只要 SESSION_ID 的长度足够大，几乎是不可能被伪造的。因此，敏感信息储存在 Session 中要比 Cookie 安全得多。</p>
<p>常见的 Session 存放媒介有：</p>
<ul>
<li>RAM</li>
<li>Database</li>
<li>Cache (e.g. Redis)</li>
</ul>
<p>Session 不是爬虫可以接触到的东西。</p>
<h2 id="ajax">AJAX 页面 <a class="header-anchor" href="#ajax" aria-hidden="true">&#128279;</a></h2>
<p>对于静态页面（服务端渲染），使用爬虫不需要考虑太多，把页面抓取下来解析即可。但对于客户端渲染，尤其是前后端完全分离的网站，一般不能直接获取页面（甚至没有必要获取页面），而是转而分析其实际请求内容。</p>
<h3 id="">请求分析 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h3>
<p>通过一些请求拦截分析工具（如 Chrome 开发者工具）可以截获网站向服务器发送的所有请求以及相应的回复。</p>
<p>包括（不限于）以下信息：</p>
<ul>
<li>请求地址</li>
<li>请求方法（GET / POST 等）</li>
<li>所带参数</li>
<li>请求头</li>
</ul>
<p>只要把信息尽数伪造，那么爬虫发出的请求照样可以从服务器取得正确的结果。</p>
<h3 id="-2">秘钥处理 <a class="header-anchor" href="#-2" aria-hidden="true">&#128279;</a></h3>
<p>一些请求中会带有秘钥（token / sid / secret），可能随除了请求方法外的任一个位置发出，也可能都带有秘钥。更可能不止一个秘钥。</p>
<p>理论上来说，正常客户端取得秘钥有两种方式：</p>
<ul>
<li>服务端提供</li>
<li>客户端自行计算，由服务端校对</li>
</ul>
<p>对于服务端提供给客户端的秘钥，只要仔细分析 HTML 或服务端返回的 Cookie Header 就一定能发现。</p>
<p>而对于客户端自行计算的秘钥则比较麻烦了，尤其是在 JS 代码加密、混淆的情况下。这种时候，只能自己去用开发者工具调试原始站点代码，找出加密代码段，并在爬虫中实现。这里面有许多技巧，如各种断点、单步调试等。</p>
<h2 id="-3">表单处理 <a class="header-anchor" href="#-3" aria-hidden="true">&#128279;</a></h2>
<p>表单实际上也是 HTTP 请求，使用 GET / POST 等方法即可模拟表单提交。然而这不是重点。重点是表单常常伴随着验证码而存在。</p>
<p>验证码的识别暂未涉及。</p>
<h2 id="-4">浏览器模拟 <a class="header-anchor" href="#-4" aria-hidden="true">&#128279;</a></h2>
<p>爬虫的下下策才是使用浏览器完全模拟用户操作。实在是属于无奈之举。Nodejs 可以驱动 Chrome 与 Firefox 浏览器，存在相应的 Package，但是，更方便的是使用各种 E2E Testing 工具。</p>
<p>比如 Night Watch JS：</p>
<pre><code>module.exports = {
 'Demo test Google' : function (client) {
 client
 .url('http://www.google.com')
 .waitForElementVisible('body', 1000)
 .assert.title('Google')
 .assert.visible('input[type=text]')
 .setValue('input[type=text]', 'rembrandt van rijn')
 .waitForElementVisible('button[name=btnG]', 1000)
 .click('button[name=btnG]')
 .pause(1000)
 .assert.containsText('ol#rso li:first-child',
 'Rembrandt - Wikipedia')
 .end();
 }
};
</code></pre>
<p>在这种模式下，Cookie / Session / 请求等各种细节都不用关心了。只需要按部就班地执行操作即可。模拟浏览器的代价是效率太低，内存开销大，但在某些特定需求情况下，却比一般爬虫要简单得多。</p>
<p> </p>
]]></description><pubDate>Sat Nov 05 2016 14:45:26 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/node-js-web-spider-note-2</link><guid isPermaLink="true">https://blog.wxsm.space/p/node-js-web-spider-note-2</guid></item><item><title>D3 Note - Basis</title><description><![CDATA[<p>D3 (Data-Driven Documents) 是一个 JavaScript Library，用来做 Web 端的数据可视化实现以及各种绘图。</p>
<blockquote>
<p><strong>D3.js</strong> is a JavaScript library for manipulating documents based on data. <strong>D3</strong> helps you bring data to life using HTML, SVG, and CSS.</p>
</blockquote>
<p>学习 D3 需要很多预备知识：</p>
<ol>
<li>HTML / DOM</li>
<li>CSS</li>
<li>JavaScript (better with jQuery)</li>
<li>SVG</li>
</ol>
<p>HTML / CSS 不必多说，因为 D3 含有大量链式操作函数以及选择器等，因此如果有 jQuery 基础将轻松很多。此外，由于一般采用 SVG 方式进行绘图，所以 SVG 基础知识也需要掌握。</p>
<p>虽然必须的预备知识如此之多，但 D3 的定位其实是 Web 前端绘图的底层工具，所谓底层，即是操作复杂而功能强大者。</p>
<!--more-->
<h2 id="svg">关于 SVG <a class="header-anchor" href="#svg" aria-hidden="true">&#128279;</a></h2>
<p>SVG (Scalable Vector Graphics) 是一种绘图标准，已经被绝大多数的现代浏览器所支持。SVG 采用 XML 语法定义图像，可直接嵌入 HTML 中使用。</p>
<p>SVG 的特点是矢量绘图（与 Canvas 不同），除了预设样式以外同时也支持 CSS 样式。</p>
<p>比如，画一个园圈，坐标为 (100, 50)，半径为 40px，拥有 2px 的黑色 border，以及红色填充：</p>
<pre><code>&lt;svg&gt;
    &lt;circle cx=&quot;100&quot; cy=&quot;50&quot; r=&quot;40&quot; stroke=&quot;black&quot; stroke-width=&quot;2&quot; fill=&quot;red&quot;/&gt;
&lt;/svg&gt;
</code></pre>
<p>SVG 有一些预定义的形状元素，可被开发者使用和操作：</p>
<ul>
<li>矩形 <rect></li>
<li>圆形 <circle></li>
<li>椭圆 <ellipse></li>
<li>线 <line></li>
<li>折线 <polyline></li>
<li>多边形 <polygon></li>
<li>路径 <path></li>
</ul>
<p>其中，<code>path</code> 是功能最强大者，使用 <code>path</code> 可以构成所有图形。</p>
<h2 id="">选择器 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h2>
<h3 id="-2">选择元素 <a class="header-anchor" href="#-2" aria-hidden="true">&#128279;</a></h3>
<p>D3 使用与 jQuery 类似的选择器来获取 HTML 元素。常用的方法有：</p>
<ul>
<li><code>d3.select(selector)</code></li>
<li><code>d3.selectAll(selector)</code></li>
</ul>
<p>（参数既可以传 selector 也可以直接传 HTML Element ）</p>
<p>顾名思义，<code>selectAll</code> 就是选择所有符合条件的元素了，那么 <code>select</code> 选择的是符合条件的第一个元素。如：</p>
<pre><code>d3.select('body') //选择 body 元素

d3.selectAll('p') //选择所有 p 元素

d3.selectAll('.className') //选择所有 class 包含 className 的元素
</code></pre>
<p>更多就不说了。</p>
<h3 id="-3">操作选择 <a class="header-anchor" href="#-3" aria-hidden="true">&#128279;</a></h3>
<p>选择器返回的是一组<strong>选择</strong>（selection），这组<strong>选择</strong>可以进行一些操作，如：</p>
<ul>
<li>在此选择的基础上继续选择；</li>
<li>改变属性；</li>
<li>改变样式；</li>
<li>绑定事件；</li>
<li>插入、删除；</li>
<li>绑定数据。</li>
</ul>
<p>大多数操作都与 jQuery 十分类似，同时也支持链式操作，不再赘述。只是这个“绑定数据”操作稍有特别。</p>
<h2 id="-4">数据绑定 <a class="header-anchor" href="#-4" aria-hidden="true">&#128279;</a></h2>
<p>通过 D3 可以把数据“绑定”到 HTML 元素上，绑定的目的主要是为了方便一些需要相应数据才能进行的元素操作（如：更改元素大小、位置等）。</p>
<p>绑定数据有两个方法：</p>
<ul>
<li><code>datum</code>: 将一个数据绑定到选择上；</li>
<li><code>data</code>: 将一个数组绑定到选择上，数组的各项分别与选择的各项一一对应。</li>
</ul>
<p>下面引用一个例子来说明这二者的不同。假设有如下三个节点：</p>
<pre><code>&lt;p&gt;Apple&lt;/p&gt;
&lt;p&gt;Pear&lt;/p&gt;
&lt;p&gt;Banana&lt;/p&gt;
</code></pre>
<h3 id="datum">datum <a class="header-anchor" href="#datum" aria-hidden="true">&#128279;</a></h3>
<p>执行以下代码：</p>
<pre><code>let str = 'datum';
let p = d3.selectAll('p');

p.datum(str);
p.text((d, i) =&gt; `Element ${i} bind with ${d}`);
</code></pre>
<p>将得到：</p>
<pre><code>Element 0 bind with datum
Element 1 bind with datum
Element 2 bind with datum
</code></pre>
<p>在对选择进行操作时，传入的<strong>值</strong>可以是<strong>值</strong>，也可以是函数。当传入函数时，D3 会向函数注入两个参数，分别是 d (data) 与 i (index)，代表当前元素绑定的数据与其索引。</p>
<h3 id="data">data <a class="header-anchor" href="#data" aria-hidden="true">&#128279;</a></h3>
<p>执行以下代码：</p>
<pre><code>let strArr = ['data0', 'data1', 'data2'];
let p = d3.selectAll('p');

p.data(strArr);
p.text((d, i) =&gt; `Element ${i} bind with ${d}`);
</code></pre>
<p>将得到：</p>
<pre><code>Element 0 bind with data0
Element 1 bind with data1
Element 2 bind with data2
</code></pre>
<p>可以看到，数组中的 3 个项分别与 3 个 p 元素绑定到了一起。因此，可以将 <code>datum</code> 看作是 <code>data</code> 函数的一个特例，实际开发中使用更多的是 <code>data</code> 函数。</p>
<h2 id="-5">实践：简单柱状图 <a class="header-anchor" href="#-5" aria-hidden="true">&#128279;</a></h2>
<p>先定义一个 SVG 画布，并将它插入到 HTML 的 body 中去：</p>
<pre><code>let width = 300,
  height = 300；

let svg = d3.select('body')
  .append('svg')
  .attr('width', width)
  .attr('height', height);
</code></pre>
<p>在这里，画布的宽高都为 300 像素。</p>
<p>然后，定义一组数据：</p>
<pre><code>let data = [250, 210, 170, 100, 190];
</code></pre>
<p>最后使用以上数据画出柱状图，柱子使用 SVG 预定义的 <code>rect</code> 元素：</p>
<pre><code>let rectWidth = 25;

svg.selectAll('rect')
 .data(data)
 .enter()
 .append('rect')
 .attr('y', (d, i) =&gt; height - d)
 .attr('x', (d, i) =&gt; i * rectWidth)
 .attr('height', d =&gt; d)
 .attr('width', rectWidth - 2)
 .attr('fill', 'steelblue');
</code></pre>
<p><code>rectWidth</code> 表示柱子的宽度，至于坐标、宽高则分别通过 x / y 以及 height / width 属性来控制，效果如下：</p>
<p><img src="https://raw.githubusercontent.com/wxsms/wxsms-img-holder/master/d3-chart.gif" alt=""></p>
<p>可以发现，这里并没有指定需要插入的 <code>rect</code> 个数，但 D3 却根据数据量自动地把图画出来了，这个工作是通过 <code>enter</code> 语句完成的。关于其工作原理，下回分解。</p>
]]></description><pubDate>Tue Oct 25 2016 10:40:44 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/d3-note-basis</link><guid isPermaLink="true">https://blog.wxsm.space/p/d3-note-basis</guid></item><item><title>WordPress 掉坑记录</title><description><![CDATA[<p>忍无可忍，长期更新。</p>
<p>（其实我很想自己重新做一个 blog，但是太麻烦，也没什么实践价值了，无非 CRUD，而且维护起来很容易忽略 blog 本身的目的所在）</p>
<!--more-->
<h2 id="">关于代码高亮 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h2>
<p>本站目前（截至 09/20/2016）使用的是 Crayon 插件，这个插件配合 TinyMCE Advanced 简直神了，用户的数据对它们来说都不是什么东西，反正就随着各自的意愿来搞。其实这样还好，关键是，他俩意愿不一致。这 TM 就很尴尬了。以至于我很多文章，编辑再保存以后，格式出现各式各样的问题。</p>
<p>最终解决方案：</p>
<ol>
<li>禁用 TinyMCE Advanced 的 keep <code>p</code> &amp; <code>br</code> 功能；</li>
<li>禁用 Crayon 的所有其它扫描功能，只保留 <code>pre</code> 扫描，即只保留块级代码高亮，同时禁用移除 <code>code</code> 标签的相关功能；</li>
<li>关于行内代码的解决继续看下面。</li>
</ol>
<p>那么行内代码怎么办呢。这个 Crayon 太奇葩，如果用它自带的工具插入行内标签（原始是 <code>span</code>），会被它自己扫描出来认为是过时标签，然后强行转为 <code>pre</code>，关键是这一转它自己认得倒还好，然而 TinyMCE 不认为它仍然是行内元素，强行给它换行，套 <code>p</code> 元素。</p>
<p>然后文章的格式就完了，而且是全完。</p>
<p>所以，解决办法是，不要使用 Crayon 的行内模式，也不要让它扫描行内代码，直接使用 <code>code</code> 标签，然后去改 style，改得跟块级代码差不多就行了。</p>
<p>注：写完这些我就把 Crayon 这插件给删了。一个乱搞用户数据库，而且不用标准标签的东西，不要也罢。就直接用 <code>code</code> 和 <code>pre</code>，还方便以后向其它平台转移。</p>
]]></description><pubDate>Tue Sep 20 2016 15:14:47 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/wordpress-hole-record</link><guid isPermaLink="true">https://blog.wxsm.space/p/wordpress-hole-record</guid></item><item><title>Node.js Web Spider Note - 1</title><description><![CDATA[<p>项目地址：<a href="https://github.com/edisond/zhihu-spider" target="_blank">https://github.com/edisond/zhihu-spider</a></p>
<p>简介：使用 Node.js 实现的一个简单的知乎爬虫，可以以一个用户为入口，爬取其账号下的一些基本信息，关注者，关注话题等。再通过关注者的 ID 继续爬取其他用户，以此循环。</p>
<p>实现功能：登录知乎（因为调用一些知乎 API 需要保存 session），解析页面，访问 AJAX API，保存到数据库。</p>
<!--more-->
<h2 id="">执行流程 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h2>
<p><img src="https://raw.githubusercontent.com/wxsms/wxsms-img-holder/master/Flowchart.png" alt=""></p>
<p>蓝色部分的任一流程出现失败或错误，程序都会直接返回到“从种子队列取出一个用户ID”这一步。因为作为一个完整的知乎用户来说，它应该是包含了个人信息，关注以及话题的，缺失一项会导致其失去很大部分的意义。</p>
<h2 id="-2">技术栈 <a class="header-anchor" href="#-2" aria-hidden="true">&#128279;</a></h2>
<p>本程序以 Node.js 为实现核心（本机版本 v6.5.0），用到的依赖很少，如下：</p>
<pre><code>&quot;dependencies&quot;: {
  &quot;asyncawait&quot;: &quot;^1.0.6&quot;, //模拟ES7 async/await语法
  &quot;jquery&quot;: &quot;^3.1.0&quot;, //用来解析HTML
  &quot;jsdom&quot;: &quot;^3.1.2&quot;, //为HTML和jQuery模拟浏览器环境
  &quot;lodash&quot;: &quot;^4.15.0&quot;,
  &quot;log4js&quot;: &quot;^0.6.38&quot;,
  &quot;mocha&quot;: &quot;^3.0.2&quot;, //用于单元测试
  &quot;mongoose&quot;: &quot;^4.6.0&quot;, 
  &quot;superagent&quot;: &quot;^2.2.0&quot;, //请求发送
  &quot;superagent-promise&quot;: &quot;^1.1.0&quot; //请求发送的Promise封装
}
</code></pre>
<h2 id="-3">程序解析 <a class="header-anchor" href="#-3" aria-hidden="true">&#128279;</a></h2>
<p>程序源代码在代码仓库的 <code>src</code>  目录下，目录结构：</p>
<pre><code>├─config
├─constants
├─http
├─model
├─parsers
│  ├─follow
│  ├─topic
│  └─user
├─services
├─spiders
└─utils
</code></pre>
<h3 id="-4">配置相关以及通用模块 <a class="header-anchor" href="#-4" aria-hidden="true">&#128279;</a></h3>
<p><code>config</code>  目录主要放置一些程序的配置文件，比如用来登录知乎的用户名和密码，想要抓取的用户种子，数据库连接地址，以及 log 的配置。</p>
<p><code>constants</code>  目录下是一些对知乎的特定配置，如 url 地址、规则，以及知乎 API 的一些信息，如表单、请求头格式等。</p>
<p><code>util</code>  目录下目前是放置了一些数据库以及 log4js 的初始化方法，如自动扫描 models 加载以及创建 log 目录等，以便于在程序入口处调用。</p>
<p><code>models</code>  则是 mongoose 的各种 schema了，用于持久化。</p>
<h3 id="-5">登录模块 <a class="header-anchor" href="#-5" aria-hidden="true">&#128279;</a></h3>
<p>登录虽然不是爬虫的重点，但却是必不可少的前提。因为对于知乎网站来说，不登录的话只能看到单个用户的个人页面，想要再前往关注者页面就不可能了。这就造成一个问题：爬虫无法持续工作。</p>
<p>因此，此模块的主要职责是，在爬虫运行的过程当中保证已登录状态。</p>
<p>此模块放置在 <code>http/session</code>  中。</p>
<h3 id="-6">爬虫模块 <a class="header-anchor" href="#-6" aria-hidden="true">&#128279;</a></h3>
<p>程序核心之一，同时也是最容易出现问题的地方（尤其是启用多线程以后），负责发送 Http 请求并接受响应。</p>
<p>除了简单的单次请求以外，因为一些特定的原因，里面还涉及到了递归请求。</p>
<h3 id="-7">转换模块 <a class="header-anchor" href="#-7" aria-hidden="true">&#128279;</a></h3>
<p>程序核心之一，负责将爬取回来的 HTML 文本、API 返回体等转换成 model 对象，没什么技术含量，体力活。</p>
<h3 id="service">Service <a class="header-anchor" href="#service" aria-hidden="true">&#128279;</a></h3>
<p>其实就是将单次爬取的整个流程定义封装好，供主程序调用。</p>
<p>同时也负责爬取结果的储存，以及用户种子队列的管理。</p>
<h2 id="-8">重点难点 <a class="header-anchor" href="#-8" aria-hidden="true">&#128279;</a></h2>
<h3 id="-9">模拟登录 <a class="header-anchor" href="#-9" aria-hidden="true">&#128279;</a></h3>
<p>这次经历让我意识到什么都靠 Google 也有不行的时候，因为爬虫这东西，虽然肯定也有别人做过，但是基本上都过时了，人家网站早更新了，真刀真枪还是得靠自己。</p>
<p>整个过程虽然简单，但是由于经验匮乏，还是走了不少弯路。最终总结出来的必须步骤如下：</p>
<p><img src="https://raw.githubusercontent.com/wxsms/wxsms-img-holder/master/loginflow.png" alt=""></p>
<p>代码如下：</p>
<pre><code>function login(_user) {
  user = _user;
  return new Promise((resolve, reject) =&gt; {
    getCaptcha()
      .then(resolveCaptcha)
      .then(getLoginCookie)
      .then(_getXsrfToken)
      .then(() =&gt; {
        logger.info('Login success!');
        resolve();
      })
      .catch((err) =&gt; {
        reject('Login failed: ' + err);
      })
  })
}
</code></pre>
<p>（目前并没有在所有地方都用上 async await，之后改过来）</p>
<p>获取验证码很简单，但是要注意的是把 response 里面的 <code>set-cookie</code>  信息保存起来添加到一会要登录的请求上去，因为不这么做的话，知乎服务器不认为登录那一次请求跟这个验证码有什么关系。</p>
<p>“解析验证码”这一步目前是这个程序最难看（难看，不是难）的地方，因为用的是土法炼钢：人眼解析。我尝试过用一些通用的验证码识别库去做自动化，但是正确率太低，而且知乎它的验证码有随机两套字体，反正好像训练起来也麻烦，所以就没继续研究下去了，毕竟不是爬虫主体，而且只需要在程序启动的时候输入一次即可。</p>
<p>登录请求的模拟，可以在知乎网站上使用浏览器的开发控制台启用“任意 XHR 断点”来截获网站发送的真实登录请求以及服务器返回来进行伪造。实际上就是填一个表单 POST 出去，然后返回的时候把 response 里面的 <code>set-cookie</code>  信息保存起来添加到以后要使用的所有请求的 header 上去就行了，因为服务器它就是靠这一堆 cookie 值来判断客户端所处的会话。</p>
<p>最后就是那个所谓的“秘钥”，网站上的名字叫 <code>xsrf</code> ，知乎在这里做了一些手脚。它在 set-cookie 中并没有提供这一串秘钥，但是如果我要请求它的 API，那么 cookie 里面就必须有这个键值对，明显网站是通过 JS 动态加进去的。然而我没有必要这么做，只需要在一开始的时候就把它拿到，然后以后每次请求都带上它就可以了。至于怎么拿也很简单，知乎每个页面都有的隐藏的输入框，里面的值就是。</p>
<pre><code>xsrfToken = $('input[name=_xsrf]').val();
</code></pre>
<p>这四步做完以后，程序就成功登录了。</p>
<h3 id="-10">获取关注 <a class="header-anchor" href="#-10" aria-hidden="true">&#128279;</a></h3>
<p>去到知乎的关注者、已关注页面可以发现，内容是随着页面滚动逐步加载的，因此这里存在一个 API 可以使用，无需爬页面。使用浏览器开发者控制台，我们可以截取到 API 的详细信息，以下是我总结的一个：</p>
<pre><code>userFollowers: {
    url: () =&gt; 'https://www.zhihu.com/node/ProfileFollowersListV2',
    pageSize: () =&gt; 20,
    form: (hashId, offset) =&gt; {
      offset = typeof offset === 'undefined' ? 0 : offset;
      return {
        method: 'next',
        params: `{&quot;offset&quot;:${offset},&quot;order_by&quot;:&quot;created&quot;,&quot;hash_id&quot;:&quot;${hashId}&quot;}`
      }
    },
    header: (userName, token) =&gt; {
      return {
        'X-Xsrftoken': token,
        'X-Requested-With': 'XMLHttpRequest',
        'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
        Referer: zhihu.url.userFollowers(userName)
      }
    }
  }
</code></pre>
<p>form 是 API 需要发送的表单，而 header 则是这次请求额外需要的 header（指包括登录获取的 header）。</p>
<p>由于它这个是按 page 来的，每次请求最多只会返回 20 条记录，到底了就会返回空数组，因此我做了一个 Promise 递归来实现这个功能。另外，由于有的用户关注加起来上万条，全部遍历完实在是太慢（不知道会不会一去不回），所以我把抓取的总数限制在了 100 条。至于总数的这个数量，在其它地方可以获取到，不需要通过这里获取，所以无所谓。</p>
<pre><code>function resolveByPage(user, offset, apiObj) {
  let header = Object.assign(session.getHttpHeader(), apiObj.header(user.id, session.getXsrfToken()));
  let form = apiObj.form(user.hashId, offset);
  //No more than 100 (too slow)
  if (offset + apiObj.pageSize() &gt; 100) {
    return Promise.resolve([]);
  }
  return superagent
    .post(apiObj.url())
    .set(header)
    .send(form)
    .end()
    .then((res) =&gt; {
      let data = parser.fromJson(res.text);
      if (!data.list.length) {
        return [];
      }
      return resolveByPage(user, offset + apiObj.pageSize(), apiObj)
        .then((nextList) =&gt; {
          return [].concat(data.list, nextList);
        })
        .catch((e) =&gt; {
          return [];
        });
    })
}
</code></pre>
<h3 id="-11">持续工作 <a class="header-anchor" href="#-11" aria-hidden="true">&#128279;</a></h3>
<p>爬虫如何持续工作这个问题一开始我是挺头疼的，就是说当一次任务结束以后，要如何自动开始下一次任务。由于全是异步操作，直接 while 1 肯定要炸。</p>
<p>后来看到 async await 语法，终于写出了一个可工作的版本。（Node.js v6.5.0 还没有原生支持 async await，所以用到了一个库）</p>
<pre><code>let next = async(function (threadId) {
  try {
    let userId = await(userQueueService.shift());
    logger.info(`Thread ${threadId} working on user ${userId}`);
    let user = await(userService.resolveAndSave(userId));
    await(userQueueService.unshiftAll([].concat(user.followers_sample, user.followees_sample)));
  } catch (err) {
    if (err.name === 'MongoError') {
      err = err.message;
    }
    logger.error(err);
  }
});

let thread = async(function (id) {
  while (1) {
    await(next(id));
  }
});
</code></pre>
<p>程序执行到 <code>await</code>  关键字的地方就会阻塞，直到语句返回再继续。</p>
<p>至于多线程，直接简单暴力：</p>
<pre><code>let main = async(function () {
  await(userService.login());
  for (let i = 0; i &lt; 5; i++) {
    thread(i)
  }
});
</code></pre>
<p>这样，执行 main 方法，程序就有 5 个线程同时工作了。</p>
<h2 id="-12">目前的问题 <a class="header-anchor" href="#-12" aria-hidden="true">&#128279;</a></h2>
<h3 id="-13">效率 <a class="header-anchor" href="#-13" aria-hidden="true">&#128279;</a></h3>
<p>5 条线程还是太慢，一小时大约能抓 1000 个用户的样子，但是我又不能再多开，再开线程请求数就爆了，各种报错、失败，得不偿失。</p>
<p><del>我在想是不是能再开几个 Node.js 进程同时跑这个程序。质量不行数量来补。</del></p>
<p>09/12/2016 更新：这个办法不行。请求数限制是在服务器端做出的。貌似无解。</p>
<h3 id="-14">稳定性 <a class="header-anchor" href="#-14" aria-hidden="true">&#128279;</a></h3>
<p>这个是目前很头疼的问题。我发现程序在跑一个小时或者两个小时以后，5 条线程就只剩下一条或者两条还在工作，其它的都失踪了，或者干脆全都死在那里了。其实我知道它们没死，只不过不知道为什么卡住了。</p>
<p>第一次发现的时候觉得有点逗，感觉就像自己生了五个孩子后来死剩两个一样。</p>
<p>09/12/2016 更新：目前发现了一个原因，即有些知乎用户的个人主页被屏蔽了，导致解析失败，但是又没有 catch 导致线程无限挂住。解决这个以后问题依然存在，高度怀疑是因为 session 过期。</p>
<p>09/14/2016 更新：果然是 session 过期的原因。在登录的表单中加入一个字段 <code>remember_me: true</code> 以后，线程死掉的问题就解决了！Excited！</p>
]]></description><pubDate>Sat Sep 10 2016 23:12:05 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/node-js-web-spider-note-1</link><guid isPermaLink="true">https://blog.wxsm.space/p/node-js-web-spider-note-1</guid></item><item><title>JavaScript Promise</title><description><![CDATA[<p>知乎上有一个黑 JavaScript 的段子，大概是说：</p>
<blockquote>
<p>N 年后，外星人截获了 NASA 发射的飞行器并破解其源代码，翻到最后发现好几页的 }}}}}}……</p>
</blockquote>
<p>这是因为 NASA 近年发射过使用 JavaScript 编程的飞行器，而 Node.js 环境下的 JavaScript 有个臭名昭著的特色：Callback hell（回调地狱的意思）</p>
<p>JavaScript Promise 是一种用来取代超长回调嵌套编程风格（特指 Node.js）的解决方案。</p>
<p>比如：</p>
<pre><code>getAsync(&quot;/api/something&quot;, (error, result) =&gt; {
    if(error){
        //error
    }
    //success
});
</code></pre>
<p>将可以写作：</p>
<pre><code>let promise = getAsyncPromise(&quot;/api/something&quot;); 
promise.then((result) =&gt; {
    //success
}).catch((error) =&gt; {
    //error
});
</code></pre>
<p>乍一看好像并没有什么区别，依然是回调。但最近在做的一个东西让我明白，Promise 的目的不是为了干掉回调函数，而是为了干掉嵌套回调函数。</p>
<!--more-->
<h2 id="">定义 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h2>
<p>MDN 定义：</p>
<blockquote>
<p>The Promise object is used for asynchronous computations. A Promise represents a value which may be available now, or in the future, or never.</p>
</blockquote>
<p>意思大概就是，Promise 是专门用于异步处理的对象。一个 Promise 代表着一个值，这个值可能已经获得了，又可能在将来的某个时刻会获得，又或者永远都无法获得。</p>
<p>简单地说，Promise 对象就是值的代理。经纪人。</p>
<h2 id="-2">简单用法 <a class="header-anchor" href="#-2" aria-hidden="true">&#128279;</a></h2>
<p>创建一个 Promise：</p>
<pre><code>let promise = new Promise((resolve, reject) =&gt; {
    //success -&gt; resolve(data)
    //error -&gt; reject(data)
});
</code></pre>
<p>使用 <code>new Promise</code>  来创建 Promise 对象，构造器中传入一个函数，同时对该函数传入 <code>resolve</code>  和 <code>reject</code>  参数，分别代表异步处理成功与失败时将要调用的方法。</p>
<p>处理 Promise 结果：</p>
<pre><code>promise.then(onFulfilled, onRejected)
</code></pre>
<p>使用 <code>then</code>  方法来注册结果函数，共可以注册两个函数，其中 <code>onFulfilled</code>  代表成功，后者代表失败。两个参数都是可选参数。</p>
<p>不过，对于失败处理，更加推荐的方式是使用 <code>catch</code>  方法：</p>
<pre><code>promise.catch(onRejected)
</code></pre>
<p>这两个方法可以进行链式操作。组合示例：</p>
<pre><code>function asyncFunction() {
    return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            resolve('Async Hello world');
        }, 1000);
    });
}

asyncFunction()
    .then((value) =&gt; {
        console.log(value); //Async Hello world
    })
    .catch((error) =&gt; {
        console.log(error);
    });
</code></pre>
<p>这里使用了定时器来模拟异步过程，实际上其它异步过程（如 XHR）也大概都是这么个写法。</p>
<h2 id="-3">状态 <a class="header-anchor" href="#-3" aria-hidden="true">&#128279;</a></h2>
<p>Promise 对象共有三种状态：</p>
<ul>
<li>Fulfilled （成功）</li>
<li>Rejected （失败）</li>
<li>Pending （处理中）</li>
</ul>
<p>有两条转换路径：</p>
<ul>
<li>Pending -&gt; Fulfilled -&gt; <code>then</code>  call</li>
<li>Pending -&gt; Rejected -&gt; <code>catch</code>  call</li>
</ul>
<p>Promise 对象的状态，从 Pending 转换为 Fulfilled 或 Rejected 之后， <code>then</code>  方法或者 <code>catch</code>  方法就会被立即调用，并且这个 promise 对象的状态不会再发生任何变化。也就是说，调用且只调用一次。</p>
<h2 id="-4">链式操作 <a class="header-anchor" href="#-4" aria-hidden="true">&#128279;</a></h2>
<p>链式操作是 Promise 对象的一大亮点。</p>
<p>本节引用一些 <a href="https://github.com/azu/promises-book" target="_blank"><em>Promise Book</em></a> 的内容。</p>
<p>例如：</p>
<pre><code>function taskA() {
    console.log(&quot;Task A&quot;);
}
function taskB() {
    console.log(&quot;Task B&quot;);
}
function onRejected(error) {
    console.log(&quot;Catch Error: A or B&quot;, error);
}
function finalTask() {
    console.log(&quot;Final Task&quot;);
}

var promise = Promise.resolve();
promise
    .then(taskA)
    .then(taskB)
    .catch(onRejected)
    .then(finalTask);

//Task A
//Task B
//Final Task
</code></pre>
<p>该代码块实际流程如图所示：</p>
<p><img src="https://raw.githubusercontent.com/wxsms/wxsms-img-holder/master/promise-then-catch-flow.png" alt=""></p>
<p> </p>
<p>可以看到，这个 onRejected 并不仅仅是 TaskB 的失败处理函数，同时它也是 TaskA 的失败处理函数。而且当 TaskA 失败（reject 被调用或者抛出异常）时，TaskB 将不会被调用，直接进入失败处理。熟悉 express 的玩家应该能看出来了，这简直就和中间件一模一样嘛。</p>
<p>比如说，TaskA 出现异常：</p>
<pre><code>function taskA() {
    console.log(&quot;Task A&quot;);
    throw new Error(&quot;throw Error @ Task A&quot;)
}
function taskB() {
    console.log(&quot;Task B&quot;);// 不会被调用
}
function onRejected(error) {
    console.log(error);// =&gt; &quot;throw Error @ Task A&quot;
}
function finalTask() {
    console.log(&quot;Final Task&quot;);
}

var promise = Promise.resolve();
promise
    .then(taskA)
    .then(taskB)
    .catch(onRejected)
    .then(finalTask);
</code></pre>
<p>这里的输出应该就是：</p>
<pre><code>//Task A
//Error: throw Error @ Task A
//Final Task
</code></pre>
<p>需要注意的是，如果在 <code>onRejected</code>  或 <code>finalTask</code>  中出现异常，那么这个异常将不会再被捕捉到。因为并没有再继续注册 <code>catch</code>  函数。</p>
<p>借助 Promise 链式操作的特点，复杂的 JavaScript 回调简化将不再是梦。</p>
<h2 id="-5">递归 <a class="header-anchor" href="#-5" aria-hidden="true">&#128279;</a></h2>
<p>Promise 可以实现递归调用，在用来一次性抓取所有分页内容的时候有用。例：</p>
<pre><code>function get(url, p) {
  return $.get(url + &quot;?page=&quot; + p)
      .then(function(data) {
          if(!data.list.length) {
              return [];
          }

          return get(url, p+1)
              .then(function(nextList) {
                  return [].concat(data.list, nextList);
              });
      });
}

get(&quot;urlurl&quot;, 1).then(function(list) {
    console.log(list);//your full list is here
});
</code></pre>
<h2 id="-6">实用方法 <a class="header-anchor" href="#-6" aria-hidden="true">&#128279;</a></h2>
<h3 id="promiseall">Promise.all <a class="header-anchor" href="#promiseall" aria-hidden="true">&#128279;</a></h3>
<p><code>Promise.all</code>  接受一个 promise 对象的数组作为参数，当这个数组里的所有promise对象全部变为 resolve 或 reject 状态的时候，它才会去调用 <code>then</code>  方法。</p>
<p>例：</p>
<pre><code>function taskA() {
    return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            console.log('TaskA resolved!');
            resolve();
        }, 1000);
    });
}

function taskB() {
    return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            console.log('TaskB resolved!');
            resolve();
        }, 2000);
    });
}

function main() {
    return Promise.all([taskA(), taskB()]);
}

main()
    .then((value) =&gt; {
        console.log('All resolved!');
    })
    .catch((error) =&gt; {
        console.log(error);
    });

//TaskA resolved!
//TaskB resolved!
//All resolved!
</code></pre>
<h3 id="promiserace">Promise.race <a class="header-anchor" href="#promiserace" aria-hidden="true">&#128279;</a></h3>
<p>跟 <code>Promise.all</code>  类似，略有区别，从名字就能看出来，只要有一个 Task 执行完毕，整个 Promise 就会返回。但是需要注意的是，返回以后并不会取消其它未完成的 Promise 的执行。</p>
<pre><code>function taskA() {
    return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            console.log('TaskA resolved!');
            resolve();
        }, 1000);
    });
}

function taskB() {
    return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            console.log('TaskB resolved!');
            resolve();
        }, 2000);
    });
}

function main() {
    return Promise.race([taskA(), taskB()]);
}

main()
    .then((value) =&gt; {
        console.log('All resolved!');
    })
    .catch((error) =&gt; {
        console.log(error);
    });

//TaskA resolved!
//All resolved!
//TaskB resolved!
</code></pre>
<h2 id="-7">支持性 <a class="header-anchor" href="#-7" aria-hidden="true">&#128279;</a></h2>
<p>由于是 ES6 语法，目前在浏览器端支持不是特别好，很多移动端浏览器以及 IE 家族均不支持（具体可查看 MDN）。如果要在浏览器端使用需要借助 Babel 编译器。</p>
<p>至于 Node.js 环境则毫无问题。</p>
]]></description><pubDate>Mon Sep 05 2016 17:27:26 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/javascript-promise</link><guid isPermaLink="true">https://blog.wxsm.space/p/javascript-promise</guid></item><item><title>WP 2016 主题使用摘要</title><description><![CDATA[<p>2016 主题设置里没有提供是否使用摘要的选项，因此如果文章不做任何操作，首页以及归档页都会显示全文，导致页面非常地长。但是，一番机缘巧合，我发现只要在文章里面插入了 <code>more</code> 标签，主题就会自动检测到并且切换到摘要模式。</p>
<p>妄我在 Google 上苦苦探索，搜集到一堆垃圾代码，然而并没有什么用。</p>
]]></description><pubDate>Wed Aug 31 2016 17:15:31 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/using-excerpt-in-wp-2016-theme</link><guid isPermaLink="true">https://blog.wxsm.space/p/using-excerpt-in-wp-2016-theme</guid></item><item><title>令牌软件使用体验</title><description><![CDATA[<p>所谓令牌，就是说，一个账号在登录的时候，除了要提供常规密码外，还要提供一组动态密码。而动态密码的来源，可以是实体设备，也可以是软件。</p>
<p>这里就说两个手机 APP：Steam 令牌与网易将军令。</p>
<p>APP 的功能很简单：在用户需要登录的时候提供动态密码。</p>
<ul>
<li>Steam 令牌会在用户需要的时候主动推送动态密码到通知；</li>
<li>而网易将军令需要用户手动打开软件查看动态密码。</li>
</ul>
<p>哪一种设计更好呢？</p>
<!--more-->
<p>我在用的时候就觉得，为什么将军令这么笨，不懂得直接把密码推送给我呢？每次要自己去打开烦不烦。</p>
<p>网易招回去的研究生、博士们，真的就想不到这一点吗？</p>
<p>后来仔细想了想，这里面大概还是有原因的！</p>
<p>除了是否要主动打开 APP 以外，手机软件还有一个隐藏区别：用户是否已解锁。显然，使用推送方式谁都能看到敏感的动态密码，而打开 APP 则必须要有用户手机已解锁的前提。</p>
<p>这样一来，万一用户的账号在使用令牌的情况下被盗，责任划分可就不一样了。Steam 不好说，可能要扯皮，反正网易将军令肯定是 100% 免责：用户不设手机密码，手机密码被盗或破解，越狱，ROOT 等情况或行为，均与网易无关。</p>
<p>（不过这些可能在服务条款里声明也没什么事，毕竟银行提供的还是实体设备，其安全与否就只能看用户是否持有设备。难道网易是真的没考虑过主动推送？）</p>
]]></description><pubDate>Mon Aug 29 2016 16:22:07 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/token-apps-usage-experiences</link><guid isPermaLink="true">https://blog.wxsm.space/p/token-apps-usage-experiences</guid></item><item><title>2016-08-25</title><description><![CDATA[<p>今天下班路上看到一对情侣，一路欢声笑语，走在没有信号灯的斑马线上，也要往马路上面站，车流离他们不到十米吧，女生不时地尝试走向对面又马上退回，脸上带着无忧无虑笑容，男友也丝毫没有阻止的意思。</p>
<p>我在后面看着，有种奇怪的感觉。觉得，这世界上也许有些人就是注定要死得早些吧。不过，又有点希望自己也能做一个这样的人。</p>
]]></description><pubDate>Thu Aug 25 2016 19:17:54 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/2016-08-25</link><guid isPermaLink="true">https://blog.wxsm.space/p/2016-08-25</guid></item><item><title>无题</title><description><![CDATA[<p>最近，工作地所在的园区推出了一款 App，宣传的主要功能是获取园区动态以及扫码付款，感觉这样吃饭可以方便一些，因此就下载了。</p>
<p>应用的名字叫“园圈”，在 App Store 上搜索出来，底下是一个没有见过的开发商。我觉得还算正常吧，一般这种小范围应用，不都是外包的吗。只是，这使我对于这个应用的使用埋下了一丝戒心。（后来我搜索了一下这家公司，网站充斥着强烈的国企风）</p>
<p>进入应用，首先要我注册，这很简单，手机号码验证码啪啪啪就输完了。然后，它要求我输入一个密码。我毫不犹豫地就输入了常用密码，在即将要点下一步的时候，却犹豫了一下。</p>
<!--more-->
<p>我在想的是：</p>
<ol>
<li>它是一个不知名的小公司</li>
<li>它已经知道了我的手机号码</li>
<li>它即将要知道我的常用密码</li>
</ol>
<p>虽然我已经在不知道多少地方用过这个密码，但是这一次我就是不想在这用了。其它很多手机应用，提供了手机号码就会让用户直接登录，然而这个应用却强制要我再填一个密码。这对于它来说太简单了，获得一个用户的手机号以及常用密码，它可以用来做任何事情。并且，更可怕的是，没有人会关注它。</p>
<p>于是我清除输入并换了一组密码。</p>
<p>接下来，它要求我输入一个手势密码。</p>
<p>我从来没有用过手势密码，但它没有提供跳过选项，因此就画了个圈以示敬意。</p>
<p>但是，我想，如果是在其它地方用过手势密码的用户，这里应该是毫不犹豫的吧。虽然得到这个貌似用处并没有像手机号加密码那么明显，但是，不论怎么说，这家公司又获得了一项用户信息。</p>
<p>并且，这个以园区动态发布以及小额支付为主要（或者说唯二）功能的应用，有什么必要同时使用密码与手势密码呢？不得而知。</p>
<p>历尽千辛，终于来到了主界面，界面其实就是支付宝和咸鱼的结合体，没什么特别的。动态都是一些领导视察之类的文章，于是我就点开了“付款”功能。</p>
<p>首先，我要同意一个用户协议。</p>
<p>然后，输入六位数的支付密码。</p>
<p>至此，这是它要求我输入的第三个密码。并且是较为敏感的六位数密码。</p>
<p>这样就很不好了。</p>
<p>然而，不知道为什么，我当时还是如实填写了。</p>
<p>一切都填好以后，我终于可以仔细查看一下它的付款功能。很简单，支付宝或者微信充值，然后二维码扫码支付，却缺少了重要的一项：余额转出。</p>
<p>这真 TM 是一个忧伤的故事，说到底还是跟充饭卡没什么区别，只要你用不完，那么充进去的钱就算是捐了。</p>
<p>唯一的区别是，我向这家公司无偿提供了我的手机号码，以及密码，手势密码以及支付密码。</p>
<p>我突然觉得，这是一波实实在在的送温暖行动。</p>
<p>这让我想起几个月前在一家米粉店付款的时候，我选择使用支付宝，从店家的微信公众号直接跳转到了一个要求输入账号密码的，UI 跟支付宝一模一样的页面。几乎是本能反应的我点了“使用浏览器打开”，果然这不是一个 alipay 域名下的网站。</p>
<p>然而，如果用户不是一个程序员，或者不熟悉互联网的点点滴滴，他有多大几率能注意到并且发现诸如此类的事情呢？</p>
]]></description><pubDate>Thu Aug 04 2016 10:15:11 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/untitled-3</link><guid isPermaLink="true">https://blog.wxsm.space/p/untitled-3</guid></item><item><title>Windows 无法删除 Node_modules 文件夹的解决方案</title><description><![CDATA[<p>在 Windows 操作系统下开发 NodeJS 项目的时候经常会遇到无法删除 Node_modules 文件夹的尴尬（因为依赖过多，文件路径长度爆炸），解决办法如下。</p>
<p>全局安装 <code>rimraf</code> 模块到系统下：</p>
<pre><code>npm install -g rimraf
</code></pre>
<p>CD 到相应文件夹，执行如下指令：</p>
<pre><code>rimraf node_modules
</code></pre>
<p>等待其完成即可。</p>
<p>其实这个模块也可以用来删除其它无法正常删除的东西，挺好用的。Node 用习惯了以后可以为系统提供许多便利，比如说现在我都不怎么使用系统自带的计算器了，直接 WIN + R + NODE 就可以得到一个 Node 环境下的计算器，非常快捷。</p>
]]></description><pubDate>Thu Jul 28 2016 16:56:40 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/solution-to-windows-cant-remove-node-modules-folder</link><guid isPermaLink="true">https://blog.wxsm.space/p/solution-to-windows-cant-remove-node-modules-folder</guid></item><item><title>删除了一个游戏</title><description><![CDATA[<p>今天，在N连跪呕心沥血终于推倒对面一座塔赢了以后，我把皇室战争这个游戏删了。</p>
<p>通常来说，删除一个游戏的原因无非几种：没兴趣，不好玩，玩腻了，等等。但是，皇室战争这个游戏，却比较特别。</p>
<p>要说它不好玩呢，其实挺有意思的，也挺符合现代游戏的节奏，不需要长时间在线，有空抽几分钟玩一局即可。</p>
<p>要说玩腻了呢，其实也没有，虽说已经玩了好几个月，但是很多酷炫的卡我依然还没有开到。</p>
<p>然后，问题在哪里呢？</p>
<!--more-->
<p><strong>我在这个游戏里面完全找不到快乐。</strong></p>
<p>很奇葩啊。一个在其它方面如此优秀的游戏，却完全忽视了一个游戏应该拥有的最基本的要素：它至少要能够让人感到快乐，哪怕是历尽八十一难以后的快乐。</p>
<p>然而，这个游戏，除了给予痛苦，愤怒，以及绝望以外，完全没有其它产出。</p>
<p><strong>痛苦</strong></p>
<p>一个人在这个游戏里能够获得的成就，由什么来决定呢？很不幸，我给出的答案是，5% 的技术，35% 的运气，以及 60% 的氪金。简单来说，这是一个氪金决定一切的游戏，因此，人民币战士就不讨论了，重点说一下像我这样的零氪玩家。</p>
<p>零氪玩家群体，在游戏中就是一个平等的群体了吗？很不幸，依然不是。在这种前提下，运气就是决定成就的最终因素。因为，皇室战争是一款卡牌对战游戏，卡牌在前，对战在后，你连卡都没有，拿什么对战呢？手上一堆屌丝卡牌，想凭借过人的技术和风骚的走位屹立在零氪之巅？我只能说，这个梦做得可以。</p>
<p>于此同时，更加残酷的现实是，游戏并没有零氪专区，就好像现实世界也没有设置单身狗专区一样。我除了要与运气比我好得多的零氪玩家斗智斗勇以外，时不时还要充当一下游戏本身为人民币玩家提供的服务。</p>
<p><strong>愤怒</strong></p>
<p>如果这个游戏仅仅是由以上内容，那它并不会使我感到愤怒，因为至少我还可以安静地玩我自己的游戏。</p>
<p>然而，很遗憾，游戏有一项特色机制，我觉得，应该称之为嘲讽机制。</p>
<p>在对战过程中，对手可以不断地发表情对我进行调戏，其实认真地说，都是一些很普通的表情，但是在某些场景下，就一定会让人觉得是一种嘲讽。</p>
<p>就很像 DOTA 中的“技不如人，甘拜下风”。</p>
<p>也许你会说，这不是很正常吗，任何对抗类游戏都会存在嘲讽这样的东西吧。</p>
<p>但是，皇室战争中的嘲讽，比较蛋疼。面对对手的嘲讽，97% 的情况都是无能为力的。为什么是 97% 呢？因为刚才说了，选手技术对游戏胜负只有 5% 的决定作用，而我对自己比较自信，给自己多加 1% 不过分吧。</p>
<p>也就是说，开局第一波交锋以后发现怼不过对面并且受到了嘲讽，97% 的情况下我都做不了任何改变。只能选择默默地被继续嘲讽，或者直接退出游戏。</p>
<p>这种情况，一开始遇到也许会觉得有趣，但是认真玩下去以后就会使人感到愤怒。</p>
<p><strong>绝望</strong></p>
<p>我痛苦着，我愤怒着，我卧薪尝胆总可以吧，前期痛苦越大，后面不就会获得更强烈的成就感吗？这样一来，它也可以稳稳地留住我这样的玩家。</p>
<p>然而并不会。</p>
<p>这也就是我说“绝望”的原因。</p>
<p>前期运气差，通过长时间的收集，总能够获得一些稀有卡片的。但是，有意义吗？卡片变好了就会进入更高阶的竞技场，结果是继续被更高阶的玩家吊打。就算我冲到了零氪玩家之巅，又如何？依然要被人民币战士吊打。</p>
<p>我要氪金呢？很遗憾，这个游戏，小氪完全不能给玩家带来任何改变，因为除了氪金，还有 35% 的运气成分在啊！而且，就算我疯狂氪金，在吊打一波渣渣以后，我也还是得继续被比我更有钱的人吊打。这个游戏带给我的东西不会有任何变化。</p>
<p>至于嘲讽，自然而然，我也可以嘲讽别人。但是问题在于，唯一能让我感到有趣的嘲讽是在首先受到了对手的嘲讽并成功翻盘的案例。这种情况，聊胜于无。</p>
<p>那么，我可以故意降杯去欺负新人吗？</p>
<p>啊，终于，发现了一条可行的路子。但是，我依然要保持一定的负场率，不然还是会在吊打菜狗的过程中不知不觉爬回到原本的竞技场，继续被吊打。</p>
<p>其实有很多人也确实是这么做了。我经常玩着玩着看到一些人掏出几个 9 级甚至 10 级的卡片，就会想，你这么厉害，还在这里干什么啊。然后就只能等死。这真是一个忧伤的故事。</p>
<p>其实这游戏有一个缺陷：它只有一种游戏模式。虽然它对游戏性把握得比较好，不容易感到疲倦，但是，这也就导致了我完全无法回避上面所提出的种种问题。最近新出的一个锦标赛模式就不谈了，我连加入都从来没有成功过，谈何体验。</p>
]]></description><pubDate>Wed Jul 27 2016 15:13:22 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/deleted-a-game</link><guid isPermaLink="true">https://blog.wxsm.space/p/deleted-a-game</guid></item><item><title>WordPress 更改后台字体为雅黑</title><description><![CDATA[<p>这个问题其实困扰了我很久。默认的后台字体实在是惨不忍睹。今天终于发现了一个很好的方案，完美解决。</p>
<p>在当前主题的 <code>functions.php</code> 中，加上如下代码：</p>
<pre><code>/**
 * 更改后台字体为雅黑
 */
function change_admin_font(){
    echo '&lt;style type=&quot;text/css&quot;&gt;.wp-admin{font-family: \'Helvetica Neue\', Helvetica, \'Microsoft Yahei\', \'Hiragino Sans GB\', \'WenQuanYi Micro Hei\', sans-serif;}&lt;/style&gt;';
}
add_action('admin_head', 'change_admin_font');
</code></pre>
<p>顺便提供一下更改 Twenty Sixteen 主题字体的代码吧，要改的地方挺多的。</p>
<!--more-->
<pre><code>/* reset font */
body,
button,
input,
select,
textarea,
button,
button[disabled]:hover,
button[disabled]:focus,
input[type=&quot;button&quot;],
input[type=&quot;button&quot;][disabled]:hover,
input[type=&quot;button&quot;][disabled]:focus,
input[type=&quot;reset&quot;],
input[type=&quot;reset&quot;][disabled]:hover,
input[type=&quot;reset&quot;][disabled]:focus,
input[type=&quot;submit&quot;],
input[type=&quot;submit&quot;][disabled]:hover,
input[type=&quot;submit&quot;][disabled]:focus,
.post-password-form label,
.main-navigation,
.post-navigation,
.post-navigation .post-title,
.pagination,
.image-navigation,
.comment-navigation,
.site .skip-link,
.logged-in .site .skip-link,
.widget .widget-title,
.widget_recent_entries .post-date,
.widget_rss .rss-date,
.widget_rss cite,
.tagcloud a,
.site-title,
.entry-title,
.entry-footer,
.sticky-post,
.page-title,
.page-links,
.comments-title,
.comment-reply-title,
.comment-metadata,
.pingback .edit-link,
.comment-reply-link,
.comment-form label,
.no-comments,
.required,
.site-footer .site-title:after,
.widecolumn label,
.widecolumn .mu_register label {
    font-family: 'Helvetica Neue', Helvetica, 'Microsoft Yahei', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', sans-serif;
}

::-webkit-input-placeholder {
    font-family: 'Helvetica Neue', Helvetica, 'Microsoft Yahei', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', sans-serif;
}

:-moz-placeholder {
    font-family: 'Helvetica Neue', Helvetica, 'Microsoft Yahei', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', sans-serif;
}

::-moz-placeholder {
    font-family: 'Helvetica Neue', Helvetica, 'Microsoft Yahei', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', sans-serif;
}

:-ms-input-placeholder {
    font-family: 'Helvetica Neue', Helvetica, 'Microsoft Yahei', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', sans-serif;
}
</code></pre>
<p> </p>
]]></description><pubDate>Wed May 25 2016 19:33:45 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/wordpress-change-admin-panel-font</link><guid isPermaLink="true">https://blog.wxsm.space/p/wordpress-change-admin-panel-font</guid></item><item><title>MEAN.JS 搭配 forever 使用以防止 app crash</title><description><![CDATA[<p>MEANJS 预设的 Grunt task 中没有提供类似出错自动重启的任务，因此当实际使用它搭建了一个 app 部署到服务器上后发现经常有一些奇怪的问题导致其崩溃挂掉。然而根据 log 来看问题应该不是由于项目代码导致的，可能是 MEANJS 本身的问题，也可能是某些 Lib 的问题。这种情况下，我能想到的暂时性解决方案就是使用 forever 了。</p>
<p>个人觉得 MEANJS 在 production mode 中也使用 nodemon 来跑 watch 任务有些鸡肋，因为我们并不需要在产品服务器上频繁地更改代码。因此，我直接把它替换掉了。</p>
<!--more-->
<p>这里需要注意的是，我们不能直接用 forever 去跑 <code>server.js</code> 脚本，因为这样的话下层代码拿不到 env settings，就会把启动模式设置为默认的开发模式。</p>
<p>因为 MEANJS 中已经自带了 forever 模块，所以就不用装它本身了，但是要安装 forever 的 grunt 插件：grunt-forever</p>
<pre><code>npm install grunt-forever -save
</code></pre>
<p>在 tasks（initConfig） 中加多一项：</p>
<pre><code>forever: {
  server: {
    options: {
      index: 'server.js',
        logFile: 'log.log',
        outFile: 'out.log',
        errFile: 'err.log'
    }
  }
}
</code></pre>
<p>这里指定了 forever 执行的对象，以及 log 文件名，路径可以不指定，默认为项目根目录下的 forever 文件夹。因为这个插件生成的是守护进程，所以 log 只能输出到文件啦。</p>
<p>最后更改一下 prod task：</p>
<pre><code>// Run the project in production mode
grunt.registerTask('prod', ['build', 'env:prod', 'mkdir:upload', 'copy:localConfig', 'forever:server:start']);
</code></pre>
<p>OK，大功告成。</p>
<p>启动 production 服务器方式：</p>
<pre><code>grunt prod
</code></pre>
<p>重启方式：</p>
<pre><code>grunt forever:server:restart
</code></pre>
<p>停止服务器：</p>
<pre><code>grunt forever:server:stop
</code></pre>
<p> </p>
]]></description><pubDate>Thu May 19 2016 15:24:46 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/mean-js-use-forever-to-prevent-app-crash</link><guid isPermaLink="true">https://blog.wxsm.space/p/mean-js-use-forever-to-prevent-app-crash</guid></item><item><title>记一次项目经历</title><description><![CDATA[<p>前几天收到一个项目请求，其实是某人希望做个简单的毕设代码实现。因为去年毕业季的时候帮同学的一些朋友做过毕设项目，因此找到了我，希望继续帮忙。因为这种东西一般都比较简单，所以我也没想很多就答应了。</p>
<!--more-->
<p>这位同学通过 QQ 联系上了我。她的具体需求是一个基于 C# 的 <a href="http://ASP.NET">ASP.NET</a> 网站，就几个页面，非常简单，但是相比去年做的那几个稍复杂些，因此我提高了要价，开价 500，为了让对方确信我没有在坐地起价，我还把她师姐们的需求文档都发了过去，让她自己对比。</p>
<p>然而，对方依然觉得太贵了，说想要“友情价”。我觉得挺搞笑的，脸皮很厚嘛。不过我也不想扯皮，就当你是个穷困潦倒的学生吧，大家都经历过，我也当做好事了，于是就降到了 400，说实话这个价格我是真不想做。虽然只需要一天，但是没意思，就跟上班一天一样，而且还是加班，还没有双倍工资。</p>
<p>其实除了这些，更让我觉得难过的是，对方是“几乎什么都不懂”，因此我后期可能还有非常多的工作需要做。在对方论文完成以前，我可能会成为免费技术顾问，而且她会觉得这是我理所当然应该做的。</p>
<p>约定的交货期限大概是十天的样子。于是就开始了。</p>
<p>大概在第五天的时候，对方想找我要数据库的截图，我说干嘛呢，她说贴论文里，要交初稿了。我去，合着我还帮你写论文呢。然而这时间我还没开始动手，我也没有义务提前交货，于是说想要就给加班费。对方就放弃了。</p>
<p>后来几天没有联系过。到了约定日期我把项目通过 QQ 发送给了对方，第二天早上就发现自己给删了好友。</p>
<p>其实故事到这里本该结束了。我没花多少时间，也不在乎这点钱。爱给不给吧。</p>
<p>然而，好在我有一个责任感强烈的“经纪人”。</p>
<p>就是那位给我介绍这个项目的同学，我简单地说明了一下情况，她深感自己把我坑了，于是千辛万苦帮我追数。其实我也挺过意不去的，这说到底是我的疏忽，现在反而要麻烦别人。我一直强调没事算了吧，然而“经纪人”始终不肯善罢甘休。</p>
<p>在这期间，有一些不知道是与项目主人何种关系的人来联系我，希望通过支付部分款项以息事宁人等。然而这些人的交流方式让我略感奇怪，三句不离同情，说得我跟个要饭的一样，因此没有同意。</p>
<p>最终，在“将作弊行为告知导师”的压力下，项目主人现身道歉，并且支付了全款。</p>
<p>后来，我反思了一下。我是以在校学生的思维方式来对待这件事情的，其实最近我也越发觉得这种思维方式让自己在社会中非常吃亏。现在来说，至少我也应该尊重自己的劳动力吧。同时，自己的错误也给别人带来了不必要的麻烦。</p>
<p>至于项目主人那边的几位，我只能说“人各有志”。收到钱的第二分钟，她们就全在我的黑名单里面了。</p>
]]></description><pubDate>Tue Apr 05 2016 14:47:06 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/some-project-memo</link><guid isPermaLink="true">https://blog.wxsm.space/p/some-project-memo</guid></item><item><title>JavaScript 事件代理</title><description><![CDATA[<p>jQuery 曾经存在 3 种绑定事件的方法：bind / live / delegate，后来 live 被砍掉了，只留下 bind 与 delegate，它们之间的区别是，通过 bind 方法绑定的事件，只对当前存在的元素生效，而通过 delegate 则可以绑定“现在”以及“将来”的所有元素。</p>
<p>为“将来”元素绑定事件的适用场景还是挺多的。比如一个列表，或者一个表格，它可能会动态地被插入或者移除一些子元素，然后每个元素都需要有一个点击事件，这样的话我们就需要保证“现在”已存在的元素以及“将来”可能被添加进去的元素都能够正常工作。怎么办呢，我们总不能每插入一个元素就给它绑一次事件吧（事实上我以前没少干这事），因此 jQuery 就为我们提供了后者的方法。</p>
<p>一开始我觉得很奇怪，像 delegate 这样的方法是怎么实现的呢？通过监听 DOM 树变化吗？性能开销会不会特别大？后来知道了 JavaScript 有一种机制叫事件代理（event delegation），也就是本文要说的东西，才明白，原来一切都很简单。</p>
<!--more-->
<h2 id="">事件代理及其工作原理 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h2>
<p>何为代理呢，大概就是，你把你要做的事情告诉我，我帮你做，我就是你的代理。</p>
<p>那么事件代理，顾名思义，在一个元素上触发的事件，由另一个元素去处理，后者就是前者的事件代理。</p>
<p>大概就是这么回事。那么，如何实现呢？</p>
<p>这里就涉及两个关于 JavaScript 事件的知识：事件冒泡（event bubbling）以及目标元素（target element）：</p>
<ul>
<li>当一个元素上触发事件的时候，比如说鼠标点击了一个按钮，同样的事件将会在它的所有祖先元素上触发。这就是所谓的事件冒泡。</li>
<li>所有事件的目标元素都将是最原始触发它的那个特定元素，就比如说那个按钮，其引用将被储存在事件对象内。</li>
</ul>
<p>因此，我们可以做到：</p>
<ul>
<li>给一个节点绑定事件</li>
<li>等待其子孙节点的冒泡事件</li>
<li>判断事件实际来源</li>
<li>做出相应处理</li>
</ul>
<p>这就是事件代理的工作原理。</p>
<h2 id="-2">有什么用 <a class="header-anchor" href="#-2" aria-hidden="true">&#128279;</a></h2>
<p>一个典型的场景是，如果一个表格有 100 行 100 列，你需要给每一个单元格都添加点击事件，怎么办？</p>
<p>当然可以说一次性把它们全选出来，绑定事件不就完了。但是，内存 BOOM，浏览器 BOOM</p>
<p>用事件代理就简单多了，给 table 绑一次事件，然后等它们冒泡上来就行了。</p>
<p>还有就是动态添加的元素。比如某一时刻 table 被添加了一行，那么新的一行其事件同样能冒泡并且被 table 上的事件处理器接收到。</p>
<h2 id="-3">代码 <a class="header-anchor" href="#-3" aria-hidden="true">&#128279;</a></h2>
<p>Talk is cheap, show me the code.</p>
<pre><code>//Some browser diff issue handler
function getEventTarget(e) {
  e = e || window.event;
  return e.target || e.srcElement;
}

//Easy event handler on 'table' element
function editCell(e) {
  var target = getEventTarget(e);
  if(target.tagName.toLowerCase() === 'td') {
    // DO SOMETHING WITH THE CELL
  }
}
</code></pre>
<p> </p>
]]></description><pubDate>Fri Apr 01 2016 11:38:12 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/javascript-event-delegation</link><guid isPermaLink="true">https://blog.wxsm.space/p/javascript-event-delegation</guid></item><item><title>高效 CSS 与 Reflow &amp; Repaint</title><description><![CDATA[<h2 id="css">高效 CSS <a class="header-anchor" href="#css" aria-hidden="true">&#128279;</a></h2>
<p>如何编写高效 CSS 其实是一个过时的话题。</p>
<p>这方面曾经存在许多真知灼见，比如说 CSS 选择器的解析方向是从子到父，比如说 ID 选择器是最快的，不应该给 Class 选择器加上 Tag 限制，尽量避免使用后代选择器等。但是，随着浏览器解析引擎的发展，这些都已经变得不再那么重要了。MDN 上阐述高效 CSS 的文章也已经被标记为过时。</p>
<p>Antti Koivisto 是 Webkit 核心的贡献者之一，他曾说：</p>
<blockquote>
<p>My view is that authors should not need to worry about optimizing selectors (and from what I see, they generally don’t), that should be the job of the engine.</p>
</blockquote>
<p>因此，如果把“高效 CSS”的含义限制为“高效 CSS 选择器”的话，那么实际上现在它已经不是开发者需要关心的问题了。我们需要做的事情变得更“政治正确”：保证功能与结构的良好可维护性即可。</p>
<p>那么 CSS 的性能还能通过什么方式提升呢？这就是下面的内容。</p>
<!--more-->
<h2 id="reflow-repaint">Reflow &amp; Repaint <a class="header-anchor" href="#reflow-repaint" aria-hidden="true">&#128279;</a></h2>
<h3 id="">概览 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h3>
<p>Reflow （回流）和 Repaint（重绘）是浏览器的两种动作。</p>
<ul>
<li>Repaint 会在某个元素的外观发生变化，但没有影响布局时触发。比如说 <code>visibility</code>  / <code>outline</code>  / <code>background-color</code>  等 CSS 属性的变化将会触发 Repaint</li>
<li>Reflow 在元素变化影响到布局时触发</li>
</ul>
<p>显然，Reflow 的代价要比 Repaint 高昂得多，它影响到了页面部分（或者所有）的布局。一个 元素的 Reflow 动作同时也会触发它的所有后代 / 祖先 / 跟随它的 DOM 节点产生 Reflow</p>
<p>比如说：</p>
<pre><code>&lt;body&gt;
&lt;div&gt;
	&lt;h4&gt;Hello World&lt;/h4&gt;
	&lt;p&gt;&lt;strong&gt;Welcome: &lt;/strong&gt;......&lt;/p&gt;
	&lt;h5&gt;......&lt;/h5&gt;
	&lt;ol&gt;
		&lt;li&gt;......&lt;/li&gt;
		&lt;li&gt;......&lt;/li&gt;
	&lt;/ol&gt;
&lt;/div&gt;
&lt;/body&gt;
</code></pre>
<p>对这一小段 HTML 来说，如果 <code>&lt;p&gt;</code> 元素上产生了 Reflow，那么 <code>&lt;strong&gt;</code> 将会受到影响（因为它属于前者的后代元素），当然也跑不了 <code>&lt;div&gt;</code> 和 <code>&lt;body&gt;</code> （祖先元素），<code>&lt;h5&gt;</code> 和 <code>&lt;ol&gt;</code> 则躺枪：没事跟在别人后面干啥呢。</p>
<p>因此，大多数的 Reflow，其实都导致了整个页面重新渲染。这对于计算能力稍低的设备（如手机）来说是非常困难的。我经常发现桌面计算机上运行良好的动画效果到了手机上就看起来很痛苦。</p>
<h3 id="reflow">Reflow 的触发点 <a class="header-anchor" href="#reflow" aria-hidden="true">&#128279;</a></h3>
<ul>
<li>Window resizing</li>
<li>改变字体</li>
<li>增删样式表</li>
<li>内容改变，比如用户在输入框中输入</li>
<li>触发 CSS 伪类，比如 <code>:hover</code>  等</li>
<li>更改 class 属性</li>
<li>脚本操作 DOM</li>
<li>计算 <code>offsetWidth</code> 与 <code>offsetHeight</code></li>
<li>更改 style 属性</li>
<li>……</li>
</ul>
<h3 id="-2">如何优化 <a class="header-anchor" href="#-2" aria-hidden="true">&#128279;</a></h3>
<p>恩。。。看了这么多发现，要完全避免 Reflow 还是比较困难的。那么我们至少可以有一些办法去减少它们的影响吧。</p>
<p>以下的方法都是收集于一些国外作者的博客。</p>
<h4 id="dom-class">尽量选择 DOM 树底层的元素去修改 Class <a class="header-anchor" href="#dom-class" aria-hidden="true">&#128279;</a></h4>
<p>比如说，不要选择类似 Wrapper 这样的元素去修改 Class，而尽量找更加底层的元素。因为 Reflow 会影响所有后代祖先以及后邻，这么干可以尽量地减少 Reflow 的影响，从而提高 CSS 渲染性能。</p>
<h4 id="-3">避免设置多个内联样式 <a class="header-anchor" href="#-3" aria-hidden="true">&#128279;</a></h4>
<p>这里的意思其实是说不要使用 JS 来给元素按部就班地设置样式 —— 因为每一次样式变化都会引起一次 Reflow，最好把样式整合为一个 Class 然后一次性加到元素上面去。</p>
<p>还有另外一种解决办法是在设置样式前先将其脱离正常文档流，比如 <code>display</code> 属性设为 <code>none</code>，然后所有设置都完成后再变回来。这样也是可以接受的。</p>
<h4 id="position-fixed-absolute">如果要使用动画尽量选择 Position 为 Fixed 或 Absolute 的元素 <a class="header-anchor" href="#position-fixed-absolute" aria-hidden="true">&#128279;</a></h4>
<p>动画的每一帧都会引起 Repaint 或者 Reflow，最好是可以让它脱离正常文档流，这样就绝对不会引起大规模持续的 Reflow</p>
<h4 id="table">不要选用 Table 布局 <a class="header-anchor" href="#table" aria-hidden="true">&#128279;</a></h4>
<p>虽然我们已经有很多理由不去使用 table 布局了，但这又是另外一个 —— 任意一个单元格的小改动都很有可能触发整个布局所有节点的变化，带来巨大的性能开销。</p>
<p> </p>
]]></description><pubDate>Wed Mar 30 2016 14:16:25 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/efficient-css-and-reflow-repaint</link><guid isPermaLink="true">https://blog.wxsm.space/p/efficient-css-and-reflow-repaint</guid></item><item><title>BFC 原理及应用</title><description><![CDATA[<h2 id="bfc">什么是 BFC <a class="header-anchor" href="#bfc" aria-hidden="true">&#128279;</a></h2>
<p>BFC（Block formatting context）是 CSS 中的一个概念，先来看一下定义 （By MDN）：</p>
<blockquote>
<p>A <strong>block formatting context</strong> is a part of a visual CSS rendering of a Web page. It is the region in which the layout of block boxes occurs and in which floats interact with each other.</p>
</blockquote>
<p>大意就是，BFC 是 Web 页面通过 CSS 渲染的一个块级（Block-level）区域，具有独立性。</p>
<p>BFC 对浮动元素的定位与清除都很重要：</p>
<ul>
<li>浮动元素的定位与清除规则只适用于同一 BFC 中的元素</li>
<li>不同 BFC 中的浮动元素不会相互影响</li>
<li>浮动元素的清除只适用于同一 BFC 中的元素</li>
</ul>
<!--more-->
<h2 id="bfc-2">如何生成 BFC <a class="header-anchor" href="#bfc-2" aria-hidden="true">&#128279;</a></h2>
<p>一个元素要成为 BFC，必须具备以下特征之一：</p>
<ul>
<li>根元素，或者包含根元素的元素</li>
<li>浮动元素（<code>float</code> 属性不为<code>none</code>）</li>
<li>绝对定位元素（<code>position</code> 属性为 <code>absolute</code> 或 <code>fixed</code>）</li>
<li>行内块级元素（<code>display</code> 属性为 <code>inline-block</code>）</li>
<li>表格单元格或者标题（<code>display</code> 属性为 <code>table-cell</code> 或 <code>table-caption</code>）</li>
<li>元素的 <code>overflow</code> 属性不为 <code>visible</code></li>
<li>Flex 元素（<code>display</code> 属性为 <code>flex</code> 或 <code>inline-flex</code>）</li>
</ul>
<h2 id="bfc-3">BFC 的应用 <a class="header-anchor" href="#bfc-3" aria-hidden="true">&#128279;</a></h2>
<h3 id="">自适应双栏布局 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h3>
<p>之前一直困扰我的一个问题是，如何使用 CSS 实现一个双栏布局，其中一栏宽度固定，另一栏则自动根据父节点剩余宽度填满容器呢？</p>
<p>因为 CSS 2.x 是不支持计算的，所以不使用 <code>calc</code> 的话，还真的好像没什么办法的样子。</p>
<p>然而，通过使用 BFC 却可以很容易地达到效果。</p>
<p>先来看一个没有 BFC 的例子：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;BFC Example&lt;/title&gt;
    &lt;style&gt;
        .aside {
            width: 100px;
            height: 150px;
            float: left;
            background: #f66;
        }

        .main {
            height: 200px;
            background: #fcc;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;aside&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;main&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>效果：</p>
<p><img src="https://raw.githubusercontent.com/wxsms/wxsms-img-holder/master/20160328171800.jpg" alt=""></p>
<p>在这种情况下，二者共享了同一个 BFC，即 <code>body</code> 根元素，因此，右边元素的定位受到了浮动的影响。</p>
<p>我们给 <code>.main</code> 添加一个属性，让它成为独立的 BFC：</p>
<pre><code>.main {
    overflow: hidden;
}
</code></pre>
<p>效果：</p>
<p><img src="https://raw.githubusercontent.com/wxsms/wxsms-img-holder/master/20160328172031.jpg" alt=""></p>
<p>这就是一个自适应两栏布局了。主栏的宽度是随父节点而自动变化的。</p>
<h3 id="-2">清除内部浮动 <a class="header-anchor" href="#-2" aria-hidden="true">&#128279;</a></h3>
<p>写 CSS 代码的时候经常会遇到一个问题：如果一个元素内部全部是由浮动元素组成的话，那么它经常会没有高度，即“不能被撑开”。</p>
<p>我们可以通过在所有浮动元素的最后清除浮动来解决问题，但通过 BFC 的方式其实更简单。</p>
<p>只需要通过任意方式将浮动元素的容器转换为 BFC（比如添加 <code>overflow: hidden</code> 属性），即使不清除浮动，其依然能被正常“撑开”。</p>
<p>就像这样：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;BFC Example&lt;/title&gt;
    &lt;style&gt;
        body {
            width: 660px;
        }

        .parent {
            background: #fcc;
            overflow: hidden;
        }

        .child {
            border: 5px solid #f66;
            width: 200px;
            height: 200px;
            float: left;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;parent&quot;&gt;
    &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>效果：</p>
<p><img src="https://raw.githubusercontent.com/wxsms/wxsms-img-holder/master/20160328173455.jpg" alt=""></p>
<h3 id="margin">清除 margin 重叠 <a class="header-anchor" href="#margin" aria-hidden="true">&#128279;</a></h3>
<p>场景：我们连续定义两个 <code>div</code>，并且都给予 <code>margin: 100px</code> 属性，实际上它们之间的距离也将是 100px 而非 200px，因为 margin 重叠了。</p>
<p>如果不想让 margin 出现这种重叠的情况，依然可以使用 BFC：给二者都各自套上一个 BFC 容器（或者其中之一），因为 BFC 的独立性，内部布局不会产生对外影响，外部也不会产生对内影响，所以二者的 margin 属性都能生效，最终就能得到 200px 的间距。</p>
<p>这个就不举实际例子了。</p>
]]></description><pubDate>Mon Mar 28 2016 17:43:35 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/bfc-theory-and-applications</link><guid isPermaLink="true">https://blog.wxsm.space/p/bfc-theory-and-applications</guid></item><item><title>“渐进增强”与“优雅降级”</title><description><![CDATA[<p>“渐进增强”与“优雅降级”是 Web 页面两种不同的开发理念，为了简单起见，先给出定义（By W3C）：</p>
<blockquote>
<p>Graceful degradation Providing an alternative version of your functionality or making the user aware of shortcomings of a product as a safety measure to ensure that the product is usable. Progressive enhancement Starting with a baseline of usable functionality, then increasing the richness of the user experience step by step by testing for support for enhancements before applying them.</p>
</blockquote>
<p>翻译：“优雅降级”的目的是为你的功能模块提供一种替代方案，或者让用户意识到某种产品（浏览器）的缺陷来保证你的产品的可用性。“渐进增强”是在一个最基本的可用功能之上，通过在拓展功能前检测（浏览器的）支持性逐步地提升用户体验。</p>
<p>这两种方案看起来好像没有什么太大区别，并且最终的结果貌似也是一样的。但是看完后面更多的解释和示例，就会更明白一些，其实这里面是真的有区别的。</p>
<p>一些博文将其简单地归结为如下内容：</p>
<pre><code>.transition {   /*渐进增强写法*/
  -webkit-transition: all .5s;
     -moz-transition: all .5s;
       -o-transition: all .5s;
          transition: all .5s;  
} 
.transition {   /*优雅降级写法*/ 
          transition: all .5s;
       -o-transition: all .5s;
     -moz-transition: all .5s;
  -webkit-transition: all .5s;
}
</code></pre>
<p>这个解释是<strong>完全错误的</strong>。实际上任何情况下我们都应该使用前者的 CSS 写法。</p>
<!--more-->
<h2 id="">在不断变化的环境中开发 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h2>
<p>稍微接触过 Web 开发的同学都能发现，我们目前所面对的最大难题不是如何实现强大的功能，而是如何保证即使是不那么强大的功能也能够被所有（退一步说，大多数）用户正常地使用。</p>
<blockquote>
<p>The web was invented and defined to be used with any display device, in any language, anywhere you want. The only thing expected of end users is that they are using a browsing device that can reach out to the web and understand the protocols used to transmit information — http, https, ftp and so on.</p>
</blockquote>
<p>正是因为可以访问 Web 的设备、语言、环境等因素太多太复杂，在极大促进 Web 发展的同时，也导致了以上困境。我们开发者无法对用户所使用的设备有任何期待。因此，我们无法保证 Web 应用上的所有功能都能够正确运行。</p>
<p>我们需要在未知中寻找出路，这就是“渐进增强”与“优雅降级”出现的原因。</p>
<h2 id="-2">二者概览 <a class="header-anchor" href="#-2" aria-hidden="true">&#128279;</a></h2>
<p>上面有对二者有一个简单的定义，这里再作一些扩展。</p>
<p><strong>优雅降级：</strong></p>
<p>首先确保使用现代浏览器的用户能够获得最好的用户体验，然后为使用老旧浏览器的用户优雅降级。降级的结果可能会导致功能不再那么美好，但是，只要能够为用户保留住访问网站的最后一点价值就算是达到了目的。让他们至少能看到正常的页面。</p>
<p><strong>渐进增强：</strong></p>
<p>相似，但又不一样。首先为所有浏览器都提供一个能够正常渲染并工作的版本，然后为更高级的浏览器构建高级功能。</p>
<p>换句话说，“优雅降级”是从复杂的现状开始，尝试去修复一些问题；而“渐进增强”则从最基础入手，为更好的环境提供扩展。“渐进增强”可以让你的基础更加牢固，并且始终保持向前看的姿态。</p>
<h2 id="-3">一个例子 <a class="header-anchor" href="#-3" aria-hidden="true">&#128279;</a></h2>
<p>光说真的很难理解，我们来看个例子。（By W3C）</p>
<p><strong>“打印此页”链接</strong></p>
<p>有时候我们会想让用户可以点击一个链接或按钮以打印整个页面，于是拍脑袋就有了如下代码：</p>
<pre><code>&lt;p id=&quot;printthis&quot;&gt;
  &lt;a href=&quot;javascript:window.print()&quot;&gt;Print this page&lt;/a&gt;
&lt;/p&gt;
</code></pre>
<p>这段语句在启用 JavaScript 并且支持 <code>print</code> 方法的浏览器中非常完美。然而，悲催的是，万一浏览器禁用了 JavaScript，或者根本就不支持，那么点击它就完全没有任何反应了。这就造成了一个问题，作为站点开发者，你写出这个链接就相当于向用户保证了这项功能，然而并没有，用户会感到困惑、被欺骗，并且责怪你提供了如此差的用户体验。</p>
<p>为了减轻问题的严重程度，开发者通常会使用<strong>优雅降级</strong>的策略：</p>
<p>告诉用户这个链接可能会不起作用，或者提供替代方案。一般来说我们会使用 <code>noscript</code> 元素来达到目的，就像这样：</p>
<pre><code>&lt;p id=&quot;printthis&quot;&gt;
  &lt;a href=&quot;javascript:window.print()&quot;&gt;Print this page&lt;/a&gt;
&lt;/p&gt;
&lt;noscript&gt;
  &lt;p class=&quot;scriptwarning&quot;&gt;
    Printing the page requires JavaScript to be enabled. 
    Please turn it on in your browser.
  &lt;/p&gt;
&lt;/noscript&gt;
</code></pre>
<p>这就是优雅降级的一种体现 —— 我们告诉用户发生了错误并且如何去修复。但是，这有一个前提，用户必须是：</p>
<ul>
<li>知道什么是 JavaScript</li>
<li>知道怎么启用它</li>
<li>有权限去启用它</li>
<li>愿意去启用它</li>
</ul>
<p>下面这种方式可能会更好些：</p>
<pre><code>&lt;p id=&quot;printthis&quot;&gt;
  &lt;a href=&quot;javascript:window.print()&quot;&gt;Print this page&lt;/a&gt;
&lt;/p&gt;
&lt;noscript&gt;
  &lt;p class=&quot;scriptwarning&quot;&gt;
    Print a copy of your confirmation. 
    Select the &quot;Print&quot; icon in your browser,
    or select &quot;Print&quot; from the &quot;File&quot; menu.
  &lt;/p&gt;
&lt;/noscript&gt;
</code></pre>
<p>这样上面所说的问题就都解决了。然而它的前提是所有浏览器都提供了“打印”功能。并且，事实依然没有任何改变：我们提供了一些可能完全没用的功能，并且需要做出解释。实际上这个“打印此页”链接完全就是没有必要存在的。</p>
<p>如果我们换一种方式，使用“<strong>渐进增强</strong>”法，则步骤如下。</p>
<p>首先我们考虑是否有一种方式可以不用写脚本实现打印功能，事实上并没有，因此我们从一开始就不应该选择“链接”这种 HTML 元素来使用。如果一项功能依赖 JavaScript 来实现，那就应该用 button</p>
<p>第二步，告诉用户去打印这个页面，就这么简单：</p>
<pre><code>&lt;p id=&quot;printthis&quot;&gt;Thank you for your order. Please print this page for your records.&lt;/p&gt;
</code></pre>
<p>注意，这无论在什么情况下都一定是适用的。接下来，我们使用“循序渐进”的 JavaScript 来给支持此功能的浏览器添加一个打印按钮：</p>
<pre><code>&lt;p id=&quot;printthis&quot;&gt;Thank you for your order. Please print this page for your records.&lt;/p&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
(function(){
  if(document.getElementById){
    var pt = document.getElementById('printthis');
    if(pt &amp;&amp; typeof window.print === 'function'){
      var but = document.createElement('input');
      but.setAttribute('type','button');
      but.setAttribute('value','Print this now');
      but.onclick = function(){
        window.print();
      };
      pt.appendChild(but);
    }
  }
})();
&lt;/script&gt;
</code></pre>
<p>注意到何为“循序渐进”了吗：</p>
<ul>
<li>使用自执行匿名函数包装法，不留下任何影响</li>
<li>测试 DOM 方法的支持性，并且尝试获取节点</li>
<li>测试节点是否存在，<code>window</code> 对象以及 <code>print</code> 方法是否存在</li>
<li>如果全都没问题，我们就创建这个功能按钮</li>
<li>把按钮添加到需要的位置上去</li>
</ul>
<p>我们永远不给用户提供不能工作的 UI —— 只在它真正能工作时才显示出来。</p>
<h2 id="-4">适用场景 <a class="header-anchor" href="#-4" aria-hidden="true">&#128279;</a></h2>
<p><strong>优雅降级</strong>适用场景：</p>
<ul>
<li>当你在改进一个旧项目但时间有限的时候</li>
<li>当你没有足够的时间使用渐进增强法去完成项目的时候</li>
<li>当你要做的产品比较特别，比如说对性能要求特别高的时候</li>
<li>当你的项目必须要有一些基础功能的时候（地图，邮箱等）</li>
</ul>
<p>其余的所有情况下，<strong>渐进增强</strong>都能让用户与你都更开心：</p>
<ul>
<li>不管环境如何，你的产品都能工作</li>
<li>当新技术或浏览器发布的时候，你只需在原有基础上扩展功能，而无需修改最基础的解决方案</li>
<li>技术可以更“用得其所”，而不仅仅是为了实现功能</li>
<li>维护方便</li>
</ul>
<h2 id="-5">总结 <a class="header-anchor" href="#-5" aria-hidden="true">&#128279;</a></h2>
<p>“渐进增强”与“优雅降级”最终都是为了实现一个目标：让所有用户都能够使用我们的产品。“渐进增强”方案看起来更优雅，但它需要更多的时间与资源去达成。“优雅降级”可以看成是现有产品的补丁：易于开发但难以维护。</p>
<p>注：本文大部分内容来自 <a href="https://www.w3.org/wiki/Graceful_degradation_versus_progressive_enhancement" target="_blank">W3C</a></p>
]]></description><pubDate>Fri Mar 25 2016 09:35:10 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/graceful-degradation-versus-progressive-enhancement</link><guid isPermaLink="true">https://blog.wxsm.space/p/graceful-degradation-versus-progressive-enhancement</guid></item><item><title>Baidu Submit for WordPress update 0.1.0</title><description><![CDATA[<p>这次更新主要是把工具做成了 WordPress 插件的形式，安装和使用起来都更符合 WordPress 的风格了，也不用再通过改代码去更改配置参数。之所以一次性把版本号提到了 0.1.0，是因为我觉得它虽然功能还不是非常完善，但是已经达到了“至少能用”的程度。</p>
<p>工具的主要功能目前为止并没有什么变化，至于这个过程中获得的少许 WordPress 插件开发经验下次再总结，好在没走多少弯路。</p>
<p>使用方式：Clone <a href="https://github.com/edisond/baidu-submit-for-wordpress" target="_blank">https://github.com/edisond/baidu-submit-for-wordpress</a> 仓库并上传至主机的</p>
<pre><code>/wp-content/plugins
</code></pre>
<p>目录，在 WordPress 插件控制面板中设置启用即可。准入密钥以及域名的配置页面可以在“设置”中找到，其中也包含了手动推送的页面。</p>
]]></description><pubDate>Mon Mar 21 2016 13:38:04 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/baidu-submit-for-wordpress-update-0-1-0</link><guid isPermaLink="true">https://blog.wxsm.space/p/baidu-submit-for-wordpress-update-0-1-0</guid></item><item><title>过期鸡汤</title><description><![CDATA[<p>花了两个晚上读了最近挺火的一本书，名曰《解忧杂货店》，同时也是我看过的第一本日本小说。看完以后只有一个感觉：这大概是过期的鸡汤吧。一点味道都没有。与此同时，总觉得有些什么地方不对。现在认真想了想，果然是奇葩。由于不清楚日本文化，也不知道该说是日本人奇葩，还是说仅仅是故事或者作者奇葩。</p>
<!--more-->
<p>这本书大概讲述了这么一件事：</p>
<p>三名无业青年爆了一个老板娘的格，跑路途中车抛锚了无奈躲进一个荒废的屋子里，后发现有信投入，内容是吐槽烦恼。回信后立马又收到了回信，终此往复。由于咨询者不知手机为何物，因此闹洞大开认为这屋子大概是个时空机器BlaBlaBla，迷途的少年感觉找到了人生的价值，摇身一变成为烦恼终结者。接下来就是各种各样奇葩的往事，各种咨询，然后通过一个孤儿院把大家都联系在了一起，最后回到现实少年发现刚爆的可怜老板娘就是最后一个与自己通信的人。少年们随即决定重新做人，义无反顾地开始捡肥皂生涯。</p>
<p>故事的核心是“一间能够连接时空的杂货店”，因此它本身是一个和时空有关的故事。这种故事太多太多了，现在读起来已经不是特别有趣，同时也非常容易出BUG，然而我想吐槽的东西不在这里。简单地说，故事里的主角们，基本都是重度自私+自恋狂。当然这里要除去杂货店主那爷俩，他俩没有任何特别之处，普通人。以下的吐槽也不是针对他俩。</p>
<p>什么意思呢，大概就是脑子里想的永远都只有自己，无论别人发生什么事，只要一切按照自己的意愿来就行。什么爱人，什么父母，都不在考虑范围内。有些故事的角色看起来是在非常无私地处处替别人考虑，比如运动员的男友，比如富二代的老爸，然而这却是更可怕的自私。他们都有如下特点：完全不考虑别人的感受，完全不给人选择的余地，然后依然是一切按照自己的意愿来就行。</p>
<p>看这本书的时候就觉得，那些人做那么多事情，完全都不需要理由的啊，或者自己觉得这么做有理就一条路走到黑做下去了，根本就不管对身边的人有什么影响，反正老子喜欢就要干。此外，也看不出角色们有什么心理活动，感觉大家都只有一根筋。</p>
<p>难道这就是日本人的特征吗？</p>
<p>除此以外，基本上所有故事都是主流鸡汤文，以挫折、烦恼和梦想为主题。最后大家通过自己的努力（辅以杂货店的建议），都达到了自己所有或者部分的目标，或者干脆啥都没做成，但最后还是觉得自己得到了升华，甚至干脆整个人升华。整本书没有任何起伏跌宕，所有故事就那么以第三人称视觉丝毫不带感情地展开了。所以说它无味。</p>
<p>作者说，希望读者在合卷的时候能够喃喃自语曰“从来没有读过这样的小说”。我想说的倒是，从来没有读过这么无聊的鸡汤。赵国的鸡汤起码能给人打鸡血，你国连鸡血都打不了。</p>
<p> </p>
]]></description><pubDate>Wed Mar 02 2016 14:02:12 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/tasteless-chicken-soup</link><guid isPermaLink="true">https://blog.wxsm.space/p/tasteless-chicken-soup</guid></item><item><title>WordPress 百度主动提交工具</title><description><![CDATA[<p>作为目前的国内搜索主流，百度的收录规则与国外搜索引擎如谷歌、必应等不太一样，虽然它也有提供普通的Sitemap模式，但是据它自己所言通过这种方式收录效率是最低的。另外还有一种是自动推送，即在网站所有页面都加入一个JS脚本，有人访问时就会自动向百度推送该链接，但实测经常会被浏览器的AD Block插件阻拦。因此还剩下效率最高的一种方式：主动推送。我试过了一些现成的插件，好像都不太好用。因为是一个简单的功能，所以就自己写了一个小工具来实现。</p>
<!--more-->
<h2 id="">主动推送规则 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h2>
<p>通过调用百度的一个接口，并给它传送要提交的链接，即完成了主动推送的过程，根据接口返回的信息可以判断提交的结果如何（成功/部分成功/失败）。</p>
<p>核心代码如下（由百度提供）：</p>
<pre><code>$urls = array(
    'http://www.example.com/1.html',
    'http://www.example.com/2.html',
);
$api = 'http://data.zz.baidu.com/urls?site=xxx&amp;token=xxx';
$ch = curl_init();
$options =  array(
    CURLOPT_URL =&gt; $api,
    CURLOPT_POST =&gt; true,
    CURLOPT_RETURNTRANSFER =&gt; true,
    CURLOPT_POSTFIELDS =&gt; implode(&quot;\n&quot;, $urls),
    CURLOPT_HTTPHEADER =&gt; array('Content-Type: text/plain'),
);
curl_setopt_array($ch, $options);
$result = curl_exec($ch);
echo $result;
</code></pre>
<p><code>$urls</code> 就是我们需要推送的 url 数组了，除此之外还有两个需要修改的地方，都在第5行。一是自己站点的域名，二是准入密钥。密钥会由百度站长工具提供。域名则有一点需要注意，必须填写在百度站长平台注册的域名，比如注册的时候是带有 www 的，则这里也必须带 www，否则会返回域名不一致的错误。</p>
<p>API返回的 <code>$result</code> 是一个 JSON 对象，若推送成功可能包含以下字段：</p>
<div class="table-responsive">
  <table class="table table-hover">
    <tr>
      <th>
        字段
      </th>
<pre><code>  &lt;th&gt;
    是否必选
  &lt;/th&gt;
  
  &lt;th&gt;
    参数类型
  &lt;/th&gt;
  
  &lt;th&gt;
    说明
  &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt;
  &lt;td&gt;
    success
  &lt;/td&gt;
  
  &lt;td&gt;
    是
  &lt;/td&gt;
  
  &lt;td&gt;
    int
  &lt;/td&gt;
  
  &lt;td&gt;
    成功推送的url条数
  &lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
  &lt;td&gt;
    remain
  &lt;/td&gt;
  
  &lt;td&gt;
    是
  &lt;/td&gt;
  
  &lt;td&gt;
    int
  &lt;/td&gt;
  
  &lt;td&gt;
    当天剩余的可推送url条数
  &lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
  &lt;td&gt;
    not_same_site
  &lt;/td&gt;
  
  &lt;td&gt;
    否
  &lt;/td&gt;
  
  &lt;td&gt;
    array
  &lt;/td&gt;
  
  &lt;td&gt;
    由于不是本站url而未处理的url列表
  &lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
  &lt;td&gt;
    not_valid
  &lt;/td&gt;
  
  &lt;td&gt;
    否
  &lt;/td&gt;
  
  &lt;td&gt;
    array
  &lt;/td&gt;
  
  &lt;td&gt;
    不合法的url列表
  &lt;/td&gt;
&lt;/tr&gt;
</code></pre>
  </table>
</div>
<p>示例：</p>
<pre><code>{
    &quot;remain&quot;:4999998,
    &quot;success&quot;:2,
    &quot;not_same_site&quot;:[],
    &quot;not_valid&quot;:[]
}
</code></pre>
<p>推送失败可能返回的字段：</p>
<div class="table-responsive">
  <table class="table table-hover">
    <tr>
      <th>
        字段
      </th>
<pre><code>  &lt;th&gt;
    是否必选
  &lt;/th&gt;
  
  &lt;th&gt;
    参数类型
  &lt;/th&gt;
  
  &lt;th&gt;
    说明
  &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt;
  &lt;td&gt;
    error
  &lt;/td&gt;
  
  &lt;td&gt;
    是
  &lt;/td&gt;
  
  &lt;td&gt;
    int
  &lt;/td&gt;
  
  &lt;td&gt;
    错误码，与状态码相同
  &lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
  &lt;td&gt;
    message
  &lt;/td&gt;
  
  &lt;td&gt;
    是
  &lt;/td&gt;
  
  &lt;td&gt;
    string
  &lt;/td&gt;
  
  &lt;td&gt;
    错误描述
  &lt;/td&gt;
&lt;/tr&gt;
</code></pre>
  </table>
</div>
<p>示例：</p>
<pre><code>{
    &quot;error&quot;:401,
    &quot;message&quot;:&quot;token is not valid&quot;
}
</code></pre>
<p>实测小站点一天只能推500条链接，超过了就会报错。不过目前来说是绝对够用了。</p>
<h2 id="-2">实现逻辑 <a class="header-anchor" href="#-2" aria-hidden="true">&#128279;</a></h2>
<p>关于这个工具，我能想到的比较合理的使用逻辑是这样的：</p>
<ul>
<li>建站已有一段时间，但是从来没用过百度主动推送，需要能够选择以往的链接并推送之</li>
<li>旧的链接都已推送过，需要在有新页面发布时自动将其推送</li>
</ul>
<p>需要推送的页面包括但不限于：</p>
<ul>
<li>首页</li>
<li>文章（Post）</li>
<li>页面（Page）</li>
<li>目录</li>
<li>标签</li>
</ul>
<p>由于是第一版，目前这个工具的逻辑就是这样的：</p>
<ol>
<li>首先获取到Wordpress站点下所有的正常页面（已发布，无密码）</li>
<li>让用户选择哪些页面需要被推送</li>
<li>用户点击按钮，请求经由AJAX发回后台</li>
<li>后台调用百度接口，实行推送</li>
<li>返回并显示结果</li>
</ol>
<p>实际的效果就像这样（<del>点此参观</del> 2016-03-10更新：由于已更换为插件模式，原页面失效）：</p>
<p><img src="https://raw.githubusercontent.com/wxsms/wxsms-img-holder/master/20160229092810.jpg" alt=""></p>
<p>这个工具目前还很简陋。当然，如果你没有登录或者已登陆但没有管理员权限的话，点击Submit是会被拒绝的。</p>
<h2 id="-3">未来的目标 <a class="header-anchor" href="#-3" aria-hidden="true">&#128279;</a></h2>
<p>虽然是一个简单的东西，但我觉得它可以变得更好：</p>
<ol>
<li>用户应该可以填写自定义的链接</li>
<li>它应该记住哪些链接已经被提交过了，这个状态应该显示在页面上，并且不再自动勾选</li>
<li>自动触发推送的功能尚未实现，这个也是很重要的</li>
<li>表格可以以一种更好的形式展现</li>
<li>Log可以写得更友好一些</li>
<li>做成插件</li>
<li>……</li>
</ol>
<p>如无意外，这些都将在之后的版本更新。</p>
<p>Github: <a href="https://github.com/edisond/baidu-submit-for-wordpress">https://github.com/edisond/baidu-submit-for-wordpress</a></p>
]]></description><pubDate>Mon Feb 29 2016 09:41:20 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/baidu-submit-for-wordpress</link><guid isPermaLink="true">https://blog.wxsm.space/p/baidu-submit-for-wordpress</guid></item><item><title>西游记之孙悟空三打白骨精</title><description><![CDATA[<p>有剧透。</p>
<p>2016年看的第一场电影，昨天，三打白骨精。有点晚了。春节档唯一感兴趣的就是它。</p>
<p>美人鱼看了预告片和简介，结合各种评分短评影评，我觉得它远远没有达到期望。个人认为评分7分上下，对于其它电影或许是“值得一看”，对于周星驰的电影来说，只能相当于“不是垃圾”。这是在砸招牌。更不用说很多人的高分只是给的这块招牌。</p>
<p>说回到三打白骨精（以下简称三打）。虽然它评分不高，虽然我看过的国产电影不多，虽然它题材滥上加滥，但我还是要说，这是我看过的<b>最好的最值的最不坑的</b>国产爆米花电影，比去年的口碑高峰寻龙诀还要好上不少。国产电影能有这么大的进步，作为一个普通电影爱好者我是觉得很高兴。</p>
<p>为什么说三打要比寻龙诀好呢。其实它的特效没有比寻龙诀高，尤其是3D这一方面，但是，三打把电影的使命捡了回来，就是<b>讲故事</b>。寻龙诀根本就没有在讲故事，看的过程中就感觉各种特效乱飞，火花四溅，然后就结束了。然而三打不一样，它做到了<b>特效为故事服务</b>。虽然一路走过来依然很酷炫，但是作为观众我能感受到重要的角色都有它背后的故事，以及正在发生的故事。能感受到角色的立体度。实实在在的角色，而不是只活在大银幕这个平面之上。</p>
<p>三打对原故事进行了不少的改编，以往的国产电影很多改编都是坑爹，但是我认为这些改编却偏偏很多都是<b>恰到好处</b>的。为什么呢。因为改编后的电影可以让观众更加关注于主要的故事其本身，另外节省说故事的时间。就比如说，我们都知道师傅是如何收的二师兄以及沙师弟，但是电影就将其极简化了，他俩简单粗暴地一起搭上了大师兄的顺风车。这么做虽然当时看的时候觉得有点怪，但是事后想想是非常妙的。观众不需要导演去告诉他们师傅在白骨精之前是怎么走过来的，90%的观众都知道这背后到底是怎么回事，观众看的电影叫三打白骨精，直入主题。这样的改编在电影中还有不少，我认为都是为了简化故事结构突出主线而生。</p>
<p>但是，有几处改编，却又是在“三打白骨精”这个原著故事上做出了扩展。这也是很有意思的一点。<b>电影把无关紧要的剧情都尽量简要交代，然后竭尽所能地拓展主线。</b>原著故事没有吃人血的国君，没有白骨精的前世今生，也没有佛祖亲自收它，白骨精之于大师兄更是蝼蚁之于巨象。但是，电影偏偏在这么一个简单的故事上脱离了纯爆米花的低级趣味：要探讨人性，要探讨佛性，要挖掘黑暗面。其实我觉得如果要更有意思一点的话，其它可以有，白骨精还是不要那么强的好，就保持原著的水平，千年修行，最后被大师兄一棍子打死，然后师父再舍生取义，再打死师傅，更探讨，更黑暗。不过这么搞特效就没法做了。</p>
<p>此外，看了那么多的西游电影电视剧，貌似也只有三打在真正地学习老版西游记的精华。不是说它的“二师兄，师傅被妖怪抓走了”之类的吐槽以及片尾曲，而是说只有这只猴子以及老版西游记的猴子是在演猴子。看得出郭天王努力地在向六小龄童大师学习，各种动作都是以猴为基准，而不是人，虽然水平是差了一个筋斗云，但是最起码有认真地去学。要是不说他是郭富城我估计真没多少人能猜得出来，说得夸张些，他的影子里只有猴。<b>如果说老版西游记的猴子是精华，那么师傅就是糟粕。三打不但吸取了精华，还扔掉了糟粕。</b>这里面的师傅，虽然在大圣和妖怪面前看起来依然是手无缚鸡之力，但是，重要的一点，这是一个有主见，有信仰，有觉悟的师傅，是不辱其名的圣僧（吐槽一下电影的圣僧之翻译：Holy monk，上帝的和尚）。多说无益，看过便知。</p>
<p>要说缺陷的话，自然还是不少，不然不会只有5+的评分。二师兄和沙师弟是打了整场的酱油，就俩高级步兵，除了会吐槽以外屁用没有。认真想想的话其实有他俩没他俩剧情根本一模一样，即使最后大师兄回家了也不是二师兄给讨回来的。电影的审美过于西化了，比如小白龙的形象，比如白骨精的形象。但是，瑕不掩瑜，还是要说，这是我看过的<b>最好的最值的最不坑的</b>国产爆米花电影。</p>
]]></description><pubDate>Mon Feb 22 2016 15:19:09 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/review-of-the-monkey-king-2</link><guid isPermaLink="true">https://blog.wxsm.space/p/review-of-the-monkey-king-2</guid></item><item><title>WordPress 在阿里云虚拟主机下无法发送邮件</title><description><![CDATA[<p>安装在阿里云虚拟主机环境下的Wordpress死活都发不出邮件，用户注册的邮件发不出，评论总结也发不出，等等等等，尝试了各种方法都以失败告终。今天用更改代码+SMTP插件终于试成功了，以下是解决方案。</p>
<!--more-->
<h2 id="">更改主机设置 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h2>
<p>首先阿里云虚拟主机发邮件相关的函数只开放了一个，即 <code>fsockopen</code>，默认情况下还是禁用的，所以我们要去控制台打开它（主机管理 ⇒ 站点信息 ⇒ 高级环境设置 ⇒ PHP.ini设置）。如图所示。</p>
<p><img src="https://raw.githubusercontent.com/wxsms/wxsms-img-holder/master/20160222105330.jpg" alt=""></p>
<h2 id="wordpress">更改Wordpress代码 <a class="header-anchor" href="#wordpress" aria-hidden="true">&#128279;</a></h2>
<p>找到代码安装路径下的 <code>wp-includes/class-smtp.php</code> 文件，搜索以下代码段：</p>
<pre><code>$this-&gt;smtp_conn = @stream_socket_client(
    $host . &quot;:&quot; . $port,
    $errno,
    $errstr,
    $timeout,
    STREAM_CLIENT_CONNECT,
    $socket_context
);
</code></pre>
<p>将其<strong>替换</strong>成：</p>
<pre><code>$this-&gt;smtp_conn = fsockopen($host, $port, $errno, $errstr);
</code></pre>
<p><strong>注意</strong>：升级Wordpress可能会导致这段修改过的代码丢失，因此可能每次Wordpress主程序升级后都要再次修改此段代码！</p>
<h2 id="smtp">安装SMTP插件 <a class="header-anchor" href="#smtp" aria-hidden="true">&#128279;</a></h2>
<p>改完代码以后，到Wordpress控制台搜索插件<strong>Easy WP SMTP</strong>（其它类似插件应该也行，这里以它为例），安装并启用。如图所示配置好。</p>
<p><img src="https://raw.githubusercontent.com/wxsms/wxsms-img-holder/master/20160222110446.jpg" alt=""></p>
<p>配置好后点击Save，保存成功后下方会有一个测试发送的表单。可以用它来测试SMTP是否已经可以正确工作。</p>
<p>如果测试邮件已经可以正常发送接收，则说明Wordpress的其它邮件也都可以正常收发了。</p>
<p>另外，本人测试过使用QQ和126的SMPT服务器，均以失败告终，原因未知。</p>
<h2 id="-2">问题待解决 <a class="header-anchor" href="#-2" aria-hidden="true">&#128279;</a></h2>
<p>现在Wordpress主程序是可以正常发邮件了，但是<strong>BackWPup</strong>插件的邮件依然是完全发不出去，使用它提供的所有方式都不行，使用同样的SMTP配置也是不行，它也没有提供什么有用的错误信息，完全摸不着头脑。</p>
<p>为什么需要这个插件发邮件呢。因为它是网站的备份主力，但是因为邮件发不出去的关系，不能通过邮件发送备份，只能备份到主机的文件夹下。这样就很没安全感了，要完蛋都是一锅端的感觉，有无备份没什么区别。它提供的其它方案也好像都被墙了，比如Dropbox什么的。</p>
<p>这个问题待解决。</p>
]]></description><pubDate>Mon Feb 22 2016 11:16:24 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/wordpress-unable-to-send-email-under-aliyun-virtual-host</link><guid isPermaLink="true">https://blog.wxsm.space/p/wordpress-unable-to-send-email-under-aliyun-virtual-host</guid></item><item><title>WordPress 博客搭建</title><description><![CDATA[<p>本文是本站的建站历程记录。每个人都可以使用极少的代价（甚至免费）拥有一个域名独立且完全自主的个人网站或博客，在于怎么选择而已。此类网站的搭建很多情况下并不要求其操作者是一个程序狗，所以个人感觉可玩性还是挺强的。整个过程一共需要准备三种事物：<strong>域名</strong>，<strong>托管</strong>与<strong>程序</strong>（特殊情况，如果选择国内主机则需要准备第四种，即<strong>备案</strong>）。</p>
<!--more-->
<h2 id="">域名 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h2>
<p>搭建一个网站首先必不可少的就是自己的域名，比如本站的域名是<a href="http://wxsm.space">wxsm.space</a>，域名可以在任意服务商处购买，不需要与托管的服务商一致。根据域名后缀的不同，价格在几十元至百元每年之间不等，大多数服务商都会提供首年优惠，少部分首年的价格甚至可以达到个位数（比如万网的 <code>.top</code> 域名购买首年只需4软妹币）。</p>
<p>域名的选择没什么技术含量，主要就是自己喜欢。本站的域名是在<a href="http://wanwang.aliyun.com/">万网</a>购买。域名购买以后可以解析到托管的IP地址。</p>
<p>需要注意的地方：</p>
<ol>
<li>如果打算购买国内（特指大陆）主机，就一定要确定自己购买的域名后缀是可以备案的类型。具体可以在工信部网站（公共查询 ⇒ 域名类型）查询，能查到的则是可备案后缀。切记切记。</li>
<li>为自己的安全着想，最好不要使用 <code>.cn</code> 类型的域名。</li>
</ol>
<h2 id="-2">托管 <a class="header-anchor" href="#-2" aria-hidden="true">&#128279;</a></h2>
<p>托管有很多种选择，首先从大的方向说，尽量选择靠谱的供应商。淘宝小商家之类的虽然便宜，但是很多时候我们需要的更多是稳定，毕竟是把代码和数据都放在别人家，还是很要命的一件事。当然如果免费的话又另当别论。至于配置就纯看个人需求了。如果是玩玩个人小网站，一般选最低的那些都没问题。</p>
<h3 id="-3">国内/香港/国外 <a class="header-anchor" href="#-3" aria-hidden="true">&#128279;</a></h3>
<p>国内主机理论上来说从国内访问速度最快，其最大的特点是需要备案，其二是会被GFW限制，主机上的程序将会无法访问到Google等公司提供的服务。</p>
<p>香港主机速度可媲美国内主机，是主攻国内但是又不想备案的不二之选。</p>
<p>国外主机在国内的访问速度可能会非常之慢，尤其是欧美地区，稍快一些的可以选择新加坡。其特点是很多都相对国内以及香港主机较为便宜，以及有部分免费（比如AppHarbor，免费空间，免费SQL Server，无限流量，同步Github仓库，自动部署，简直不要太良心，<a href="http://xn--eprj140hbm6afon.Net">可惜只能跑.Net</a>）。</p>
<p>本站目前使用的是万网提供的国内主机。</p>
<h3 id="vps">虚机/VPS/其它 <a class="header-anchor" href="#vps" aria-hidden="true">&#128279;</a></h3>
<p>虚机即虚拟主机。该类型主机一般都是共享系统资源，如CPU，内存，带宽，IP等。虚机好像只有ASP.Net和PHP两种类型（反正我是没见过其它的），并且所有功能都是由外部配置好的，用户只能使用服务商所提供的功能，超出范围则无能为力，因此它的限制会比较大。操作方式就是通过FTP访问其储存空间，然后将写好的程序上传，马上就能在浏览器看到结果，不需要考虑部署、环境等。如果使用CMS（如Wordpress）的话，这种主机已经足够用了。</p>
<p>VPS相当于一台属于自己的计算机，用户可以通过各种方式登录并且对它操作，安装环境，部署网站等。Java，Node.js等类型的程序好像只能跑在VPS上。因为没有用过所以不太了解。其价格要普遍比虚机贵一些。</p>
<p>还有一些是类似Github Pages的静态服务器，它们只能够作为静态网页的托管。这些可能会很便宜，但是需要一定的技巧才能玩出花样来。</p>
<p>本站目前使用的是万网提供的虚机，免费版。每个人都可以申请，使用期限为两年。运行Wordpress完全没有问题。传送门：<a href="http://wanwang.aliyun.com/hosting/free/">http://wanwang.aliyun.com/hosting/free/</a></p>
<h2 id="-4">程序 <a class="header-anchor" href="#-4" aria-hidden="true">&#128279;</a></h2>
<p>有了域名和托管，我们需要的最后一件事物就是程序。程序才是真正运行着的东西。</p>
<p>程序可以自己写，也可以用开源软件。自己写的好处就是完全控制，以及比较有意思，但如果更多的是想要做内容的话还是用开源软件比较好，这样就可以更好地关注于网站的内容本身而不是实现。</p>
<p>本站使用的是开源Wordpress CMS，我们要做的事情很简单，在中文官网<a href="https://cn.wordpress.org/">https://cn.wordpress.org/</a>首页把Wordpress程序下载回来，解压，然后将文件夹上传到服务器根目录，通过访问其任意页面来配置站点的基本信息，如名字，描述，数据库连接等，就可以非常方便地搭建好整个网站。数据库表等其它事物都会由程序自动生成。关于这个软件的安装和使用方法网络上有非常多的详细教程，遇到问题多用搜索就好啦。</p>
<p>WordPress的主题和插件简直数不过来，我觉得满足98%个人网站用户的需求完全是没问题的。加之它有强大的缓存插件，可以自动将所有的动态页面都缓存成HTML然后301之，所以访问性能也不在话下。当然如果想要实现某些特别的自定义功能的话，还是要懂一点点编程技巧才行。</p>
<h2 id="-5">备案 <a class="header-anchor" href="#-5" aria-hidden="true">&#128279;</a></h2>
<p>如果使用的是国内的托管，则需要进行最麻烦的一步：备案。</p>
<p>备案一般是由代理商完成，不需要我们自己直接与工信部沟通。</p>
<p>整个流程有两个地方稍微麻烦，一是初审填表，需要下载、打印、填表、扫描、上传这么多的步骤。其次是“当面核验”，其实就是拍个照上传，但是需要它专用的背景幕布，可以到指定的拍照地点免费拍摄，或者代理商以免费或者到付的形式快递幕布给申请人，然后自行拍照上传。</p>
<p>管局审核需要的时间从从两个小时到三十天不等，主要看运气。反正我是这个时间段内的都遇到过（广东）。</p>
<p>备案通过以后，需要把备案号以链接的形式加到网站的底部，然后就可以该干嘛干嘛了。</p>
]]></description><pubDate>Mon Feb 22 2016 09:12:03 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/how-to-build-a-wordpress-blog</link><guid isPermaLink="true">https://blog.wxsm.space/p/how-to-build-a-wordpress-blog</guid></item><item><title>IDEA 滚动条问题</title><description><![CDATA[<p>用IDEA撸代码的时候有一个非常恶心的问题，它的滚动条经常会无缘无故地跳动，最常见的就是拖动滚动条之后它会马上跳回到原本的位置，纵向和横向都有此问题，因此基本上每次都至少要拖两次滚动条才能成功，烦不胜烦。升级版本等等都没有用。今天终于找到了真正的解决方法，就是<strong>关闭屏幕取词软件或禁用软件的取词功能（比如有道）</strong>。完全、彻底地解决此问题。</p>
]]></description><pubDate>Wed Feb 17 2016 14:43:31 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/idea-scrolling-issue</link><guid isPermaLink="true">https://blog.wxsm.space/p/idea-scrolling-issue</guid></item><item><title>JavaScript 的一些古怪之处</title><description><![CDATA[<p>大概一年前在看一本介绍JavaScript与jQuery的书籍之时看到了这么一个有趣的章节，当时印象挺深刻的。现在突然回想起来了这回事，于是就重新翻出来做了个笔记。作者将这些材料归结为两类：神奇的知识点以及WTF。这里去除了与浏览器有关的部分，因为那些和JavaScript本身并没有关联。</p>
<!--more-->
<h2 id="">数据类型与定义 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h2>
<h3 id="null">NULL是一个对象 <a class="header-anchor" href="#null" aria-hidden="true">&#128279;</a></h3>
<p>不同于C或者Java之类的语言，JavaScript的 <code>null</code> 值是一个对象。也许你会说“<code>null</code> 应该定义为一个完全没有意义的值”，也许你是对的，然并卵，事实是：</p>
<pre><code>alert(typeof null); //object
</code></pre>
<p>尽管如此，<code>null</code> 并不是任何对象的一个实例（补充：JavaScript中的所有“值”都是基本对象的实例，比如说数字是 <code>Number</code> 对象的实例，字符串是 <code>String</code> 对象的实例，所有对象都是 <code>Object</code> 对象的实例，等等）。于是我们可以理智地认为：如果 <code>null</code> 代表的是没有值，那么它就不能是任何对象的实例。因此下面的表达式应该返回 <code>false</code>：</p>
<pre><code>alert(null instanceof Object); //evaluates false
</code></pre>
<h3 id="nan">NAN是一个数字 <a class="header-anchor" href="#nan" aria-hidden="true">&#128279;</a></h3>
<p>你以为 <code>null</code> 是一个对象已经够离谱了吗，too young too simple！<code>NaN</code>→ Not a Number → 它是一个数字。还有更过分的呢，它甚至不等于它自身。我受到了伤害。</p>
<pre><code>alert(typeof NaN); //alerts 'Number'
alert(NaN === NaN); //evaluates false
</code></pre>
<p>事实上，<code>NaN</code> 不与任何值相等。如果想要判断一个值是不是 <code>NaN</code>，唯一的办法是通过调用 <code>isNaN()</code> 函数。</p>
<h3 id="false">空数组==FALSE <a class="header-anchor" href="#false" aria-hidden="true">&#128279;</a></h3>
<p>这个特性其实很受欢迎的呢：</p>
<pre><code>alert(new Array() == false); //evaluates true
</code></pre>
<p>要弄明白这里面到底发生了什么事，首先要知道在JavaScript世界中<strong>真假相</strong>的概念。它在逻辑上有一些简化。</p>
<p>作者认为最简单的理解方式是：在JavaScript的世界中，<strong>所有非布尔类型的值，它们都存在有一个内置的布尔类型标志位</strong>，当该非布尔值在要求做出布尔类型的比较时，实际上调用的是它的标志位。</p>
<p>（我觉得理解为JavaScript有内置的比较逻辑表也是可以的吧）</p>
<p>因为苹果没办法和梨比较，猫不能和狗比较，因此当JavaScript需要比较两种不同类型的数值时，它要做的第一件事必然是将其<strong>强转</strong>为通用的可比较的类型。<code>False</code>，<code>null</code>，<code>undefined</code>，<code>NaN</code>,空字符串以及零到最后全都会变成 <code>false</code>。不过这当然不是永久的，这种转换只在特定的表达式（布尔表达式）中生效。</p>
<pre><code>var someVar = 0;
alert(someVar == false); //evaluates true
</code></pre>
<p>以上就是一个<strong>强转</strong>的例子。</p>
<p>至此还没有开始讨论数组的行为呢。空数组是一件非常奇特的事物，它们实际上是表示真，但如果你拿它来做布尔运算，它又是假的。我总觉得这里面隐藏着什么不可告人的秘密 (¬_¬)</p>
<pre><code>var someVar = []; //empty array
alert(someVar == false); //evaluates true
if (someVar) alert('hello'); //alert runs, so someVar evaluates to true
</code></pre>
<p>为了避免类似的困扰，我们可以使用<strong>全等操作符</strong>（三个等号，同时比较类型与值）：</p>
<pre><code>var someVar = 0;
alert(someVar == false); //evaluates true – zero is a falsy
alert(someVar === false); //evaluates false – zero is a number, not a boolean
</code></pre>
<p>这个问题十分广泛，这里也就不过多介绍了。如果想要深入了解其内部原理，可以阅读<a href="http://www.mozilla.org/js/language/E262-3.pdf">ECMA-262标准之11.9.3章节</a>文档。</p>
<h2 id="-2">正则表达式 <a class="header-anchor" href="#-2" aria-hidden="true">&#128279;</a></h2>
<h3 id="replace">REPLACE()可以接受回调函数 <a class="header-anchor" href="#replace" aria-hidden="true">&#128279;</a></h3>
<p>这绝对是JavaScript最为隐秘的特性之一，从1.3版本之后加入。绝大多数人都是这么用它的：</p>
<pre><code>alert('10 13 21 48 52'.replace(/\d+/g, '*')); //replace all numbers with *
</code></pre>
<p>（原文中有一些疏忽，比如使用了 <code>d+</code> 而非 <code>\d+</code>，这里均做出了修正）</p>
<p>简单的替换，字符串，星号。但如果我们想要更进一步的控制呢？比如我们只想替换30以下的数字？这个逻辑通过正则来实现会较为困难，毕竟它不是数学运算，我们可以这样：</p>
<pre><code>alert('10 13 21 48 52'.replace(/\d+/g, function(match) {
	return parseInt(match) &lt; 30 ? '*' : match;
}));
</code></pre>
<p>这段代码的意思是，如果匹配到的字符串转换为整型数值后小于30，则替换为星号，否则原样返回。</p>
<h3 id="-3">不仅仅是比较和替换 <a class="header-anchor" href="#-3" aria-hidden="true">&#128279;</a></h3>
<p>通常情况下我们都只用到了正则表达式的比较和替换功能，但其实JavaScript提供的方法远远不止两个。</p>
<p>比如说 <code>test()</code> 函数，它和比较十分类似，但它不反回比较值，只确认字符串是否匹配。这样代码可以更轻一些。</p>
<pre><code>alert(/\w{3,}/.test('Hello')); //alerts 'true'
</code></pre>
<p>以上表达式判断了字符串是否有3个或以上的字符。</p>
<p>还有就是 <code>RegExp</code> 对象，通过它我们可以构建动态的正则表达式。一般情况下正则表达式都是通过短格式声明的（封闭在斜杠中，就像上面所用到的）。这么做的话，我们不能在其中插入变量。当然，我们还有 <code>RegExp</code>：</p>
<pre><code>function findWord(word, string) {
	var instancesOfWord = string.match(new RegExp('\\b'+word+'\\b', 'ig'));
	alert(instancesOfWord);
}
findWord('car', 'Carl went to buy a car but had forgotten his credit card.');
</code></pre>
<p>这里我们基于 <code>word</code> 参数构建了一个动态的正则表达式。这个函数会返回car作为独立单词在字符串中出现的次数。本例只有一次。</p>
<p>由于 <code>RegExp</code> 使用字符串来表示正则表达式，而非斜杠，因此我们可以在里面插入变量。但是，与此同时，需要注意的是，表达式中特殊符号前的反斜杠我们也要写两次（转义处理）。</p>
<h2 id="-4">函数与作用域 <a class="header-anchor" href="#-4" aria-hidden="true">&#128279;</a></h2>
<h3 id="-5">你可以伪造作用域 <a class="header-anchor" href="#-5" aria-hidden="true">&#128279;</a></h3>
<p>作用域决定了变量可以在哪些地方被访问。独立（即不在函数内部）的JavaScript可以在全局作用域（对浏览器来说是 <code>window</code> 对象）下访问，函数内部定义的变量则只能在内部访问，其对外部不可见。</p>
<pre><code>var animal = 'dog';
function getAnimal(adjective) { alert(adjective+' '+this.animal); }
getAnimal('lovely'); //alerts 'lovely dog';
</code></pre>
<p>这里，我们的变量和函数都是在全局作用域下定义的（比如 <code>window</code>）。因为 <code>this</code> 总是指向当前作用域，因此在本例中它指向了 <code>window.animal</code>，于是就找到了。一切看起来都没问题。但是，我们可以骗过函数本身，让它认为自己执行在另一个作用域下，并无视其原本的作用域。我们通过调用内置的 <code>call()</code> 函数来达到目的：</p>
<pre><code>var animal = 'dog';
function getAnimal(adjective) { alert(adjective+' '+this.animal); };
var myObj = {animal: 'camel'};
getAnimal.call(myObj, 'lovely'); //alerts 'lovely camel'
</code></pre>
<p>在这里，函数不在 <code>window</code> 而在 <code>myObj</code> 中运行 — 作 为 <code>call</code> 方法的第一个参 数。本质上说 <code>call</code> 方法将函数 <code>getAnimal</code> 看成 <code>myObj</code> 的一个方法（如果没看懂这是什么意思， 你可能需要去看一下 JavaScrip t的原型继承系统相关内容）。注意，我们传递给 <code>call</code> 的第一个参数后面的参数都会被传递给我们的函数 — 因此我们将 lovely 作为相关参数传递进来。尽管好的代码设计不需要采用这种伪造手段，这依然是非常有趣的知识。<code>apply</code> 函数与 <code>call</code> 函数作用相似，它的参数应该被指定为数组。所以，上面的例子如果用 <code>apply</code> 函数的话如下：</p>
<pre><code>getAnimal.apply(myObj, ['lovely']); //func args sent as array
</code></pre>
<h3 id="-6">函数可以自执行 <a class="header-anchor" href="#-6" aria-hidden="true">&#128279;</a></h3>
<p>显然：</p>
<pre><code>(function() { alert('hello'); })(); //alerts 'hello'
</code></pre>
<p>这个语法非常简单：我们定义了一个函数，然后立刻就调用了它，就像调用其它函数一样。也许你会觉得这有些奇怪，函数包含的代码一般都是在之后执行的，比如我们想在某个时刻调用它，既然它需要立即执行，那为什么要把代码放在函数体内呢？</p>
<p>自执行函数的一大用处就是将<strong>变量的当前值</strong>绑定到将来要被执行的函数中去。就比如说回调，延迟或者持续运行：</p>
<pre><code>var someVar = 'hello';
setTimeout(function() { alert(someVar); }, 1000);
var someVar = 'goodbye';
</code></pre>
<p>这段代码有一个问题，它的输出永远都是goodbye而不是hello，这是因为timeout中的函数在真正执行之前永远不会去关心里面的变量发生了什么变化，到那时候，<code>someVar</code> 早就被goodbye覆盖了。</p>
<p>（JavaScript新手经常会犯的一个错误就是在循环中定义事件，并且将index作为参数传入，到最后发现真正绑上了事件的只有最后的那个元素，这也是同理）</p>
<p>解决办法如下：</p>
<pre><code>var someVar = 'hello';
setTimeout((function(someVar) {
	return function()  { alert(someVar); }
})(someVar), 1000);
var someVar = 'goodbye';
</code></pre>
<p>在这里，被传入函数中的相当于是一个快照，而不是真正的变量本身。</p>
<h2 id="-7">其它 <a class="header-anchor" href="#-7" aria-hidden="true">&#128279;</a></h2>
<h3 id="01-02-03">0.1 + 0.2 !== 0.3 <a class="header-anchor" href="#01-02-03" aria-hidden="true">&#128279;</a></h3>
<p>其实这是计算机科学中的一个普遍问题，我已经在很多编程语言中都发现了它的影子，它是由浮点数不能做到完全精确导致的。实际的计算结果是0.30000000000000004</p>
<p>如何解决，归根到底取决于计算需求：</p>
<ul>
<li>转换成整型计算，而后再转回浮点</li>
<li>允许某个范围内的误差</li>
</ul>
<p>因此，与其：</p>
<pre><code>var num1 = 0.1, num2 = 0.2, shouldEqual = 0.3;
alert(num1 + num2 == shouldEqual); //false
</code></pre>
<p>不如：</p>
<pre><code>alert(num1 + num2 &gt; shouldEqual - 0.001 &amp;&amp; num1 + num2 &lt; shouldEqual + 0.001); //true
</code></pre>
<p>这就是一个简单的允许误差的办法。</p>
<h3 id="undefineddefined">UNDEFINED可以被DEFINED <a class="header-anchor" href="#undefineddefined" aria-hidden="true">&#128279;</a></h3>
<p>这个看起来有点蠢了。undefined在JavaScript中其实不是一个关键字，尽管它一般是用来表示一个变量是否未被定义。就像这样：</p>
<pre><code>var someVar;
alert(someVar == undefined); //evaluates true
</code></pre>
<p>然而也可以这样：</p>
<pre><code>undefined = &quot;I'm not undefined!&quot;;
var someVar;
alert(someVar == undefined); //evaluates false!
</code></pre>
<p>看起来很有趣的样子……</p>
]]></description><pubDate>Mon Feb 15 2016 16:47:27 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/some-oddities-about-javascript</link><guid isPermaLink="true">https://blog.wxsm.space/p/some-oddities-about-javascript</guid></item><item><title>CSS 绘制三角形</title><description><![CDATA[<p>关于如何使用CSS中的border属性绘制各式各样的三角形。下面有一个国外友人制作的动画，对其原理进行了直观的阐释，我简单地做了点翻译。</p>
<p class='codepen'  data-height='387' data-theme-id='0' data-slug-hash='zrbGpx' data-default-tab='result' data-animations='run' data-editable='' data-embed-version='2'>
  See the Pen <a href=’http://codepen.io/edisond/pen/zrbGpx/’>Animation to Explain CSS Triangles</a> by wxsm (<a href=’http://codepen.io/edisond’>@edisond</a>) on <a href=’http://codepen.io’>CodePen</a>.0
</p>
<p> </p>
<p>要点：</p>
<ul>
<li>元素不能有宽高（当然也可以稍作变化来绘制梯形）</li>
<li>只有一边border显示颜色，其宽度即为三角形的高</li>
<li>与其相邻的border设置为透明色，它们将决定三角形的形状</li>
</ul>
<!--more-->
<p>更多的例子：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;

&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;/&gt;
    &lt;title&gt;CSS Triangle&lt;/title&gt;
    &lt;style&gt;
        .arrow-up {
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-bottom: 5px solid black;
        }

        .arrow-down {
            width: 0;
            height: 0;
            border-left: 20px solid transparent;
            border-right: 20px solid transparent;
            border-top: 20px solid #f00;
        }

        .arrow-right {
            width: 0;
            height: 0;
            border-top: 60px solid transparent;
            border-bottom: 60px solid transparent;
            border-left: 60px solid green;
        }

        .arrow-left {
            width: 0;
            height: 0;
            border-top: 10px solid transparent;
            border-bottom: 10px solid transparent;
            border-right: 10px solid blue;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;arrow-up&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;arrow-down&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;arrow-left&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;arrow-right&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>效果：</p>
<p>以上的例子都是使用实体元素来绘制三角形，其实实际情况下使用伪元素的（before，after）会更多一些。</p>
]]></description><pubDate>Mon Feb 15 2016 10:58:33 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/css-triangle</link><guid isPermaLink="true">https://blog.wxsm.space/p/css-triangle</guid></item><item><title>无题</title><description><![CDATA[<p>年廿七回家，到今天是第七天。这么快就已经过去了整整一周，马上又要回珠海上班了。</p>
<p>回家这么多天来，今天是第一次在家吃晚饭。一直都在亲戚朋友家过节，自己家冷冷清清的时间比较多。因为自己家里没有老人，只有我和爸妈一家三口，所以大概只能往外跑吧。我们很少在广东过年，只是今年可能是因为我的身体还不太好，妈妈也比较累，所以就不想回江西了。其实过节在哪里都无所谓啦，大家在一起开心就好。倒是不能去看看年事已高的奶奶觉得很忧伤。妈妈看起来又老了一些，是照顾我的那段时间太劳累了。</p>
<p>今年印象比较深的是，大家都喜欢在茶余饭后玩红包了。尤其是除夕晚上的时候，开着电视，但其实没多少时间去看，大家都忙着摇摇摇咻咻咻，完事以后继续关注下一轮的时刻，至于春晚什么的，谁管呢。当然老人还是在看。腾讯老大给的一块几毛就图个乐（一块几毛是说微信，至于QQ真是太小气了），但这里要吐槽一下支付宝，我一直以为它要么会大量放出稀有卡，要么会给集齐四张卡的同学一些安慰奖，结果也是呵呵，于是我毫不犹豫地就把除了家人以外的加起来的好友都删了。这游戏在春晚打了那么硬的广告，结果让全国99%的玩家都吃了个闭门羹，这么有种也是没谁了。老人一直在问为什么会有奇怪的声音，他们在年夜饭的过程中反而不太受到关注。</p>
<p>老人们有时候会问什么时候结婚的事，我都是回答说还早。两个人在一起的压力有时候真要比一个人要大得多，毕竟一个人生活不用考虑什么时候能买房，反正都是自己住。珠海的房价一天比一天高，然而刚工作半年的我也只能看着它高。</p>
<p>和小伙伴们谈起工作的时候，发现自己果然是最闲的。突然感觉没有赚加班费的机会也是一件挺忧伤的事。手术的伤依然是还没有好，总是觉得有这个问题在生活中处处都受到了限制。过两天又要回到那个以断网为常态并且每晚跳三四次闸的地方去住，再次回家又不知道是什么时候。</p>
]]></description><pubDate>Sat Feb 13 2016 02:37:20 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/untitled-2</link><guid isPermaLink="true">https://blog.wxsm.space/p/untitled-2</guid></item><item><title>域名转移</title><description><![CDATA[<p>本博客自今日起域名变更为<a href="http://anubarak.com">anubarak.com</a>，原域名wxsm.top将于2016-05-19到期，wxsm.space将于2016-09-19到期。其实本人更偏向于使用wxsm.space，奈何该后缀无法备案。请各位存有友链的博主更改友链指向为<a href="http://anubarak.com">anubarak.com</a>，多谢。</p>
]]></description><pubDate>Sat Feb 06 2016 00:34:41 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/domain-transfer</link><guid isPermaLink="true">https://blog.wxsm.space/p/domain-transfer</guid></item><item><title>使用 IDEA 配置自动同步到FTP服务器</title><description><![CDATA[<p>使用虚拟主机的时候经常会想到一个问题，就是改了代码以后还要手动上传到服务器上，非常麻烦，且不利于保持本地开发代码与服务器上运行代码之间的同步，容易出错。今天突然想着能不能用IDE来完成类似自动同步的事情，如果可以的话开发效率自然是大幅度提高。拜强大到没朋友的IDEA所赐，结果非常可观。</p>
<p>首先确保安装好IDEA，测试用IDEA版本为15.0.1，然后我们从FTP服务器上copy一份代码到本地，并创建好存放目录。此时代码应该是完全同步的。以上为准备工作。</p>
<!--more-->
<p>然后我们打开IDEA，选择File -&gt; Open，打开代码根目录。</p>
<p>打开Tools -&gt; Deployment -&gt; Configuration</p>
<p><img src="https://raw.githubusercontent.com/wxsms/wxsms-img-holder/master/20160203160541.png" alt=""></p>
<p>在弹出的界面中点击 <code>+</code> 按钮，添加一个服务器。</p>
<p><img src="https://raw.githubusercontent.com/wxsms/wxsms-img-holder/master/20160203161409.png" alt=""></p>
<p>如下图所示，填写主机地址，端口（如果不一样），用户名与密码以后，就可以点 <code>Test FTP connection</code> 按钮进行连接测试，如果连接成功，IDEA会有相应的提示。以下的步骤需要以此为前提。</p>
<p>点击 <code>Autodetect</code> 按钮后，选择服务器的根目录，一般选择最顶端的文件夹就OK了。即使代码并不是在根目录，我们也还有后面的配置来选择代码所处的实际目录。</p>
<p>最下面的 <code>Web server root URL</code> 字段可以填写网站的实际访问地址，这样在使用IDEA的实时预览功能时，浏览器就会以该Domain为基准进行路由。</p>
<p><img src="https://raw.githubusercontent.com/wxsms/wxsms-img-holder/master/20160203161627.png" alt=""></p>
<p>切换到 <code>Mappings</code> 标签，我们需要填写的字段也如下图。</p>
<p><code>Local path</code> 即本地代码根目录，IDEA已经自动设置好了。</p>
<p><code>Deployment path</code>则是FTP服务器上实际同步的位置，在此选择代码所处的文件夹即可。以上都填好后点击 <code>OK</code> 按钮。</p>
<p><img src="https://raw.githubusercontent.com/wxsms/wxsms-img-holder/master/20160203162340.png" alt=""></p>
<p>现在就大功告成了。我们可以选中一些文件或者文件夹，右键，然后就可以看到 Deployment 菜单，其子菜单有 Upload，Download，Compare，Sync四个。其中 Sync 就是我们所期望的功能，IDEA 会帮我们完成文件比较，与 VCS 的文件比较系统非常相似，确认无误后点击绿色的向右箭头按钮，代码就同步到服务器上去了。如下所示。</p>
<p><img src="https://raw.githubusercontent.com/wxsms/wxsms-img-holder/master/20160203163356.png" alt=""></p>
<p>当然每次都要右键然后找到 Sync 选项可能会有点太麻烦。我们可以把这个功能放到主工具栏上去，以后每次点它就行了。</p>
<p><img src="https://raw.githubusercontent.com/wxsms/wxsms-img-holder/master/20160203164053.png" alt=""></p>
<p>接下来就可以享受愉快的开发体验了。唯一需要注意的是在网络不是非常理想的情况下，Sync 的时候不要选择项目根目录，选择真正有改变的文件或者文件夹即可，因为它毕竟不是 VCS，所有文件一个个比对的话实在是太慢。当然我们也可以配合 VCS 使用，效果更佳，这里就不再赘述。</p>
]]></description><pubDate>Wed Feb 03 2016 16:45:27 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/using-idea-to-config-ftp-auto-deployment</link><guid isPermaLink="true">https://blog.wxsm.space/p/using-idea-to-config-ftp-auto-deployment</guid></item><item><title>WordPress 文章归档页面实现</title><description><![CDATA[<p>归档页就是一个包含站点所有已发布文章的列表页面，通常默认会根据发布时间来进行排序，然后可能会有一些分页排序页内搜索等功能。实现这个功能可以用Wordpress插件，当然也可以自己写代码，我一开始就是用了一款插件，觉得实现了功能还不错就没管它。后来想要做一些自定义的修改，比如插件是按月份分组然而我想改成年份，就稍微看了看它的代码。一看不得了，莫名地有一种总算见识到了什么叫又烂又臭的代码的感觉涌上心头，做了这么多年伸手党总算是被恶心到了，简直不能忍，于是琢磨着自己写一个简单的模板页，不用它了。</p>
<!--more-->
<h2 id="">吐槽区 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h2>
<p>首先来说说为什么这个插件的代码<strong>又烂又臭</strong>，在后面我再对它进行针对性的改进。哦对了它的名字叫<strong>Clean Archives Reloaded</strong>，作者叫<strong>Viper007Bond</strong>，来自美国俄勒冈州，没错就是点名批评，看来鬼佬的编码水平也不是普遍的高啊，这坨屎简直是开源界的耻辱。去到各搜索引擎搜索“Wordpress归档”关键字还有很多文章推荐使用该插件，看来大家都不太关心代码质量，只要能用就行。 该插件的主要设计思路如下：</p>
<ol>
<li>从WP数据库中抓取文章</li>
<li>根据用户配置分组并排序</li>
<li>组织并输出HTML到页面相关位置</li>
</ol>
<p>OK，就这么三步，实际上我们也只需要这么点东西。暂且不讨论步骤是否可以简化，我们先来看看它有着怎样的内心世界。</p>
<pre><code>// A direct query is used instead of get_posts() for memory reasons
$rawposts = $wpdb-&gt;get_results( &quot;SELECT ID, post_date, post_date_gmt, comment_status, comment_count FROM $wpdb-&gt;posts WHERE post_status = 'publish' AND post_type = 'post' AND post_password = ''&quot; );

</code></pre>
<p>这个是它的唯一一条SQL语句，可以看到作者为了给我们节省内存真是殚精竭力，本着够用就行的精神，放弃使用Wordpress自带的API，直接使用查询语句从数据库中查询出来了非常有限的一些字段。值得称赞。 按照插件的思路，紧接着就是分组啦：</p>
<pre><code>// Loop through each post and sort it into a structured array
foreach( $rawposts as $post ) {
	$posts[ mysql2date( 'Y.m', $post-&gt;post_date ) ][] = $post;
}
$rawposts = null; // More memory cleanup
</code></pre>
<p>排序啦：</p>
<pre><code>( 'new' == $atts['monthorder'] ) ? krsort( $posts ) : ksort( $posts );

// Sort the posts within each month based on $atts
foreach( $posts as $key =&gt; $month ) {
    $sorter = array();
    foreach ( $month as $post )
        $sorter[] = $post-&gt;post_date_gmt;

    $sortorder = ( 'new' == $atts['postorder'] ) ? SORT_DESC : SORT_ASC;

    array_multisort( $sorter, $sortorder, $month );

    $posts[$key] = $month;
    unset($month);
}
</code></pre>
<p>分组的思路就是根据一篇文章的年以及月来将原本的一维数组重新组织到一个新的二维数组中去，以方便后面的循环。排序有点复杂，首先大局上它是能够根据配置按月份从新到旧或者反方向的排序，然后在每个月份里面也能够根据配置从新到旧或者反方向的排序，这个设定简直蛋疼，谁这么无聊正着排一遍在里面反着又排一遍，即折磨自己又折磨读者，不过存在即合理，这里也不说它。**我想吐槽的是，既然你都把SQL写出来了，你也知道至少要排一次序了，又何必费尽周章在查出来以后排呢，我们直接在SQL里面排不比这一大串代码优雅吗？不快速吗？不节省内存吗？此外，这个分组也是萌萌哒，我们就不能在SQL里面先把组给分好吗，非要写个循环来调用 **<code>mysql2date</code>，这样真的好吗？当然如果作者没有学过 <code>ORDER BY</code>，也不知道SQL都有各自的内置日期函数，这些也就算了。我们接着往下看。 接下来的步骤是组织HTML：</p>
<pre><code>// Generate the HTML
$html = '&lt;div class=&quot;car-container';
if ( 1 == $atts['usejs'] ) $html .= ' car-collapse';
$html .= '&quot;&gt;'. &quot;\n&quot;;

// 此处省略n行

$html .= &quot;&lt;/ul&gt;\n&lt;/div&gt;\n&quot;;
return $html;
</code></pre>
<p>看到这里我已经瞎了。。。尤其是高亮的那一行。。。省略的N行中充斥着的都是如此的代码。它还不止有 <code>. &quot;\n&quot;</code> 之流，在省略的内容中甚至连HTML的编码器缩进作者都保留得很好很好。WTF？？这TM都是些什么鬼？？作者的这些杠N和缩进是写给鬼看的吗？？？字符串拼凑各种内容这种事我自己不懂事的时候也干过不少也就不说了，但这作者这一种原汁原味的拼法真是我有屎以来见过的最特立独行的行为艺术。</p>
<p>让我们接着来看生成HTML之中的一部分核心代码。显然其中会有一些循环用来生成列表，并且在每个内层循环之前应该输出一个标题之类的东西用来指示以下的内容属于哪一年哪一个月。代码如下：</p>
<pre><code>$firstmonth = TRUE;
foreach( $posts as $yearmonth =&gt; $posts ) {
    list( $year, $month ) = explode( '.', $yearmonth );

    $firstpost = TRUE;
    foreach( $posts as $post ) {
        if ( TRUE == $firstpost ) {
            $html .= '	&lt;li&gt;&lt;span class=&quot;car-yearmonth&quot;&gt;' . sprintf( __('%1$s %2$d'), $wp_locale-&gt;get_month($month), $year );
            if ( '0' != $atts['postcount'] ) $html .= ' &lt;span title=&quot;' . __('Post Count', 'clean-archives-reloaded') . '&quot;&gt;(' . count($posts) . ')&lt;/span&gt;';
            $html .= &quot;&lt;/span&gt;\n		&lt;ul class='car-monthlisting'&gt;\n&quot;;
            $firstpost = FALSE;
        }

        $html .= '			&lt;li&gt;' .  mysql2date( 'd', $post-&gt;post_date ) . ': &lt;a href=&quot;' . get_permalink( $post-&gt;ID ) . '&quot;&gt;' . get_the_title( $post-&gt;ID ) . '&lt;/a&gt;';

        // Unless comments are closed and there are no comments, show the comment count
        if ( '0' != $atts['commentcount'] &amp;&amp; ( 0 != $post-&gt;comment_count || 'closed' != $post-&gt;comment_status ) )
            $html .= ' &lt;span title=&quot;' . __('Comment Count', 'clean-archives-reloaded') . '&quot;&gt;(' . $post-&gt;comment_count . ')&lt;/span&gt;';

        $html .= &quot;&lt;/li&gt;\n&quot;;
    }

    $html .= &quot;		&lt;/ul&gt;\n	&lt;/li&gt;\n&quot;;
}
</code></pre>
<p>第5-12行代码，第一眼看到的时候马上就能闻到一股弱者的气息。<strong>作者想要在循环开始之前先输出一个列表标题，所以想到了一个使用标志位的办法，但是我们明明可以直接在循环前面做这件事的，根本不需要这个萌萌哒标志位。</strong></p>
<p>还有第14行。作者明明一直在标榜自己是如何节省时间节省内存的，结果在这里却使用了内置函数 <code>get_the_title</code> 以及 <code>get_permalink</code>，后者很正常，因为 wordpress 的文章链接是可以改变的，不能直接写死，必须查，那前者这个函数是做什么的呢？很明显，根据一篇文章的 ID 来获取它的标题。要如何根据 ID 来获取标题呢，我们能用算法算出来吗？显然不能，这里面显然需要一次数据库查询，至少也是一次缓存查询，而且它这个函数写在循环里面，我的天，这里面是多少条 SQL，你直接在一开始把 Title 也给查出来不就万事大吉了吗。。。</p>
<p>插件的核心功能大概就到此为止，为了实现让用户可以点击收起与展开每个内层列表的功能，作者还添加了一些 JavaScript 代码，就不吐槽了吧，我已经好累了。</p>
<h2 id="-2">改进 <a class="header-anchor" href="#-2" aria-hidden="true">&#128279;</a></h2>
<p>赶紧把这插件删了，删个干净，然后我们来改代码。因为我并不需要配置什么什么的，也不需要什么JS，怎么个分组怎么个排序的需求很明确，所以直接 HARD CODE。原插件还有一个缓存查询出来的数据的功能，由于我已经用了更强大的缓存，直接将动态页面缓存成纯 HTML，所以也不需要。以上内容通通砍掉，核心代码就很简单了。 首先是 SQL 查询：</p>
<pre><code>global $wpdb;
$rawposts = $wpdb-&gt;get_results(&quot;SELECT ID, year(post_date) as post_year, post_date, post_date_gmt, post_title FROM $wpdb-&gt;posts WHERE post_status = 'publish' AND post_type = 'post' AND post_password = '' order by post_date_gmt desc&quot;);
</code></pre>
<p>这里按照发布时间降序排序，为什么要用GMT时间而不直接用本地时间呢，我猜可能是为了防止我在这边发了一篇文章然后马上飞到美国又发一篇，可能会乱套吧，反正这么写更严谨，虽然不太可能发生。然后除了多选择一个post_title字段以外，还使用MySQL的一个内置函数选择了这篇文章发布时的年度，这样就不用在分组的时候使用N多遍 <code>mysql2date</code> 函数了。节省了大量步骤。 然后是分组：</p>
<pre><code>foreach ($rawposts as $post) {
    $posts[$post-&gt;post_year][] = $post;
}
$rawposts = null;
</code></pre>
<p>然后是HTML部分：</p>
<pre><code>$html = '&lt;div class=&quot;archives-container&quot;&gt;&lt;ul class=&quot;archives-list&quot;&gt;';
foreach ($posts as $year =&gt; $posts_yearly) {
    $html .= '&lt;li&gt;&lt;div class=&quot;archives-year&quot;&gt;' . $year . '年&lt;/div&gt;&lt;ul class=&quot;archives-sublist&quot;&gt;';
    foreach ($posts_yearly as $post) {
        $html .= '&lt;li&gt;';
        $html .= '&lt;time datetime=&quot;' . $post-&gt;post_date . '&quot;&gt;' . mysql2date('m月d日 D', $post-&gt;post_date, true) . '&lt;/time&gt;';
        $html .= '&lt;a href=&quot;' . get_permalink($post-&gt;ID) . '&quot;&gt;' . $post-&gt;post_title . '&lt;/a&gt;';
        $html .= &quot;&lt;/li&gt;&quot;;
    }
    $html .= &quot;&lt;/ul&gt;&lt;/li&gt;&quot;;
}
$html .= &quot;&lt;/ul&gt;&lt;/div&gt;&quot;;
return $html;
</code></pre>
<p>两个字：简洁。</p>
<h2 id="-3">使用方法 <a class="header-anchor" href="#-3" aria-hidden="true">&#128279;</a></h2>
<p>我们复制一份主题目录下的 <code>page.php</code> 文件，然后重命名为 <code>template-archives.php</code>，主要是给它加上以上的代码并且调用之。 对于我正在使用的主题来说，文件内容如下：</p>
<pre><code>&lt;?php
/*
Template Name: archives
*/


function _PostList($atts = array())
{
    global $wpdb;
    $rawposts = $wpdb-&gt;get_results(&quot;SELECT ID, year(post_date) as post_year, post_date, post_title FROM $wpdb-&gt;posts WHERE post_status = 'publish' AND post_type = 'post' AND post_password = '' order by post_date desc&quot;);
    foreach ($rawposts as $post) {
        $posts[$post-&gt;post_year][] = $post;
    }
    $rawposts = null;
    $html = '&lt;div class=&quot;archives-container&quot;&gt;&lt;ul class=&quot;archives-list&quot;&gt;';
    foreach ($posts as $year =&gt; $posts_yearly) {
        $html .= '&lt;li&gt;&lt;div class=&quot;archives-year&quot;&gt;' . $year . '年&lt;/div&gt;&lt;ul class=&quot;archives-sublist&quot;&gt;';
        foreach ($posts_yearly as $post) {
            $html .= '&lt;li&gt;';
            $html .= '&lt;time datetime=&quot;' . $post-&gt;post_date . '&quot;&gt;' . mysql2date('m月d日 D', $post-&gt;post_date, true) . '&lt;/time&gt;';
            $html .= '&lt;a href=&quot;' . get_permalink($post-&gt;ID) . '&quot;&gt;' . $post-&gt;post_title . '&lt;/a&gt;';
            $html .= &quot;&lt;/li&gt;&quot;;
        }
        $html .= &quot;&lt;/ul&gt;&lt;/li&gt;&quot;;
    }
    $html .= &quot;&lt;/ul&gt;&lt;/div&gt;&quot;;
    return $html;
}

function _PostCount()
{
    $num_posts = wp_count_posts('post');
    return number_format_i18n($num_posts-&gt;publish);
}

get_header(); ?&gt;

    &lt;div id=&quot;primary&quot; class=&quot;content-area&quot;&gt;
        &lt;main id=&quot;main&quot; class=&quot;site-main&quot; role=&quot;main&quot;&gt;

            &lt;article &lt;?php post_class(); ?&gt;&gt;
                &lt;header class=&quot;entry-header&quot;&gt;
                    &lt;h1 class=&quot;entry-title&quot;&gt;&lt;?php the_title(); ?&gt;&lt;/h1&gt;
                &lt;/header&gt;
                &lt;!-- .entry-header --&gt;

                &lt;div class=&quot;entry-content&quot;&gt;
                    &lt;?php
                    echo _PostList();
                    ?&gt;
                &lt;/div&gt;
                &lt;!-- .entry-content --&gt;
            &lt;/article&gt;
            &lt;!-- #post-## --&gt;


        &lt;/main&gt;
        &lt;!-- #main --&gt;
    &lt;/div&gt;
    &lt;!-- #primary --&gt;

&lt;?php get_sidebar(); ?&gt;
&lt;?php get_footer(); ?&gt;
</code></pre>
<p>然后我们把它上传到主机的主题目录下，来到wordpress管理控制台新建一个page，模板选择 <code>archives</code>，什么也不用输入（可以加个标题），保存，就可以看到效果了。当然这里没有涉及到CSS样式，可以在主题的 <code>style.css</code> 中自定义，也可以直接写在 <code>template-archives.php</code> 内，爱写哪写哪。本站使用的CSS如下所示：</p>
<pre><code>.archives-year {
    color: #777;
    border-bottom: 1px solid #e8e8e8;
    margin: 40px 0 10px 0;
    padding-bottom: 7px;
}

.archives-list {
    list-style: none;
    margin: 20px 0!important;
}

.archives-sublist {
    list-style: none;
    font-size: 90%;
    margin-left: 0 !important;
}

.archives-sublist li time {
    color: #777;
    width: 140px;
    min-width: 140px;
    max-width: 140px;
    display: table-cell;
    vertical-align: top;
}

.archives-sublist li a {
    display: table-cell;
    vertical-align: top;
}
</code></pre>
<p><a href="http://anubarak.com/archives/">点此查看实际效果</a> （可能因为网站更新而不符合）</p>
]]></description><pubDate>Tue Feb 02 2016 16:06:16 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/wordpress-archives-page-implementation</link><guid isPermaLink="true">https://blog.wxsm.space/p/wordpress-archives-page-implementation</guid></item><item><title>Angular Router 学习笔记</title><description><![CDATA[<p>使用Angular Router可以很方便地构建SPA应用，同时它支持深度链接，支持各种浏览器操作（前进、后退、收藏等），非常有趣。使用过类似模块就会觉得它要比传统的路由方式，比如服务端的Forward，Redirect以及一般的JavaScript Redirect等，好用得多。特别是用户体验这一块，上升了很大的档次。</p>
<p>就在不久前我还开发了一个使用iframe与jQuery的SPA项目，当时由于是老板提供的所有前端页面所以也没多想。现在学过了Angular Router真是有些不堪回首的感觉。</p>
<!--more-->
<h2 id="">传统路由方式 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h2>
<div class="table-responsive">
  <table class="table table-bordered table-hover">
    <tr>
      <td>
      </td>
<pre><code>  &lt;td&gt;
     &lt;strong&gt;Server Forward&lt;/strong&gt;
  &lt;/td&gt;
  
  &lt;td&gt;
     &lt;strong&gt;Server Redirect&lt;/strong&gt;
  &lt;/td&gt;
  
  &lt;td&gt;
     &lt;strong&gt;Client Redirect&lt;/strong&gt;
  &lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
  &lt;td&gt;
     &lt;strong&gt;Request(s) &lt;/strong&gt;
  &lt;/td&gt;
  
  &lt;td&gt;
     1
  &lt;/td&gt;
  
  &lt;td&gt;
     &lt;span style=&quot;color: #ff0000;&quot;&gt;2&lt;/span&gt;
  &lt;/td&gt;
  
  &lt;td&gt;
     1
  &lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
  &lt;td&gt;
     &lt;strong&gt;Browser URL Change&lt;/strong&gt;
  &lt;/td&gt;
  
  &lt;td&gt;
     &lt;span style=&quot;color: #ff0000;&quot;&gt;NO&lt;/span&gt;
  &lt;/td&gt;
  
  &lt;td&gt;
     YES
  &lt;/td&gt;
  
  &lt;td&gt;
     YES
  &lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
  &lt;td&gt;
     &lt;strong&gt;Page Refresh &lt;/strong&gt;
  &lt;/td&gt;
  
  &lt;td&gt;
     YES
  &lt;/td&gt;
  
  &lt;td&gt;
     YES
  &lt;/td&gt;
  
  &lt;td&gt;
     YES
  &lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
  &lt;td&gt;
     &lt;strong&gt;Maintainable&lt;/strong&gt;
  &lt;/td&gt;
  
  &lt;td&gt;
     YES
  &lt;/td&gt;
  
  &lt;td&gt;
     YES
  &lt;/td&gt;
  
  &lt;td&gt;
     &lt;span style=&quot;color: #ff0000;&quot;&gt;NO&lt;/span&gt;
  &lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
  &lt;td&gt;
     &lt;strong&gt;Browser Actions&lt;/strong&gt;
  &lt;/td&gt;
  
  &lt;td&gt;
     &lt;span style=&quot;color: #ff0000;&quot;&gt;NO&lt;/span&gt;
  &lt;/td&gt;
  
  &lt;td&gt;
     YES
  &lt;/td&gt;
  
  &lt;td&gt;
     YES
  &lt;/td&gt;
&lt;/tr&gt;
</code></pre>
  </table>
</div>
<p>以上是一个简单的对比，从请求次数、显示URL是否变化、页面是否刷新、是否可维护、是否支持浏览器动作这5个方面进行，可以看到彼此都有一些遗憾。由于Server Forward以及Client Redirect的限制实在太大，很多情况下我们用到的都是Server Redirect，但是两次请求是硬伤。并且以上所有方式都需要强制刷新页面。Wordpress博客使用的就都是Redirect方式。</p>
<h2 id="-2">前端路由 <a class="header-anchor" href="#-2" aria-hidden="true">&#128279;</a></h2>
<p>Angular Router支持两种使用方式：</p>
<ul>
<li>#锚点</li>
<li>HTML5 API</li>
</ul>
<p>其实在我看来很多情况下第一种较为朴素的方式已经足够用了。以下是一个简单的Demo：</p>
<p>独立页面链接：<a href="http://blog.wxsm.space/others/examples/angular-router/" target="_blank">http://wxsm.space/others/examples/angular-router/</a></p>
<p>点击Edit/Delete/Add/Show几个链接，可以发现下面的内容发生了变化。同时地址栏的URL也相应地变了。也可以尝试前进、后退、收藏等操作（在独立页面进行）。 代码如下：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;

&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;/&gt;
    &lt;title&gt;$routeProvide example&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;div ng-app=&quot;pathApp&quot;&gt;

    Choose your option:
    &lt;br/&gt;
    &lt;br/&gt;
    &lt;a href=&quot;#/Book/Edit&quot;&gt;Edit&lt;/a&gt; |
    &lt;a href=&quot;#/Book/Delete&quot;&gt;Delete&lt;/a&gt; |
    &lt;a href=&quot;#/Book/Add&quot;&gt;Add&lt;/a&gt; |
    &lt;a href=&quot;#/Book/Show&quot;&gt;Show&lt;/a&gt;

    &lt;div ng-view&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.7/angular.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    angular.module('pathApp', [], function ($routeProvider, $locationProvider) {
        $routeProvider
                .when('/Book/Edit', {
                    template: '&lt;div&gt;Edit&lt;/div&gt;',
                })
                .when('/Book/Delete', {
                    template: '&lt;div&gt;Delete&lt;/div&gt;',
                })
                .when('/Book/Show', {
                    template: '&lt;div&gt;Show&lt;/div&gt;',
                })
                .when('/Book/Add', {
                    template: '&lt;div&gt;Add&lt;/div&gt;',
                })
                .otherwise({
                    redirectTo: '/Book'
                });
    });
&lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<p>这个Demo为了简便使用了直接的HTML字符串来作为一个页面的内容，我们在实际使用的时候可以把它换成一个实际页面的地址，这样在点击一个链接的时候Angular Router就会异步地加载相应的页面并且填充到相应的<code>ng-view</code>节点中去。整个过程无需全局刷新。由此带来的好处是非常多的。我们不需要重新加载和渲染一些固定的板块（比如通常情况下一个网站的Header和Footer部分都是不会发生变化的，当然如果需要变化Angular Router也能做到），同时也可以真正地给页面切换添加一些酷炫的动画（CSS或者JS）。并且由于加载一个新页面只需要从服务器读取它的HTML内容而不需要如JS/CSS等静态文件（这些都将会在页面第一次打开的时候加载完毕），因此速度将会非常快。</p>
<p>需要注意的是，这里使用的是比较旧的AngularJS版本。在新版本中，Angular Router从AngularJS的核心代码内分离了出来，成为了一个叫做ngRoute的独立模块。我们需要同时引入AngularJS和ngRoute模块来启用Angular Router路由器。</p>
<h2 id="routeproviderroute">关于$routeProvider与$route <a class="header-anchor" href="#routeproviderroute" aria-hidden="true">&#128279;</a></h2>
<p>这个路由功能是由Angular的一个服务提供者（service provider）实现的，它的名字就叫做<code>$routeProvider</code> 。Angular服务是由服务工厂创建出来的一系列单例对象，而工厂则是由服务提供者来创建。服务提供者必须实现一个<code>$get</code>方法，它就是该服务的工厂方法了。 当我们使用AngularJS的依赖注入给控制器注入一个服务对象的时候，Angular会使用<code>$injector</code>来查找相应的注入器。一旦找到了，它就会调用相应<code>$get</code>方法来或取服务对象的实例。有时候服务提供者在实例化服务对象之前需要其调用者提供一些参数。</p>
<p>Angular路由功能是由<code>$routeProvider</code>声明的，同时它也是<code>$route</code>服务的提供者。</p>
]]></description><pubDate>Mon Feb 01 2016 17:21:59 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/angular-router-note</link><guid isPermaLink="true">https://blog.wxsm.space/p/angular-router-note</guid></item><item><title>Bootstrap file input in Firefox</title><description><![CDATA[<p>默认的Bootstrap文件上传框在Chrome/Firefox/IE上的表现都不一样，如下所示。 代码：</p>
<pre><code>&lt;input class=&quot;form-control&quot; type=&quot;file&quot;&gt;
</code></pre>
<p>Chrome:</p>
<p><img src="https://raw.githubusercontent.com/wxsms/wxsms-img-holder/master/20160122090540.png" alt=""></p>
<p>Firefox:</p>
<p><img src="https://raw.githubusercontent.com/wxsms/wxsms-img-holder/master/20160122090635.png" alt=""></p>
<p>IE:</p>
<p><img src="https://raw.githubusercontent.com/wxsms/wxsms-img-holder/master/20160122090110.png" alt=""></p>
<p>先忽略掉文字表述的差异（由浏览器所使用语言引起），可以看到File input在Chrome和FF下的表现比较相似，IE则差距略大。但是至少Chrome和IE是可以正常显示其样式的，FF则出现了奇怪的样式问题，好像因为按钮太大而超出了输入框。 解决方法也很简单，最快捷的：</p>
<pre><code>.form-control {
    height: auto;
}
</code></pre>
<p>但是这个方法可能会影响到其它输入框组，可以稍作修改：</p>
<pre><code>.form-control[type=file] {
    height: auto;
}
</code></pre>
<p>这样CSS就会自动选择类型为file的输入框并且添加以上样式。虽然IE家族对CSS属性选择器的支持有限制（7/8）或者完全不支持（6），但是实际上并不影响。因为Bootstrap最低也只能支持到IE 9或IE 8（添加额外库），所以这个方法已经足够了。 修改后的Firefox（Chrome/IE无变化）：</p>
<p><img src="https://raw.githubusercontent.com/wxsms/wxsms-img-holder/master/20160122092621.png" alt=""></p>
]]></description><pubDate>Fri Jan 22 2016 09:20:46 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/bootstrap-file-input-in-firefox</link><guid isPermaLink="true">https://blog.wxsm.space/p/bootstrap-file-input-in-firefox</guid></item><item><title>2015年度总结</title><description><![CDATA[<p>2015对我来说是有喜有悲的一年。我还清楚地记得十一个月前刚过完年的时候，在上班的第一天迟到了，然后收到同事哥哥姐姐们的一桌子红包的情景，然而不知不觉就已经过去这么久了。最近生活和工作上都遇到了一点瓶颈，中午无聊的时候翻看了一下这一年下来的邮件，于是就想写点东西。</p>
<!--more-->
<h3 id="">实习 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h3>
<p>2014年11月的时候我找到了大学以来的第一份正经工作（实习），岗位是前端开发，一做就是近九个月。这九个月中我从一个什么都不懂的应届生成长为了一个对社会生活有初步了解的普通人。至今当时的Leader还在拿我的语录打趣，她问我说觉得公司怎么样，答曰：“我觉得挺正规的”。可见我是有多不会说话。虽然现在也没有变得很能说，但是在大家的帮助和教导下（感激不尽），至少是有一些进步了。</p>
<p>实习阶段工作内容非常简单，只需要根据哥哥姐姐们提出的需求去完成一系列相应的任务即可。通常都是一些编写或者维护Web页面以及通用控件的任务。作为一个实习生，很多情况下我都不用对所做的东西负很多的责任，质量有大师傅们把关着呢，就算一时间做得不好也不会被责怪，师傅们会尽心尽力地进行指导。所以现在回想起来，这真是一段无忧无虑的时光。工作上没有太多的压力，不用接触业务，根据详细的需求去实现不会太难的东西，同时也有着大量学习与实践的时间。</p>
<blockquote>
<p>Hi Kairui, Jessie,</p>
<p>Welcome to join UCD as intern.</p>
</blockquote>
<p>这是我在公司收到的第一封邮件，来自当时的Leader，这其中还有一个故事。一开始我并没有给公司投递简历，而是女朋友投了，并且收到了面试通知，于是我就抱着看看的心态，跟着一起去了。后来觉得“这间公司好像还挺正规”，于是也就提出了希望试一试的请求。好在HR比较宽容，给了我一次机会，也让我做了笔试与面试。几天后就有了上面的结果，我们都被录取了。但是女朋友她同时也面试了另一间公司的实习岗，也通过了，她权衡利弊以后觉得那个地方要更适合自己，所以最后我们只好各自入职。为这件事我郁闷了好一段时间。</p>
<h3 id="-2">毕设 <a class="header-anchor" href="#-2" aria-hidden="true">&#128279;</a></h3>
<p>因为全职实习的缘故，大学最后的半年时间我基本上都没有在学校度过，很久很久都没有听到过上课的钟声，也懒得跟任课老师请假。一开始还能够从学校宿舍早出晚归，后来直接就住在公司旁边了，每周回那么一两次学校。因此，我只想选一个最简单的，最不动脑的毕设，能过就行，实在是没有很多时间能投入进去。学校的毕设选题网站同样也是一个毕设，没有做完善的安全防卫，因此为了达到以上目的我还不择手段地写了一段浏览器脚本来抢题，大概就是每隔多少毫秒就给服务器发送“我要选这道题”的消息。后来比较后悔的事情是我没有及时地把这个主意分享给室友（因为是在开放选题前一两个小时的时间里想到的，而且我也不确定是不是真的能用），不然我们就都可以选到自己喜欢的题目了，而不是周末回去后发现大家都怨声载道的。</p>
<p>我的毕设内容是做一个供师生发布和选择实验课题的网站平台，实在是太简单了，导师说这种题目做出花来也就是七八十分。因此为了增加点技术含量，我使用了当时流行度还不是特别高的技术来制作它。整个过程当然是真金白银，这两个月期间我还直接或者间接地帮助了一些认识或者不认识的同学完成了他们的毕设，说请我吃饭的人最后都不知道哪里去了。后来论文得了八十六分，差点就能评优。</p>
<p>做完毕设以后，大学本科生涯就算结束了。曾经的舍友同学各奔东西。但是我觉得还不够过瘾，其实我还想读研。然而我没有得到保研的机会。也许工作一两年以后，我会有兴趣再去考一次研。</p>
<h3 id="-3">培训 <a class="header-anchor" href="#-3" aria-hidden="true">&#128279;</a></h3>
<p>大概在实习的第六个月的时候，我终于通过了公司的转正考核并且拿到OFFER，这段时间非常开心，一块大石终于落下，不至于在毕业以后回家打游戏。等待我的是毕业后长达三个月的入职培训。</p>
<p>培训的主要内容是Java以及Java Web，也是公司一贯以来的技术主流，然而并不是我非常熟悉的东西。除了在大二还是大三的时候选过一门不知所谓的Java课程，以及可以用Java来秒杀一些ACM中简单的大数题目以外，我对它几乎是没有任何印象。公司的培训有它的淘汰机制，所以我也怕被淘汰。所幸后来顺利地过去了。</p>
<p>培训进行的节奏非常快，基本是每周都要写一个对我们来说较大的Project，不睡觉也得写完。某天老师还说了一句听起来很污的话，“周六你们一起睡嘛”。然而我觉得现在好像也只有在这么紧张的节奏中才能专注于一件事情了。公司给我们提供午餐，目的就是让我们能够从早到晚呆在十七楼顶，就只专注一件事情。这段时间好像没有谁敢请假，好像一请假就要脱不知道多少节的样子。</p>
<p>在这段时间里面我认识了很多新同事，印象最深的一位同学是来自政法大学的研究生，专业是刑法。一份计算机的题目我做六十分，他能做一百分。他对知识的热情，真的让我有些无地自容。当然也还有其它非常优秀的同学，和这样的同学在一起参加培训，除了真的能学到东西以外，也能够鞭策自己。当然也还有厉害的老师，来自中科院的老师们，感觉在他们在Java世界的造诣已经成仙了。</p>
<h3 id="-4">疾<del></del>病 <a class="header-anchor" href="#-4" aria-hidden="true">&#128279;</a></h3>
<p>培训结束后不久，我经历了人生的第一次手术，同时我觉得也会是整个人生历程中较为痛苦的一次。具体过程就不提了，前前后后已经经历了近四个月，至今仍未痊愈。这段时间也是一整年中情绪最为低落的时间，我有点不知道自己在做什么以及该做什么。因为在病急时选择了一间非医保定点医院，医保不给报销，到现在不仅我自己没有赚到钱不说，还花掉了妈妈的大把积蓄。妈妈为了照顾我把工作也辞掉了，她自己心力交瘁看起来也老了不少。我是真的觉得很惭愧啊，可是又不知道自己能做些什么。做一份工作赚着微薄的工资，还得了这么个折磨人的病，总是不痊愈也不知道什么时候是个头，妈妈为了我再苦再累也不会说，每当想起都觉得好忧伤。</p>
<h3 id="-5">工作 <a class="header-anchor" href="#-5" aria-hidden="true">&#128279;</a></h3>
<p>因为疾病的关系，我在培训结束正式入职后不久就请了一个多月的病假。这对我来说又是一个打击。本来应该是迅速熟悉业务进入工作状态的时间，我却不得不缺席。回来以后发现当时的同事们都已经轻车熟路，而自己依然是一问三不知。后来我被调离了原项目组，进入到了一个新的环境，重新开始一个新的项目。好在新项目使用的技术相对来说是我比较熟悉的，而且没有涉及到大量的业务逻辑，情况才慢慢好起来。</p>
<p>一开始做起来觉得没什么问题，然而功能越加越多，慢慢就觉得有些力不从心，需要重构。重构的前提是要对相关技术有相当的熟悉程度与足够的项目结构经验，然而我发现自己对稍复杂的项目就已经没有了头绪。现在看来除了写代码以外，我要学的东西真的还有很多很多。很多事情我虽然知道怎样做是不好或者不够好的，但是我却不知道应该如何把它们变得更好。</p>
<p>因为工作的缘故，能够回家的时间越来越少了。从前还有寒暑假，现在也没有了。本来我是很喜欢冬天的，但是这个冬天过得一点都不安分。时不时就成了南风天，又下雨又潮湿，气温还异常高，以至于在珠海一月份穿短袖也不是一件过分的事。</p>
<p>以上总结。</p>
]]></description><pubDate>Tue Jan 12 2016 16:08:16 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/2015-annual-summary</link><guid isPermaLink="true">https://blog.wxsm.space/p/2015-annual-summary</guid></item><item><title>IE Cache Issue</title><description><![CDATA[<p>昨天发现了一个奇怪的问题，一个Web Application Update Entity的功能，在Chrome/Firefox上测试都正常运行，到了IE 11上就不行了，主要表现就是Update成功以后再次读取记录会读取出Update之前的值。功能逻辑就是一些简单的通过RESTful API来执行CRUD操作的Ajax调用。在IE上用控制台仔细调试一番后，发现在打开控制台的时候居然能表现正常，而关掉以后就立刻不行，这明显就是IE爸爸不走寻常路，把API也Cache下来了。于是就有了以下的解决方案。</p>
<!--more-->
<h2 id="">前端解决方案 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h2>
<p>既然是因为Cache产生的问题，那么就很容易解决，在API调用（主要是GET）中都添加一个随机数或者时间戳就行了，强制浏览器刷新。比如，原本请求的应该是这样的地址：</p>
<pre><code>var url = '/api/metadata/entity/list?type=car&amp;name=qq'
</code></pre>
<p>可以通过添加一个时间戳修改成这样：</p>
<pre><code>var url = '/api/metadata/entity/list?type=car&amp;name=qq&amp;_t=' + new Date().getTime()
</code></pre>
<p>其中添加的 <code>_t</code> 参数如果服务端没有定义的话就会自然而然地被扔掉（如果是有意义的参数就换个key，或者不写key也行），浏览器缓存也会因为每次请求的URL实际上都不一样而失效，这样问题就解决了。但是，对于一个大型项目来说，如果每个URL都要怎么来一遍，那么用软件工程界的专业术语来说，叫做不好维护。很有可能什么时候漏掉了一个URL没有加时间戳，就埋下了一个BUG的种子。</p>
<h2 id="-2">服务端解决方案 <a class="header-anchor" href="#-2" aria-hidden="true">&#128279;</a></h2>
<p>此处以使用ExpressJS搭建的NodeJS服务器为例，其它代码也可以使用类似的方法达到同样的效果。</p>
<p>以下是一本万利的解决思路：</p>
<pre><code>// No cache for RESTful APIs
    app.use('/api/*', function (req, res, next) {
        res.header(&quot;Cache-Control&quot;, &quot;no-cache, no-store, must-revalidate&quot;);
        res.header(&quot;Pragma&quot;, &quot;no-cache&quot;);
        res.header(&quot;Expires&quot;, 0);
        next();
    });
</code></pre>
<p>这段代码所做的事情是，对于所有进来的以’/api’开头为路由的请求，都执行以下操作：</p>
<ul>
<li>给响应头添加 <code>&quot;Cache-Control&quot;: &quot;no-cache, no-store, must-revalidate&quot;</code> 键值对</li>
<li>给响应头添加 <code>&quot;Pragma&quot;: &quot;no-cache&quot;</code> 键值对</li>
<li>给响应头添加 <code>&quot;Expires&quot;: 0</code> 键值对</li>
<li>将请求交给下游中间件，继续处理，该干嘛干嘛</li>
</ul>
<p>Cache-Control ：</p>
<ul>
<li>no-cache：指示请求或响应消息不能缓存</li>
<li>no-store：用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。</li>
<li>must-revalidate：字面理解，必须重新验证</li>
</ul>
<p>Pragma ：</p>
<ul>
<li>no-cache：在HTTP/1.1协议中，它的含义和Cache- Control:no-cache相同</li>
</ul>
<p>Expires：</p>
<ul>
<li>自然就是缓存的过期时间了</li>
</ul>
<p>那么通过以上方法，只要浏览器是支持基本HTTP协议的，它就应该能够做出相应的操作，从而不对API进行缓存。很显然这段代码应该在所有API的具体方法执行之前被执行，对于Express来说我们只需要把它放在其他路由代码之前就可以了。</p>
<h2 id="-3">总结 <a class="header-anchor" href="#-3" aria-hidden="true">&#128279;</a></h2>
<p>经过验证，两种方法都可以达到预期的效果。至于实际使用哪一种，可能还要视具体需求而定。</p>
]]></description><pubDate>Wed Jan 06 2016 17:12:47 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/ie-cache-issue</link><guid isPermaLink="true">https://blog.wxsm.space/p/ie-cache-issue</guid></item><item><title>MEAN.js Menu Service Extension</title><description><![CDATA[<p>MEAN.js解决方案只提供了1级/2级菜单栏的service支持，最近项目中需要用到第3级菜单，所以需要进行一个小的功能扩展。一开始我以为可以很容易地做到无限级，真正做起来以后发现并没有那么简单，所以目前通过这个办法只能达到第3级。</p>
<!--more-->
<h2 id="menu">修改Menu服务 <a class="header-anchor" href="#menu" aria-hidden="true">&#128279;</a></h2>
<p>初始的Menu Service中为使用者写了两个添加菜单项的方法：</p>
<pre><code>// Add menu item object
this.addMenuItem = function (menuId, options)
</code></pre>
<p>以及</p>
<pre><code>// Add submenu item object
this.addSubMenuItem = function (menuId, parentItemState, options)
</code></pre>
<p>第一个方法很显然就是用来添加顶级菜单了，第二个在没有看代码以前我曾经天真地以为它可以无限嵌套，然而并没有，它做的事情仅限于添加第2级菜单。所以现在我需要自己写第三个方法来完成添加第三级菜单。考虑到三级循环的效率问题，虽然一般来说菜单项不会有太多，但看起来就是非常不爽，所以我给每个Menu项都添加了一个哈希表来储存其下面所有菜单项的引用，这样多花费一点点内存就可以不用写循环嵌套了。由于使用了哈希表，对原2级菜单做了一些修改：</p>
<pre><code>// Add submenu item object
    this.addSubMenuItem = function (menuId, parentItemState, options) {
        options = options || {};

        // Validate that the menu exists
        this.validateMenuExistance(menuId);

        // Search for menu item
        for (var itemIndex in this.menus[menuId].items) {
            if (this.menus[menuId].items[itemIndex].state === parentItemState) {
                // Push new submenu item
                var newSubmenuItem = {
                    title: options.title || '',
                    state: options.state || '',
                    disabled: options.disabled || false,
                    roles: ((options.roles === null || typeof options.roles === 'undefined') ? this.menus[menuId].items[itemIndex].roles : options.roles),
                    position: options.position || 0,
                    shouldRender: shouldRender,
                    items: []
                };
                this.menus[menuId].items[itemIndex].items.push(newSubmenuItem);
                this.menus[menuId].menuHash[newSubmenuItem.state] = newSubmenuItem;

                if (options.items) {
                    for (var i in options.items) {
                        this.addSubMenuItemToSubMenu(menuId, options.state, options.items[i]);
                    }
                }
            }
        }

        // Return the menu object
        return this.menus[menuId];
    };
</code></pre>
<p>然后是新的添加3级菜单的方法：</p>
<pre><code>//For level 3 menu items
    this.addSubMenuItemToSubMenu = function (menuId, parentItemState, options) {
        options = options || {};
        this.validateMenuExistance(menuId);
        for (var itemIndex in this.menus[menuId].menuHash) {
            if (this.menus[menuId].menuHash[itemIndex].state === parentItemState) {
                // Push new submenu item
                var newSubMenuItem = {
                    title: options.title || '',
                    state: options.state || '',
                    disabled: options.disabled || false,
                    roles: ((options.roles === null || typeof options.roles === 'undefined') ? this.menus[menuId].menuHash[itemIndex].roles : options.roles),
                    position: options.position || 0,
                    shouldRender: shouldRender,
                    items: []
                };
                this.menus[menuId].menuHash[itemIndex].items.push(newSubMenuItem);
                this.menus[menuId].menuHash[newSubMenuItem.state] = newSubMenuItem;
            }
        }
        return this.menus[menuId];
    };
</code></pre>
<h2 id="header">修改Header模板 <a class="header-anchor" href="#header" aria-hidden="true">&#128279;</a></h2>
<p>原Header模板中嵌套了两层Angular循环来遍历菜单项，我们给它加一层就好了，改完以后就像这样：</p>
<pre><code>&lt;nav class=&quot;collapse navbar-collapse&quot; uib-collapse=&quot;!isCollapsed&quot; role=&quot;navigation&quot;&gt;
    &lt;ul class=&quot;nav navbar-nav&quot; ng-if=&quot;menu.shouldRender(authentication.user);&quot;&gt;
      &lt;li ng-repeat=&quot;item in menu.items | orderBy: 'position'&quot; ng-if=&quot;item.shouldRender(authentication.user);&quot;
          ng-switch=&quot;item.type&quot;
          ng-class=&quot;{ active: $state.includes(item.state), dropdown: item.type === 'dropdown',disabled:item.disabled }&quot;
          class=&quot;{{item.class}}&quot; uib-dropdown=&quot;item.type === 'dropdown'&quot;&gt;
        &lt;a ng-switch-when=&quot;dropdown&quot; class=&quot;dropdown-toggle&quot; uib-dropdown-toggle role=&quot;button&quot;&gt;{{::item.title}}&amp;nbsp;&lt;span
          class=&quot;caret&quot;&gt;&lt;/span&gt;&lt;/a&gt;
        &lt;ul ng-switch-when=&quot;dropdown&quot; class=&quot;dropdown-menu&quot;&gt;
          &lt;li ng-repeat=&quot;subitem in item.items | orderBy: 'position'&quot; ng-if=&quot;subitem.shouldRender(authentication.user);&quot;
              ui-sref-active=&quot;active&quot; ng-class=&quot;{'dropdown-submenu':subitem.items.length&gt;0,disabled:subitem.disabled}&quot;&gt;
            &lt;a ui-sref=&quot;{{subitem.state}}&quot; ng-bind=&quot;subitem.title&quot; ng-if=&quot;subitem.items.length===0&quot;&gt;&lt;/a&gt;
            &lt;a href=&quot;javascript:;&quot; ng-bind=&quot;subitem.title&quot; ng-if=&quot;subitem.items.length&gt;0&quot;&gt;&lt;/a&gt;
            &lt;ul class=&quot;dropdown-menu&quot; ng-if=&quot;subitem.items.length&gt;0&quot;&gt;
              &lt;li ng-repeat=&quot;i in subitem.items | orderBy: 'position'&quot; ng-if=&quot;i.shouldRender(authentication.user);&quot;
                  ui-sref-active=&quot;active&quot; ng-class=&quot;{disabled:i.disabled}&quot;&gt;
                &lt;a ui-sref=&quot;{{i.state}}&quot; ng-bind=&quot;i.title&quot;&gt;&lt;/a&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
        &lt;a ng-switch-default ui-sref=&quot;{{item.state}}&quot; ng-bind=&quot;item.title&quot;&gt;&lt;/a&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul class=&quot;nav navbar-nav navbar-right&quot; ng-hide=&quot;authentication.user&quot;&gt;
      &lt;li ui-sref-active=&quot;active&quot;&gt;
        &lt;a ui-sref=&quot;authentication.signup&quot;&gt;Sign Up&lt;/a&gt;
      &lt;/li&gt;
      &lt;li class=&quot;divider-vertical&quot;&gt;&lt;/li&gt;
      &lt;li ui-sref-active=&quot;active&quot;&gt;
        &lt;a ui-sref=&quot;authentication.signin&quot;&gt;Sign In&lt;/a&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul class=&quot;nav navbar-nav navbar-right&quot; ng-show=&quot;authentication.user&quot;&gt;
      &lt;li class=&quot;dropdown&quot; uib-dropdown&gt;
        &lt;a class=&quot;dropdown-toggle user-header-dropdown-toggle&quot; uib-dropdown-toggle role=&quot;button&quot;&gt;
          &lt;img ng-src=&quot;{{authentication.user.profileImageURL}}&quot; alt=&quot;{{authentication.user.displayName}}&quot;
               class=&quot;header-profile-image&quot;/&gt;
          &lt;span ng-bind=&quot;authentication.user.displayName&quot;&gt;&lt;/span&gt; &lt;b class=&quot;caret&quot;&gt;&lt;/b&gt;
        &lt;/a&gt;
        &lt;ul class=&quot;dropdown-menu&quot; role=&quot;menu&quot;&gt;
          &lt;li ui-sref-active=&quot;active&quot;&gt;
            &lt;a ui-sref=&quot;settings.profile&quot;&gt;Edit Profile&lt;/a&gt;
          &lt;/li&gt;
          &lt;li ui-sref-active=&quot;active&quot;&gt;
            &lt;a ui-sref=&quot;settings.picture&quot;&gt;Change Profile Picture&lt;/a&gt;
          &lt;/li&gt;
          &lt;li ui-sref-active=&quot;active&quot; ng-show=&quot;authentication.user.provider === 'local'&quot;&gt;
            &lt;a ui-sref=&quot;settings.password&quot;&gt;Change Password&lt;/a&gt;
          &lt;/li&gt;
          &lt;!--li ui-sref-active=&quot;active&quot;&gt;
            &lt;a ui-sref=&quot;settings.accounts&quot;&gt;Manage Social Accounts&lt;/a&gt;
          &lt;/li--&gt;
          &lt;li class=&quot;divider&quot;&gt;&lt;/li&gt;
          &lt;li&gt;
            &lt;a href=&quot;/api/auth/signout&quot; target=&quot;_self&quot;&gt;Signout&lt;/a&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/nav&gt;
</code></pre>
<h2 id="css">修改CSS <a class="header-anchor" href="#css" aria-hidden="true">&#128279;</a></h2>
<p>为了让菜单看起来更自然些，这里修改的是 <code>core.css</code>，添加以下内容：</p>
<pre><code>.dropdown-submenu {
    position: relative;
}

.dropdown-menu {
    -webkit-border-radius: 0;
    -moz-border-radius: 0;
    border-radius: 0;
}

.dropdown-submenu &gt; .dropdown-menu {
    top: 0;
    left: 100%;
    margin-top: -6px;
    margin-left: -1px;
}

.dropdown-submenu:hover &gt; .dropdown-menu {
    display: block;
}

.dropdown-submenu &gt; a:after {
    display: block;
    content: &quot; &quot;;
    float: right;
    width: 0;
    height: 0;
    border-color: transparent;
    border-style: solid;
    border-width: 5px 0 5px 5px;
    border-left-color: #333;
    margin: 5px -10px 0;
}

.dropdown-submenu:hover &gt; a:after {
    border-left-color: #333;
}

.dropdown-submenu.pull-left {
    float: none;
}

.dropdown-submenu.pull-left &gt; .dropdown-menu {
    left: -100%;
    margin-left: 10px;
    -webkit-border-radius: 6px 0 6px 6px;
    -moz-border-radius: 6px 0 6px 6px;
    border-radius: 6px 0 6px 6px;
}
</code></pre>
<p> </p>
<h2 id="">使用方法 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h2>
<p>3级菜单的定义方法与2级菜单一模一样，除了直接调用 <code>addSubMenuItemToSubMenu</code>  以外，还可以通过在2级菜单内定义 <code>items</code> 来实现添加子菜单，示例如下，高亮部分则为3级菜单：</p>
<pre><code>Menus.addMenuItem('topbar', {
            title: '...',
            state: '...',
            type: 'dropdown',
            position: 0,
            roles: ['*'],
            items: [{
                title: '...',
                state: '...',
                roles: ['*']
            }, {
                title: '...',
                state: '...',
                roles: ['*'],
                items: [{
                    title: '...',
                    state: '...',
                    roles: ['*']
                }, {
                    title: '...',
                    state: '...',
                    roles: ['*']
                }]
            }]
        });
</code></pre>
<h2 id="-2">实现无限级 <a class="header-anchor" href="#-2" aria-hidden="true">&#128279;</a></h2>
<p>目前看来菜单层级的限制不是在于Service代码，而在于模板。如何在模板中让Angular做一个DFS搜索才是重点。Angular貌似没有提供类似的API，要做的话比较好的办法应该是自己写一个指令。以后有时间再来实现。</p>
]]></description><pubDate>Tue Jan 05 2016 17:34:47 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/mean-js-menu-service-extension</link><guid isPermaLink="true">https://blog.wxsm.space/p/mean-js-menu-service-extension</guid></item><item><title>Angular 教程：添加动画</title><description><![CDATA[<p>在这最后一步中，我们将通过在模板代码中添加一些CSS以及JavaScript动画来让Web应用看起来更酷炫一点。</p>
<ul>
<li>我们通过使用<code>ngAnimate</code>模块来在应用程序中启用动画</li>
<li>我们也会使用一些通用的<code>ng</code>指令来自动配置动画的切入时机</li>
<li>在注册了动画效果后，标准的DOM操作将会触发相应的动画（比如说通过<code>ngRepeat</code>插入以及移除节点，或者在<code>ngClass</code>中添加或移除CSS类）</li>
</ul>
<p>最重要的改动如下所示。你可以在<a href="https://github.com/angular/angular-phonecat/compare/step-11...step-12" title="See diff on Github">GitHub</a>上查看它与之前的代码有何区别。</p>
<hr>
<h2 id="">依赖 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h2>
<p>动画功能由Angular的<code>ngAnimate</code>模块提供，该模块没有包含在Angular的核心框架中。在此我们还使用了<code>jQuery</code>来做一些额外的JavaScript动画效果。 我们使用<a href="http://bower.io/">Bower</a>来安装客户端的依赖。通过更新 <code>bower.json</code> 配置文件来加入新的依赖项：</p>
<pre><code>{
  &quot;name&quot;: &quot;angular-seed&quot;,
  &quot;description&quot;: &quot;A starter project for AngularJS&quot;,
  &quot;version&quot;: &quot;0.0.0&quot;,
  &quot;homepage&quot;: &quot;https://github.com/angular/angular-seed&quot;,
  &quot;license&quot;: &quot;MIT&quot;,
  &quot;private&quot;: true,
  &quot;dependencies&quot;: {
    &quot;angular&quot;: &quot;1.4.x&quot;,
    &quot;angular-mocks&quot;: &quot;1.4.x&quot;,
    &quot;jquery&quot;: &quot;~2.1.1&quot;,
    &quot;bootstrap&quot;: &quot;~3.1.1&quot;,
    &quot;angular-route&quot;: &quot;1.4.x&quot;,
    &quot;angular-resource&quot;: &quot;1.4.x&quot;,
    &quot;angular-animate&quot;: &quot;1.4.x&quot;
  }
}
</code></pre>
<ul>
<li><code>&quot;angular-animate&quot;: &quot;1.4.x&quot;</code>告诉Bower需要安装1.4.x版本的angular-resource组件</li>
<li><code>&quot;jquery&quot;: &quot;~2.1.1&quot;</code>告诉Bower需要安装2.1.1版本的jQuery，需要注意的是这并不是一个Angular模块，它是标准的jQuery库。我们可以使用Bower来安装各种各样的第三方工具</li>
</ul>
<p>我们使用Bower来下载以及安装这些组件，通过执行：</p>
<pre><code>npm install
</code></pre>
<blockquote>
<p>警告：如果在你上一次运行 npm install 之后Angular发布了新版本的话，在运行 install 的时候可能就会遇到问题（因为angular.js的版本发生了冲突）。解决方法是在执行 install 之前先删除bower_components 目录。</p>
</blockquote>
<p> </p>
<blockquote>
<p>注意：如果你已经全局安装了bower，你可以使用 install 指令。但在这个项目中我们有预设的 install 指令来完成相同的事</p>
</blockquote>
<hr>
<h2 id="nganimate">ngAnimate的工作机制 <a class="header-anchor" href="#nganimate" aria-hidden="true">&#128279;</a></h2>
<p>如果想要了解关于AngularJS中动画的运行机制的话，可以先阅读<a href="https://docs.angularjs.org/guide/animations">AngularJS动画指导</a>。</p>
<hr>
<h2 id="-2">模板 <a class="header-anchor" href="#-2" aria-hidden="true">&#128279;</a></h2>
<p>我们需要在HTML模板代码中添加对<code>angular-animate.js</code>文件的依赖。<code>angular-animate.js</code>文件中定义了<code>ngAnimate</code>模块，它的作用是让应用能够注意到一些动画的存在。</p>
<p><code>app/index.html</code>：</p>
<pre><code>...
  &lt;!-- for CSS Transitions and/or Keyframe Animations --&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;css/animations.css&quot;&gt;

  ...

  &lt;!-- jQuery is used for JavaScript animations (include this before angular.js) --&gt;
  &lt;script src=&quot;bower_components/jquery/dist/jquery.js&quot;&gt;&lt;/script&gt;

  ...

  &lt;!-- required module to enable animation support in AngularJS --&gt;
  &lt;script src=&quot;bower_components/angular-animate/angular-animate.js&quot;&gt;&lt;/script&gt;

  &lt;!-- for JavaScript Animations --&gt;
  &lt;script src=&quot;js/animations.js&quot;&gt;&lt;/script&gt;

...
</code></pre>
<blockquote>
<p><strong>重要</strong>：当使用Angular 1.4版本的时候必须确保同时使用的jQuery版本大于或等于2.1；官方不确保jQuery 1.x是被完全支持的。确保在加载所有的AngularJS脚本以前先加载jQuery，反之Angular将不会检测到jQuery的存在，动画效果也就会出现一些问题。</p>
</blockquote>
<p>我们现在可以同时在CSS代码（<code>animations.css</code>）以及JavaScript代码（<code>animations.js</code>）中创建动画了。但在这之前，就像使用<code>ngResource</code>，我们先来创建一个依赖于<code>ngAnimate</code>的新模块。</p>
<hr>
<h2 id="-3">模块与动画 <a class="header-anchor" href="#-3" aria-hidden="true">&#128279;</a></h2>
<p><code>app/js/animations.js</code>：</p>
<pre><code>angular.module('phonecatAnimations', ['ngAnimate']);
// ...
// this module will later be used to define animations
// ...

</code></pre>
<p>然后我们把它附加到应用中去。</p>
<p><code>app/js/app.js</code>：</p>
<pre><code>// ...
angular.module('phonecatApp', [
  'ngRoute',

  'phonecatAnimations',
  'phonecatControllers',
  'phonecatFilters',
  'phonecatServices',
]);
// ...
</code></pre>
<p>现在应用可以检测动画了。我们来做些动画吧！</p>
<hr>
<h2 id="cssngrepeat">带有CSS动画的ngRepeat <a class="header-anchor" href="#cssngrepeat" aria-hidden="true">&#128279;</a></h2>
<p>我们先来给<code>phone-list.html</code>页面中的<code>ngRepeat</code>指令加点CSS动画。首先我们给循环体添加一些额外的CSS类，然后我们就可以把它和我们定义的CSS动画挂上钩了。</p>
<p><code>app/partials/phone-list.html</code>：</p>
<pre><code>&lt;!--
  Let's change the repeater HTML to include a new CSS class
  which we will later use for animations:
--&gt;
&lt;ul class=&quot;phones&quot;&gt;
  &lt;li ng-repeat=&quot;phone in phones | filter:query | orderBy:orderProp&quot;
      class=&quot;thumbnail phone-listing&quot;&gt;
    &lt;a href=&quot;#/phones/{{phone.id}}&quot; class=&quot;thumb&quot;&gt;&lt;img ng-src=&quot;{{phone.imageUrl}}&quot;&gt;&lt;/a&gt;
    &lt;a href=&quot;#/phones/{{phone.id}}&quot;&gt;{{phone.name}}&lt;/a&gt;
    &lt;p&gt;{{phone.snippet}}&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>看到我们是怎么给它加上<code>phone-listing</code>CSS类的了吗？在HTML中写这么点代码就完全足够了。 接下来是真正的CSS Transition动画代码。</p>
<p><code>app/css/animations.css</code>：</p>
<pre><code>.phone-listing.ng-enter,
.phone-listing.ng-leave,
.phone-listing.ng-move {
  -webkit-transition: 0.5s linear all;
  -moz-transition: 0.5s linear all;
  -o-transition: 0.5s linear all;
  transition: 0.5s linear all;
}

.phone-listing.ng-enter,
.phone-listing.ng-move {
  opacity: 0;
  height: 0;
  overflow: hidden;
}

.phone-listing.ng-move.ng-move-active,
.phone-listing.ng-enter.ng-enter-active {
  opacity: 1;
  height: 120px;
}

.phone-listing.ng-leave {
  opacity: 1;
  overflow: hidden;
}

.phone-listing.ng-leave.ng-leave-active {
  opacity: 0;
  height: 0;
  padding-top: 0;
  padding-bottom: 0;
}
</code></pre>
<p>如你所见，<code>phone-listing</code>CSS类用来与一些动画钩子结合使用了。钩子会在动画事件发生时被添加或者删除。</p>
<ul>
<li><code>ng-enter</code>类会在新元素添加到列表并且渲染到页面中时触发</li>
<li><code>ng-move</code>类会在元素在列表中移动时触发</li>
<li><code>ng-leave</code>类会在元素从列表中移除时触发</li>
</ul>
<p>手机列表中的元素会根据传入<code>ng-repeat</code>指令中的数据被添加或者移除。举例说，如果过滤器的值发生了变化，那么这些元素会在列表中动画式的出场或退场。 在这里，重点是要注意到当动画发生时，两组CSS类会被添加到元素上：</p>
<ol>
<li><code>starting</code>类意味着动画开始时的样式</li>
<li><code>active</code>类意味着动画结束时的样式</li>
</ol>
<p>starting样式的类名由<code>ng-</code>前缀和当时触发的事件名（比如<code>enter</code>，<code>move</code>或者<code>leave</code>）组成，所以<code>enter</code>事件会与<code>ng-enter</code>类挂钩。 active样式的类名与starting类一模一样，除了<code>-active</code>后缀。这两种CSS命名转换允许开发者构建完整的，从开始到结束的所有动画。</p>
<p>在上面的例子中，当元素被添加进列表时，它们的高度会从<strong><strong>变成<strong>120</strong>个像素，并且在被移除之前会重新变回</strong></strong>像素。同时它们还有一个不错的淡出淡入效果。所有这些都是由以上的CSS Transition声明来控制的。 虽然绝大多数主流浏览器对CSS Transition和CSS动画都有着不错的支持，但请不要忘记IE爸爸，如果你想要让动画效果可以支持到更老旧一些的浏览器的话，可以考虑使用基于JavaScript的动画，我们会在下面的内容中介绍。</p>
<hr>
<h2 id="css-keyframengview">带有CSS Keyframe动画的ngView <a class="header-anchor" href="#css-keyframengview" aria-hidden="true">&#128279;</a></h2>
<p>接下来我们给<code>ngView</code>在路由转换的时候添加一个动画。 在开始之前，我们给HTML添加一个新的CSS类，就跟刚才所做的一样。这一次我们把它添加到包含<code>ng-view</code>指令的元素中去。为了做到这些，我们对HTML代码做了少许改动，这样我们在视图转换的时候可以有更多的控制权。</p>
<p><code>app/index.html</code>：</p>
<pre><code>&lt;div class=&quot;view-container&quot;&gt;
  &lt;div ng-view class=&quot;view-frame&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>通过这个改动，<code>ng-view</code>指令将被包含在一个拥有<code>view-container</code>CSS类的父节点中。这个CSS类给节点添加了一个<code>position: relative</code>类，因此在动画效果执行时<code>ng-view</code>的位置是通过这个父节点计算得出的。 做完这些工作后，我们就可以给它添加一些CSS动画了。</p>
<p><code>app/css/animations.css</code>：</p>
<pre><code>.view-container {
  position: relative;
}

.view-frame.ng-enter, .view-frame.ng-leave {
  background: white;
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
}

.view-frame.ng-enter {
  -webkit-animation: 0.5s fade-in;
  -moz-animation: 0.5s fade-in;
  -o-animation: 0.5s fade-in;
  animation: 0.5s fade-in;
  z-index: 100;
}

.view-frame.ng-leave {
  -webkit-animation: 0.5s fade-out;
  -moz-animation: 0.5s fade-out;
  -o-animation: 0.5s fade-out;
  animation: 0.5s fade-out;
  z-index:99;
}

@keyframes fade-in {
  from { opacity: 0; }
  to { opacity: 1; }
}
@-moz-keyframes fade-in {
  from { opacity: 0; }
  to { opacity: 1; }
}
@-webkit-keyframes fade-in {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes fade-out {
  from { opacity: 1; }
  to { opacity: 0; }
}
@-moz-keyframes fade-out {
  from { opacity: 1; }
  to { opacity: 0; }
}
@-webkit-keyframes fade-out {
  from { opacity: 1; }
  to { opacity: 0; }
}

/* don't forget about the vendor-prefixes! */
</code></pre>
<p>这些代码中除了页面切换时的淡出淡入效果以外没什么丧心病狂的东西。唯一特别的事情是我们使用了绝对定位来对新页面（由<code>ng-enter</code></p>
<p>标记）与旧页面（由<code>ng-leave</code></p>
<p>标记）在交叉动画的过程中进行定位。因此当旧页面即将被移除的时候，在它淡出的同时新页面也将同时在与其相同的顶端位置上淡入。 一旦leave动画结束元素就会被移除，同理一旦enter动画结束<code>ng-enter</code>以及<code>ng-enter-active</code>CSS类也会从元素中被移除，然后它就会由其本身的CSS代码来重新渲染和定位（所以一旦动画结束就不存在有失优雅的绝对定位了）。在路由变化的整个过程中这些都会是非常流畅的，页面将表现得非常自然而不是各种闪现。 添加的CSS代码（start和end类）与给<code>ng-repeat</code>添加的代码非常相似。每次新页面加载完成的时候<code>ng-view</code>都会创建一个自身的副本，下载模板然后追加内容。这么做可以保证所有的视图都包含在一个HTML元素中，于是动画就会变得更容易控制。</p>
<p>更多的CSS动画请参考<a href="http://docs.webplatform.org/wiki/css/properties/animations">文档</a>。</p>
<hr>
<h2 id="javascriptngclass">带JavaScript动画的ngClass <a class="header-anchor" href="#javascriptngclass" aria-hidden="true">&#128279;</a></h2>
<p>我们来给应用添加另一种动画。打开<code>phone-detail.html</code>页面，我们已经完成了一个不错的图片切换功能。通过点击缩略图我们可以改变显示在详细页面上的大图。但我们要怎么给它加点动画呢？</p>
<p>首先我们先来思考一下。从根本而言，当点击略缩图时，我们是通过改变大图的状态来反应这一次点击的。在HTML世界中最好的反应状态的方法就是使用CSS类。就像我们之前所做的通过CSS类来定义动画，这次动画将在CSS类本身发生变化时启动。 无论选中的缩略图在何时发生变化都将导致状态的变化，同时我们将给大图添加一个<code>.active</code>CSS类来执行动画效果。 我们先来处理<code>phone-detail.html</code>页面。需要注意的是显示大图的方式已经发生了变化。</p>
<p><code>app/partials/phone-detail.html</code>：</p>
<pre><code>&lt;!-- We're only changing the top of the file --&gt;
&lt;div class=&quot;phone-images&quot;&gt;
  &lt;img ng-src=&quot;{{img}}&quot;
       class=&quot;phone&quot;
       ng-repeat=&quot;img in phone.images&quot;
       ng-class=&quot;{active:mainImageUrl==img}&quot;&gt;
&lt;/div&gt;

&lt;h1&gt;{{phone.name}}&lt;/h1&gt;

&lt;p&gt;{{phone.description}}&lt;/p&gt;

&lt;ul class=&quot;phone-thumbs&quot;&gt;
  &lt;li ng-repeat=&quot;img in phone.images&quot;&gt;
    &lt;img ng-src=&quot;{{img}}&quot; ng-mouseenter=&quot;setImage(img)&quot;&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>就像略所图一样，我们使用一个循环器来显示了<strong>所有</strong>大图，但我们并不会给它添加任何与循环有关的动画。不同的是我们使用<code>ng-class</code>指令来做了一个判断，当且仅当<code>active</code>类为真时它才会被添加到元素上去，然后元素会显示为可见。除此以外它们就将处于隐藏的状态。对于我们目前的情况来说，总会有一张图片是拥有<code>active</code></p>
<p>类的，因此任何时候都会有仅有一张图片在视图上是可见的。 当<code>active</code>类被添加到元素上的时候，<code>active-add</code>和<code>active-add-active</code>类会在此之前被AngularJS触发。同理当移除类时，<code>active-remove</code>和<code>active-remove-active</code>类也会在恰当的时机被添加到元素上去。 为了保证手机图片在页面一开始加载的时候能够正确地显示，我们给详细页添加了一些CSS样式。</p>
<p><code>app/css/app.css</code>：</p>
<pre><code>.phone-images {
  background-color: white;
  width: 450px;
  height: 450px;
  overflow: hidden;
  position: relative;
  float: left;
}

...

img.phone {
  float: left;
  margin-right: 3em;
  margin-bottom: 2em;
  background-color: white;
  padding: 2em;
  height: 400px;
  width: 400px;
  display: none;
}

img.phone:first-child {
  display: block;
  }
</code></pre>
<p>你可能会觉得我们要做的不过是创建另一个CSS动画。虽然确实可以这么做，但既然有这么个机会我们就可以学习如何使用JavaScript来编写动画。</p>
<p><code>app/js/animations.js</code>：</p>
<pre><code>var phonecatAnimations = angular.module('phonecatAnimations', ['ngAnimate']);

phonecatAnimations.animation('.phone', function() {

  var animateUp = function(element, className, done) {
    if(className != 'active') {
      return;
    }
    element.css({
      position: 'absolute',
      top: 500,
      left: 0,
      display: 'block'
    });

    jQuery(element).animate({
      top: 0
    }, done);

    return function(cancel) {
      if(cancel) {
        element.stop();
      }
    };
  }

  var animateDown = function(element, className, done) {
    if(className != 'active') {
      return;
    }
    element.css({
      position: 'absolute',
      left: 0,
      top: 0
    });

    jQuery(element).animate({
      top: -500
    }, done);

    return function(cancel) {
      if(cancel) {
        element.stop();
      }
    };
  }

  return {
    addClass: animateUp,
    removeClass: animateDown
  };
});
</code></pre>
<p>注意到我们使用了<a href="http://jquery.com/">jQuery</a>来实现动画效果。Angular并不需要jQuery来完成JavaScript动画，但我们还是用了它，因为如何编写一个JavaScript动画库并不在本教程的范围之内。更多关于<code>jQuery.animate</code>的信息请查看<a href="http://api.jquery.com/animate/">jQuery文档</a>。</p>
<p><code>addClass</code>和<code>removeClass</code>回调函数会在元素添加或者移除所注册的CSS类（<code>.phone</code>）的时候被调用。当<code>.active</code>类被添加到元素上（通过<code>ng-class</code>指令）的时候，<code>addClass</code>JavaScript回调就会在被当作参数而传入到其中的元素（element上执行。最后一个传入的参数是<code>done</code>回调函数。<code>done</code>函数的目的是可以通过调用它让Angular知道这次JavaScript动画已经执行完了。<code>removeClass</code>回调除了触发的时机不同以外，工作方式和上面一模一样。</p>
<p>在JavaScript回调内，我们通过操作DOM来创建动画。在上面的代码中我们使用了<code>element.css()</code>和<code>element.animate()</code>来操作DOM，回调函数把新元素放在了距离原位置<strong>500</strong>个像素的地方，然后把旧元素和新元素同时地向上移动<strong>500</strong>个像素。因此这个动画看起来就跟传送带一样。当<code>animate</code>函数完成所有事情以后，它就会调用<code>done</code>方法。 需要注意的是<code>addClass</code>和<code>removeClass</code>都返回了一个函数。这个<strong>可选</strong>函数将在动画被取消（另一个动画发生在同一元素上）时触发，当然也包括动画自然完成的情况。函数将被传入一个布尔类型的参数，开发者可以根据它来判断动画是否被取消了。这个函数可以用来给动画做一些收尾工作。</p>
<h2 id="-4">总结 <a class="header-anchor" href="#-4" aria-hidden="true">&#128279;</a></h2>
<p>就这样了！我们在超短的时间内构建了一个Web应用。你可以继续在代码中进行深入的探索，并且使用<code>git checkout</code>随时退回到之前步骤的状态下。</p>
]]></description><pubDate>Tue Dec 29 2015 16:00:39 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/angular-tutorial-applying-animations</link><guid isPermaLink="true">https://blog.wxsm.space/p/angular-tutorial-applying-animations</guid></item><item><title>Angular 教程：REST 和自定义服务</title><description><![CDATA[<p>在这一步中，应用程序抓取数据的方式将会改变。</p>
<ul>
<li>我们定义了一个代表着<a href="http://en.wikipedia.org/wiki/Representational_State_Transfer">RESTful</a>客户端的自定义服务。通过这个客户端我们可以用更简洁的方式向服务器发起数据请求，不再与低层次的<a href="https://docs.angularjs.org/api/ng/service/$http">$http</a>接口，HTTP方法与URL等打交道</li>
</ul>
<p>最重要的改动如下所示。你可以在<a href="https://github.com/angular/angular-phonecat/compare/step-10...step-11" title="See diff on Github">GitHub</a>上查看它与之前的代码有何区别。</p>
<hr>
<h2 id="">依赖 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h2>
<p>RESTful功能由Angular的<code>ngResource</code>模块提供，该模块没有包含在Angular的核心框架中。 我们使用<a href="http://bower.io/">Bower</a>来安装客户端的依赖。通过更新<code>bower.json</code>配置文件来加入新的依赖项：</p>
<pre><code>{
  &quot;name&quot;: &quot;angular-seed&quot;,
  &quot;description&quot;: &quot;A starter project for AngularJS&quot;,
  &quot;version&quot;: &quot;0.0.0&quot;,
  &quot;homepage&quot;: &quot;https://github.com/angular/angular-seed&quot;,
  &quot;license&quot;: &quot;MIT&quot;,
  &quot;private&quot;: true,
  &quot;dependencies&quot;: {
    &quot;angular&quot;: &quot;1.4.x&quot;,
    &quot;angular-mocks&quot;: &quot;1.4.x&quot;,
    &quot;jquery&quot;: &quot;~2.1.1&quot;,
    &quot;bootstrap&quot;: &quot;~3.1.1&quot;,
    &quot;angular-route&quot;: &quot;1.4.x&quot;,
    &quot;angular-resource&quot;: &quot;1.4.x&quot;
  }
}
</code></pre>
<p>新的依赖项<code>&quot;angular-resource&quot;: &quot;1.4.x&quot;</code>告诉Bower需要安装1.4.x版本的angular-resource组件。通过以下命令下载并安装依赖：</p>
<pre><code>npm install
</code></pre>
<blockquote>
<p>警告：如果在你上一次运行<code>npm install</code>之后Angular发布了新版本的话，在运行<code>bower install</code>的时候可能就会遇到问题（因为angular.js的版本发生了冲突）。解决方法是在执行<code>npm install</code>之前先删除<code>app/bower_components</code>目录。</p>
</blockquote>
<p> </p>
<blockquote>
<p>注意：如果你已经全局安装了bower，你可以使用<code>bower install</code>指令。但在这个项目中我们有预设的<code>npm install</code>指令来完成相同的事情</p>
</blockquote>
<hr>
<h2 id="-2">模板 <a class="header-anchor" href="#-2" aria-hidden="true">&#128279;</a></h2>
<p><code>app/js/services.js</code>文件将包含一些自定义服务的代码，所以我们要把它添加到布局模版中。同时我们也要加载<code>angular-resource.js</code>文件，它包含了ngResource模块。</p>
<p><code>app/index.html</code>：</p>
<pre><code>...
  &lt;script src=&quot;bower_components/angular-resource/angular-resource.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;js/services.js&quot;&gt;&lt;/script&gt;
...
</code></pre>
<hr>
<h2 id="-3">服务 <a class="header-anchor" href="#-3" aria-hidden="true">&#128279;</a></h2>
<p>我们通过自己创建的服务来与服务器上的手机数据打交道：</p>
<p><code>app/js/services.js</code>：</p>
<pre><code>var phonecatServices = angular.module('phonecatServices', ['ngResource']);

phonecatServices.factory('Phone', ['$resource',
  function($resource){
    return $resource('phones/:phoneId.json', {}, {
      query: {method:'GET', params:{phoneId:'phones'}, isArray:true}
    });
  }]);
</code></pre>
<p>我们通过使用工厂（Factory）方法以及模块（Module）API来注册一个自定义服务。我们给它传递了两个参数：服务名（Phone）以及工厂方法。工厂方法的构造与控制器非常相似，它们都能通过方法参数来接受注入。在这个服务中我们声明了一项对<code>$resource</code>服务的依赖。<code>$resource</code>服务可以让我们使用更少的代码以更简洁的方式来创建RESTful客户端。这个客户端可以取代低层次的<code>$http</code>服务在应用中的作用。</p>
<p><code>app/js/app.js</code>：</p>
<pre><code>...
angular.module('phonecatApp', ['ngRoute', 'phonecatControllers','phonecatFilters', 'phonecatServices']).
...
</code></pre>
<p>我们需要给<code>phonecatApp</code>主模块添加对<code>phonecatServices</code>模块的依赖。</p>
<hr>
<h2 id="-4">控制器 <a class="header-anchor" href="#-4" aria-hidden="true">&#128279;</a></h2>
<p>我们通过使用<code>Phone</code>服务替代低层次的<code>$http</code>服务来简化子控制器（<code>PhoneListCtrl</code>和<code>PhoneDetailCtrl</code>）。对于暴露的RESTful数据资源来说，Angular的<code>$recource</code>服务比<code>$http</code>服务用起来更简单，并且代码也更容易看懂了。</p>
<p><code>app/js/controllers.js</code>：</p>
<pre><code>var phonecatControllers = angular.module('phonecatControllers', []);

...

phonecatControllers.controller('PhoneListCtrl', ['$scope', 'Phone', function($scope, Phone) {
  $scope.phones = Phone.query();
  $scope.orderProp = 'age';
}]);

phonecatControllers.controller('PhoneDetailCtrl', ['$scope', '$routeParams', 'Phone', function($scope, $routeParams, Phone) {
  $scope.phone = Phone.get({phoneId: $routeParams.phoneId}, function(phone) {
    $scope.mainImageUrl = phone.images[0];
  });

  $scope.setImage = function(imageUrl) {
    $scope.mainImageUrl = imageUrl;
  }
}]);
</code></pre>
<p>注意在<code>PhoneListCtrl</code>中我们使用：</p>
<pre><code>$scope.phones = Phone.query();
</code></pre>
<p>替代了：</p>
<pre><code>$http.get('phones/phones.json').success(function(data) {
  $scope.phones = data;
});
</code></pre>
<p>这是一个查询所有手机设备的简写。 这里有一个重点，就是我们在调用Phone服务的时候不会给它传入任何的回调函数。虽然结果看起来像是同步返回的一样，然而并不是。同步返回的实际上不是数据，而是“未来（Future）”——一个在XHR响应返回的时候将会被数据填充的对象。因为Angular的数据绑定特性，我们可以用这个“未来”对象给模板做绑定。那么在数据真正到来的时候，视图也就会自然而然地更新了。 有时候仅仅依靠这个未来的对象并不能完成我们想要的所有工作，因此在本例中，我们还是给它添加了一个回调参数来处理服务器响应。比如<code>PhoneDetailCtrl</code>，我们在回调函数中设置了<code>mainImageUrl</code>的值。</p>
<hr>
<h2 id="-5">测试 <a class="header-anchor" href="#-5" aria-hidden="true">&#128279;</a></h2>
<p>因为我们使用了ngResource模块，所以想要让测试通过的话就必须要更新一下Karma配置文件了：</p>
<p><code>test/karma.conf.js</code>：</p>
<pre><code>files : [
  'app/bower_components/angular/angular.js',
  'app/bower_components/angular-route/angular-route.js',
  'app/bower_components/angular-resource/angular-resource.js',
  'app/bower_components/angular-mocks/angular-mocks.js',
  'app/js/**/*.js',
  'test/unit/**/*.js'
],
</code></pre>
<p>我们修改了一下单元测试来验证新服务是否使用了HTTP请求并且是否工作正确。同时测试也会验证控制器与服务之间的连接是否正确。 <a style="line-height: 1.5;" href="https://docs.angularjs.org/api/ngResource/service/$resource">$resource</a>服务自动地给响应体添加了更新以及删除数据的方法。所以如果我们使用标准的<code>toEqual</code>匹配器的话，测试将会失败。这是因为测试数据并没有和响应体完全一模一样。为了解决这个问题，我们使用一个新定义的<code>toEqualData</code><a href="http://jasmine.github.io/1.3/introduction.html#section-Matchers">Jasmine匹配器</a>。<code>toEqualData</code>匹配器在比较两个对象的时候会只比较其属性而忽略对象所携带的方法。</p>
<p><code>test/unit/controllersSpec.js</code>：</p>
<pre><code>describe('PhoneCat controllers', function() {

  beforeEach(function(){
    this.addMatchers({
      toEqualData: function(expected) {
        return angular.equals(this.actual, expected);
      }
    });
  });

  beforeEach(module('phonecatApp'));
  beforeEach(module('phonecatServices'));


  describe('PhoneListCtrl', function(){
    var scope, ctrl, $httpBackend;

    beforeEach(inject(function(_$httpBackend_, $rootScope, $controller) {
      $httpBackend = _$httpBackend_;
      $httpBackend.expectGET('phones/phones.json').
          respond([{name: 'Nexus S'}, {name: 'Motorola DROID'}]);

      scope = $rootScope.$new();
      ctrl = $controller('PhoneListCtrl', {$scope: scope});
    }));


    it('should create &quot;phones&quot; model with 2 phones fetched from xhr', function() {
      expect(scope.phones).toEqualData([]);
      $httpBackend.flush();

      expect(scope.phones).toEqualData(
          [{name: 'Nexus S'}, {name: 'Motorola DROID'}]);
    });


    it('should set the default value of orderProp model', function() {
      expect(scope.orderProp).toBe('age');
    });
  });


  describe('PhoneDetailCtrl', function(){
    var scope, $httpBackend, ctrl,
        xyzPhoneData = function() {
          return {
            name: 'phone xyz',
            images: ['image/url1.png', 'image/url2.png']
          }
        };


    beforeEach(inject(function(_$httpBackend_, $rootScope, $routeParams, $controller) {
      $httpBackend = _$httpBackend_;
      $httpBackend.expectGET('phones/xyz.json').respond(xyzPhoneData());

      $routeParams.phoneId = 'xyz';
      scope = $rootScope.$new();
      ctrl = $controller('PhoneDetailCtrl', {$scope: scope});
    }));


    it('should fetch phone detail', function() {
      expect(scope.phone).toEqualData({});
      $httpBackend.flush();

      expect(scope.phone).toEqualData(xyzPhoneData());
    });
  });
});
</code></pre>
<p>现在你应该能在Karma终端内看到以下输出：</p>
<pre><code>Chrome 22.0: Executed 5 of 5 SUCCESS (0.038 secs / 0.01 secs)
</code></pre>
<h2 id="-6">总结 <a class="header-anchor" href="#-6" aria-hidden="true">&#128279;</a></h2>
<p>现在我们见识了如何构建一个自定义的服务来作为RESTful客户端，下一步<a href="/p/angular-tutorial-applying-animations/">step 12</a>（最后一步）我们将会学习如何让应用程序动起来（加点特效）。</p>
]]></description><pubDate>Tue Dec 29 2015 14:01:43 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/angular-tutorial-rest-and-custom-services</link><guid isPermaLink="true">https://blog.wxsm.space/p/angular-tutorial-rest-and-custom-services</guid></item><item><title>Angular 教程：事件处理</title><description><![CDATA[<p>在这一步中，你将给手机详细页面添加一个可点击的图片切换功能。</p>
<ul>
<li>手机列表视图现在显示了一张大图与几张较小的缩略图。当我们点击任意一张缩略图的时候大图都会被其取代。</li>
</ul>
<p>最重要的改动如下所示。你可以在<a href="https://github.com/angular/angular-phonecat/compare/step-9...step-10" title="See diff on Github">GitHub</a>上查看它与之前的代码有何区别。</p>
<hr>
<h2 id="">控制器 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h2>
<p><code>app/js/controllers.js</code>：</p>
<pre><code>...
var phonecatControllers = angular.module('phonecatControllers',[]);

phonecatControllers.controller('PhoneDetailCtrl', ['$scope', '$routeParams', '$http',
  function($scope, $routeParams, $http) {
    $http.get('phones/' + $routeParams.phoneId + '.json').success(function(data) {
      $scope.phone = data;
      $scope.mainImageUrl = data.images[0];
    });

    $scope.setImage = function(imageUrl) {
      $scope.mainImageUrl = imageUrl;
    };
  }]);
</code></pre>
<p>在<code>PhoneDetailCtrl</code>中，我们创建了<code>mainImageUrl</code>模型并把它的初始值设置为手机图片URL列表中的第一项。 同时我们也创建了一个<code>setImage</code>事件处理函数来改变<code>mainImageUrl</code>的值。</p>
<hr>
<h2 id="-2">模板 <a class="header-anchor" href="#-2" aria-hidden="true">&#128279;</a></h2>
<p><code>app/partials/phone-detail.html</code>：</p>
<pre><code>&lt;img ng-src=&quot;{{mainImageUrl}}&quot; class=&quot;phone&quot;&gt;

...

&lt;ul class=&quot;phone-thumbs&quot;&gt;
  &lt;li ng-repeat=&quot;img in phone.images&quot;&gt;
    &lt;img ng-src=&quot;{{img}}&quot; ng-click=&quot;setImage(img)&quot;&gt;
  &lt;/li&gt;
&lt;/ul&gt;
...
</code></pre>
<p>我们将<code>mainImageUrl</code>模型绑定到了大图的<code>ngSrc</code>指令上。 同时我们给缩略图注册了一个<code>ngClick</code>事件处理器。当用户点击其中一张缩略图的时候，处理器将使用<code>setImage</code>事件处理函数来动态地改变<code>mainImageUrl</code>的值。</p>
<hr>
<p> </p>
<h2 id="-3">测试 <a class="header-anchor" href="#-3" aria-hidden="true">&#128279;</a></h2>
<p>为了测试这项新功能，我们添加了两个端到端测试。其中一个用来验证大图在默认情况下是否设置成了所有图片中的第一张，另一个则用来验证当点击缩略图的时候大图是否正确地改变了。</p>
<p><code>test/e2e/scenarios.js</code>：</p>
<pre><code>...
  describe('Phone detail view', function() {

...

    it('should display the first phone image as the main phone image', function() {
      expect(element(by.css('img.phone')).getAttribute('src')).toMatch(/img\/phones\/nexus-s.0.jpg/);
    });


    it('should swap main image if a thumbnail image is clicked on', function() {
      element(by.css('.phone-thumbs li:nth-child(3) img')).click();
      expect(element(by.css('img.phone')).getAttribute('src')).toMatch(/img\/phones\/nexus-s.2.jpg/);

      element(by.css('.phone-thumbs li:nth-child(1) img')).click();
      expect(element(by.css('img.phone')).getAttribute('src')).toMatch(/img\/phones\/nexus-s.0.jpg/);
    });
  });
</code></pre>
<p>你可以通过执行<code>npm run protractor</code>来观察测试运行。 同时因为我们给<code>PhoneDetailCtrl</code>控制器添加了<code>mainImageUrl</code>模型，所以单元测试也需要做些重构。如下所示，为了让测试通过，我们创建了<code>xyzPhoneData</code>函数用来返回带<code>images</code>属性的正确的JSON数据。</p>
<p><code>test/unit/controllersSpec.js</code>：</p>
<pre><code>...
  beforeEach(module('phonecatApp'));

...

 describe('PhoneDetailCtrl', function(){
    var scope, $httpBackend, ctrl,
        xyzPhoneData = function() {
          return {
            name: 'phone xyz',
            images: ['image/url1.png', 'image/url2.png']
          }
        };


    beforeEach(inject(function(_$httpBackend_, $rootScope, $routeParams, $controller) {
      $httpBackend = _$httpBackend_;
      $httpBackend.expectGET('phones/xyz.json').respond(xyzPhoneData());

      $routeParams.phoneId = 'xyz';
      scope = $rootScope.$new();
      ctrl = $controller('PhoneDetailCtrl', {$scope: scope});
    }));


    it('should fetch phone detail', function() {
      expect(scope.phone).toBeUndefined();
      $httpBackend.flush();

      expect(scope.phone).toEqual(xyzPhoneData());
    });
  });
</code></pre>
<p>现在单元测试应该能通过了。</p>
<h2 id="-4">课外扩展 <a class="header-anchor" href="#-4" aria-hidden="true">&#128279;</a></h2>
<p>我们来给<code>PhoneDetailCtrl</code>添加一个新的控制方法：</p>
<pre><code>$scope.hello = function(name) {
    alert('Hello ' + (name || 'world') + '!');
}
</code></pre>
<p>并且给<code>phone-detail.html</code>模板添加：</p>
<pre><code>&lt;button ng-click=&quot;hello('Elmo')&quot;&gt;Hello&lt;/button&gt;
</code></pre>
<h2 id="-5">总结 <a class="header-anchor" href="#-5" aria-hidden="true">&#128279;</a></h2>
<p>现在我们已经完成了图片切换功能，可以通过<a href="/p/angular-tutorial-rest-and-custom-services/">step 11</a>来学习一种更好的抓取数据的方式。</p>
]]></description><pubDate>Tue Dec 29 2015 11:35:25 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/angular-tutorial-event-handlers</link><guid isPermaLink="true">https://blog.wxsm.space/p/angular-tutorial-event-handlers</guid></item><item><title>Angular 教程：过滤器</title><description><![CDATA[<p>在这一步中你将会学习如何创建自定义的过滤器。</p>
<ul>
<li>在上一步中，详细页面通过显示true或者false来表示一个手机是否具有某项功能。我们将使用一个自定义的过滤器来把这些字符串转换成图标：用✓表示true，用✘表示false</li>
</ul>
<p>最重要的改动如下所示。你可以在<a href="https://github.com/angular/angular-phonecat/compare/step-8...step-9" title="See diff on Github">GitHub</a>上查看它与之前的代码有何区别。</p>
<hr>
<h2 id="">自定义过滤器 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h2>
<p>为了创建新的过滤器，我们创建了一个<code>phonecatFilters</code>模块，并且将自定义的过滤器注册在这个模块下。</p>
<p><code>app/js/filters.js</code>：</p>
<pre><code>angular.module('phonecatFilters', []).filter('checkmark', function() {
  return function(input) {
    return input ? '\u2713' : '\u2718';
  };
});
</code></pre>
<p>过滤器的名字叫checkmark，<code>input</code>将被转换为<code>true</code>或者<code>false</code>，然后我们根据结果返回两个unicode编码字符中的其中之一。 现在过滤器已经准备好了，我们需要给<code>phonecatApp</code>主模块添加一项<code>phonecatFilters</code>模块的依赖。</p>
<p><code>app/js/app.js</code>：</p>
<pre><code>...
angular.module('phonecatApp', ['ngRoute','phonecatControllers','phonecatFilters']);
...
</code></pre>
<hr>
<h2 id="-2">模板 <a class="header-anchor" href="#-2" aria-hidden="true">&#128279;</a></h2>
<p>既然过滤器代码存在于<code>app/js/filters.js</code></p>
<p>文件内，我们就需要把它包含到布局模版中。</p>
<p><code>app/index.html</code>：</p>
<pre><code>...
 &lt;script src=&quot;js/controllers.js&quot;&gt;&lt;/script&gt;
 &lt;script src=&quot;js/filters.js&quot;&gt;&lt;/script&gt;
...
</code></pre>
<p>在Angualr中根据以下语法来使用过滤器：</p>
<pre><code>{{ expression | filter }}
</code></pre>
<p>现在我们来给手机详细模板添加过滤器：</p>
<p><code>app/partials/phone-detail.html</code>：</p>
<pre><code>...
    &lt;dl&gt;
      &lt;dt&gt;Infrared&lt;/dt&gt;
      &lt;dd&gt;{{phone.connectivity.infrared | checkmark}}&lt;/dd&gt;
      &lt;dt&gt;GPS&lt;/dt&gt;
      &lt;dd&gt;{{phone.connectivity.gps | checkmark}}&lt;/dd&gt;
    &lt;/dl&gt;
...
</code></pre>
<hr>
<h2 id="-3">测试 <a class="header-anchor" href="#-3" aria-hidden="true">&#128279;</a></h2>
<p>就像任何其它的组件一样，过滤器也应该要测一测。所幸的是编写这些测试是非常简单的事情。</p>
<p><code>test/unit/filtersSpec.js</code>：</p>
<pre><code>describe('filter', function() {

  beforeEach(module('phonecatFilters'));

  describe('checkmark', function() {

    it('should convert boolean values to unicode checkmark or cross',
        inject(function(checkmarkFilter) {
      expect(checkmarkFilter(true)).toBe('\u2713');
      expect(checkmarkFilter(false)).toBe('\u2718');
    }));
  });
});
</code></pre>
<p>在每一个过滤器测试执行以前我们都必须调用<code>beforeEach(module('phonecatFilters'))</code>，这个调用将<code>phonecatFilters</code>模块加载到了这些测试的注入器中。 需要注意的是我们调用了工具方法<code>inject(function(checkmarkFilter) { ... })</code>来获取需要被测试的过滤器。参考<a href="https://docs.angularjs.org/api/ngMock/function/angular.mock.inject">angular.mock.inject()</a> 与此同时我们也注意到Filter后缀被追加到了我们定义的过滤器名字之后。参考<a href="https://docs.angularjs.org/guide/filter#using-filters-in-controllers-services-and-directives">Filter Guide</a>来获取与此有关的信息。 你现在应该能在Karma控制台中看到如下输出：</p>
<pre><code>Chrome 22.0: Executed 4 of 4 SUCCESS (0.034 secs / 0.012 secs)
</code></pre>
<h2 id="-4">课外扩展 <a class="header-anchor" href="#-4" aria-hidden="true">&#128279;</a></h2>
<p>我们来试试给<code>index.html</code>中的绑定添加一些<a href="https://docs.angularjs.org/api/ng/filter">Angular的内置过滤器</a>吧：</p>
<ul>
<li><code>{{ &quot;lower cap string&quot; | uppercase }}</code></li>
<li><code>{{ {foo: &quot;bar&quot;, baz: 23} | json }}</code></li>
<li><code>{{ 1304375948024 | date }}</code></li>
<li><code>{{ 1304375948024 | date:&quot;MM/dd/yyyy @ h:mma&quot; }}</code></li>
</ul>
<p>与此同时我们也可以创建一个带有输入框的模型，然后给它添加一个带过滤器的绑定：</p>
<pre><code>&lt;input ng-model=&quot;userInput&quot;&gt; Uppercased: {{ userInput | uppercase }}
</code></pre>
<h2 id="-5">总结 <a class="header-anchor" href="#-5" aria-hidden="true">&#128279;</a></h2>
<p>现在我们学会了如何编写和测试自定义的过滤器，通过<a href="/p/angular-tutorial-event-handlers/">step 10</a>来学习如何使用Angular扩展手机详细页面。</p>
]]></description><pubDate>Tue Dec 29 2015 09:12:33 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/angular-tutorial-filters</link><guid isPermaLink="true">https://blog.wxsm.space/p/angular-tutorial-filters</guid></item><item><title>Angular 教程：更多的模板</title><description><![CDATA[<p>在这一步中，你将实现当用户点击手机列表中的一条记录时显示的详细视图。</p>
<ul>
<li>当你点击列表中的一条记录时，页面会显示一个带有该记录详细信息的视图</li>
</ul>
<p>为了实现这个目标，我们使用<a href="https://docs.angularjs.org/api/ng/service/$http">$http</a>来抓取数据并刷新<code>phone-detail.html</code>视图模板。 最重要的改动如下所示。你可以在<a href="https://github.com/angular/angular-phonecat/compare/step-7...step-8" title="See diff on Github">GitHub</a>上查看它与之前的代码有何区别。</p>
<hr>
<h2 id="">数据 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h2>
<p>除了<code>phones.json</code>以外，<code>app/phones/</code>目录还包含了每台手机设备详细信息的JSON文件：</p>
<p><code>app/phones/nexus-s.json</code>：</p>
<pre><code>{
  &quot;additionalFeatures&quot;: &quot;Contour Display, Near Field Communications (NFC),...&quot;,
  &quot;android&quot;: {
      &quot;os&quot;: &quot;Android 2.3&quot;,
      &quot;ui&quot;: &quot;Android&quot;
  },
  ...
  &quot;images&quot;: [
      &quot;img/phones/nexus-s.0.jpg&quot;,
      &quot;img/phones/nexus-s.1.jpg&quot;,
      &quot;img/phones/nexus-s.2.jpg&quot;,
      &quot;img/phones/nexus-s.3.jpg&quot;
  ],
  &quot;storage&quot;: {
      &quot;flash&quot;: &quot;16384MB&quot;,
      &quot;ram&quot;: &quot;512MB&quot;
  }
}
</code></pre>
<p>这些文件使用了同样的格式来为手机设备描述一些各种各样的属性。我们会在详细视图中展现它们。</p>
<hr>
<h2 id="-2">控制器 <a class="header-anchor" href="#-2" aria-hidden="true">&#128279;</a></h2>
<p>我们扩展了<code>PhoneDetailCtrl</code>控制器，在其中使用<code>$http</code>服务来抓取JSON文件，就跟获取手机列表的方式一模一样：</p>
<p><code>app/js/controllers.js</code>：</p>
<pre><code>var phonecatControllers = angular.module('phonecatControllers',[]);

phonecatControllers.controller('PhoneDetailCtrl', ['$scope', '$routeParams', '$http',
  function($scope, $routeParams, $http) {
    $http.get('phones/' + $routeParams.phoneId + '.json').success(function(data) {
      $scope.phone = data;
    });
  }]);
</code></pre>
<p>为了构建HTTP请求的URL，我们使用到了<code>$route</code>服务从当前路由中提取到的<code>$routeParams.phoneId</code></p>
<hr>
<h2 id="-3">模板 <a class="header-anchor" href="#-3" aria-hidden="true">&#128279;</a></h2>
<p>之前临时加入的TBD模板现在被一些包含手机详细信息的列表与绑定取代了。注意我们是如何使用Angular表达式以及<code>ngRepeat</code>来将手机数据从模型映射到视图上的。</p>
<p><code>app/partials/phone-detail.html</code>：</p>
<pre><code>&lt;img ng-src=&quot;{{phone.images[0]}}&quot; class=&quot;phone&quot;&gt;

&lt;h1&gt;{{phone.name}}&lt;/h1&gt;

&lt;p&gt;{{phone.description}}&lt;/p&gt;

&lt;ul class=&quot;phone-thumbs&quot;&gt;
  &lt;li ng-repeat=&quot;img in phone.images&quot;&gt;
    &lt;img ng-src=&quot;{{img}}&quot;&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ul class=&quot;specs&quot;&gt;
  &lt;li&gt;
    &lt;span&gt;Availability and Networks&lt;/span&gt;
    &lt;dl&gt;
      &lt;dt&gt;Availability&lt;/dt&gt;
      &lt;dd ng-repeat=&quot;availability in phone.availability&quot;&gt;{{availability}}&lt;/dd&gt;
    &lt;/dl&gt;
  &lt;/li&gt;
    ...
  &lt;li&gt;
    &lt;span&gt;Additional Features&lt;/span&gt;
    &lt;dd&gt;{{phone.additionalFeatures}}&lt;/dd&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<hr>
<h2 id="-4">测试 <a class="header-anchor" href="#-4" aria-hidden="true">&#128279;</a></h2>
<p>我们为<code>PhoneListCtrl</code>编写了一个类似于step 5的单元测试。</p>
<p><code>test/unit/controllersSpec.js</code>：</p>
<pre><code>beforeEach(module('phonecatApp'));

  ...

  describe('PhoneDetailCtrl', function(){
    var scope, $httpBackend, ctrl;

    beforeEach(inject(function(_$httpBackend_, $rootScope, $routeParams, $controller) {
      $httpBackend = _$httpBackend_;
      $httpBackend.expectGET('phones/xyz.json').respond({name:'phone xyz'});

      $routeParams.phoneId = 'xyz';
      scope = $rootScope.$new();
      ctrl = $controller('PhoneDetailCtrl', {$scope: scope});
    }));


    it('should fetch phone detail', function() {
      expect(scope.phone).toBeUndefined();
      $httpBackend.flush();

      expect(scope.phone).toEqual({name:'phone xyz'});
    });
  });
...
</code></pre>
<p>你现在应该可以在Karma终端看到以下输出：</p>
<pre><code>Chrome 22.0: Executed 3 of 3 SUCCESS (0.039 secs / 0.012 secs)
</code></pre>
<p>同时我们也添加了一个端到端测试，验证当页面跳转到Nexus S详细视图的时候页头是不是真的显示了Nexus S</p>
<p><code>test/e2e/scenarios.js</code>：</p>
<pre><code>...
  describe('Phone detail view', function() {

    beforeEach(function() {
      browser.get('app/index.html#/phones/nexus-s');
    });


    it('should display nexus-s page', function() {
      expect(element(by.binding('phone.name')).getText()).toBe('Nexus S');
    });
  });
...
</code></pre>
<p>你可以通过执行<code>npm run protractor</code>来观察测试运行。</p>
<h2 id="-5">课外扩展 <a class="header-anchor" href="#-5" aria-hidden="true">&#128279;</a></h2>
<p>使用<a href="http://angular.github.io/protractor/#/api">Protractor API</a>编写一个测试，验证我们在Nexus S详细页上显示了4张标题图片。</p>
<h2 id="-6">总结 <a class="header-anchor" href="#-6" aria-hidden="true">&#128279;</a></h2>
<p>现在手机详细视图已经到位了，在<a href="/p/angular-tutorial-filters/">step 9</a>中我们将学习如何编写自定义的过滤器。</p>
]]></description><pubDate>Tue Dec 29 2015 08:44:23 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/angular-tutorial-more-templating</link><guid isPermaLink="true">https://blog.wxsm.space/p/angular-tutorial-more-templating</guid></item><item><title>Angular 教程：多页面与路由</title><description><![CDATA[<p>在这一步中，你将学习如何使用布局模版以及通过Angular的<code>ngRoute</code>模块来给应用添加路由功能。</p>
<ul>
<li>当你现在访问<code>app/index.html</code>的时候页面被重定向到了<code>app/index.html/#/phones</code>，并且手机列表将在此展示</li>
<li>当你点击其中一条手机链接的时候，浏览器将显示一个手机详细信息页面，同时URL相应地更新</li>
</ul>
<p>最重要的改动如下所示。你可以在<a href="https://github.com/angular/angular-phonecat/compare/step-6...step-7" title="See diff on Github">GitHub</a>上查看它与之前的代码有何区别。</p>
<hr>
<h2 id="">依赖 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h2>
<p>这一步中添加的路由功能是由Angular的<code>ngRoute</code>模块提供的，该模块没有包含在Angular框架的核心内容中。 我们使用<a href="http://bower.io/">Bower</a>来安装客户端依赖。更新<code>bower.json</code>配置文件来包含新的依赖：</p>
<pre><code>{
  &quot;name&quot;: &quot;angular-phonecat&quot;,
  &quot;description&quot;: &quot;A starter project for AngularJS&quot;,
  &quot;version&quot;: &quot;0.0.0&quot;,
  &quot;homepage&quot;: &quot;https://github.com/angular/angular-phonecat&quot;,
  &quot;license&quot;: &quot;MIT&quot;,
  &quot;private&quot;: true,
  &quot;dependencies&quot;: {
    &quot;angular&quot;: &quot;1.4.x&quot;,
    &quot;angular-mocks&quot;: &quot;1.4.x&quot;,
    &quot;jquery&quot;: &quot;~2.1.1&quot;,
    &quot;bootstrap&quot;: &quot;~3.1.1&quot;,
    &quot;angular-route&quot;: &quot;1.4.x&quot;
  }
}
</code></pre>
<p>新的依赖项<code>&quot;angular-route&quot;: &quot;1.4.x&quot;</code>会告诉Bower去安装1.4.x版本的angular-route组件。我们必须使用Bower来下载以及安装该组件。 如果你已经全局安装了bower，你可以使用<code>bower install</code>指令。但在这个项目中我们有预设的指令来完成相同的事情：</p>
<pre><code>npm install
</code></pre>
<hr>
<h2 id="-2">多视图，路由以及布局模板 <a class="header-anchor" href="#-2" aria-hidden="true">&#128279;</a></h2>
<p>我们的应用慢慢地成长并开始变得复杂起来了。在这一步之前，应用提供给用户的只有一个视图（所有手机的列表），并且所有模板代码都在<code>index.html</code>文件中。现在我们将要给应用添加一个显示列表中手机细节的视图。</p>
<p>为了添加细节视图，我们可以扩展<code>index.html</code>视图以包含新的模板代码，但这么做的话项目很快就会变得异常糟糕。所以我们将要做的是把<code>index.html</code>变成一个“布局模版”。这个模板可以理解为应用程序中所有其它模板的母版，至于其它的“局部模板”则将根据当前的“路由”（当前展示给用户的视图）选择性地加载到母版中来。</p>
<p>Angular的应用路由是由<a href="https://docs.angularjs.org/api/ngRoute/provider/$routeProvider">$routeProvider</a>声明的，它是<a href="https://docs.angularjs.org/api/ngRoute/service/$route">$route</a>服务的提供者。这个服务的目的是让控制器，视图模版以及当前浏览器URL地址之间的连接变得更简单一些。我们可以使用这个功能来实现<a href="http://en.wikipedia.org/wiki/Deep_linking">深度链接</a>，从而允许用户使用浏览器的前进后退以及书签等功能。</p>
<h2 id="-3">依赖注入，注入器和提供者 <a class="header-anchor" href="#-3" aria-hidden="true">&#128279;</a></h2>
<p>正如我们所知，依赖注入（DI）是AngularJS的核心，所以对其工作原理稍加理解是很有必要的。 在应用程序被引导的时候，Angular会创建一个注入器，它会寻找并且注入所有被应用程序所需求的服务。注入器本身完全不知道诸如<code>$http</code>或者<code>$route</code>的服务具体做了些什么。实际上，在被正确配置之前，注入器甚至不知道这些服务是否存在。 注入器只是按部就班地做了以下事情：</p>
<ul>
<li>读取应用所声明的模块</li>
<li>注册所有在模块声明中定义的提供者（Provider）</li>
<li>当需要的时候，给模块注入指定的函数以及任何需要的依赖（服务），它们将被提供者懒加载</li>
</ul>
<p>提供者是一个提供（创建）服务实例并且暴露配置接口以控制服务的创建过程与实际行为的对象。对于<code>$route</code>服务而言，<code>$routeProvider</code>暴露的API允许你为自己的应用定义路由。</p>
<blockquote>
<p>注意：提供者只能够注入到<code>config</code>函数内。因此你不能给<code>PhoneListCtrl</code>注入<code>$routeProvider</code></p>
</blockquote>
<p>Angular模块通过移除应用的全局状态以及提供配置注入器的方法来解决以上问题。与AMD或者require.js截然相反的是，Angular模块并没有尝试去解决脚本加载顺序以及脚本懒加载的问题。这些目标都是完全独立的，同时所有的模块系统都能共存并且实现它们的目标。 查看<a href="https://github.com/angular/angular.js/wiki/Understanding-Dependency-Injection">理解依赖注入</a>来深入了解Angular的DI系统。</p>
<hr>
<h2 id="-4">模板 <a class="header-anchor" href="#-4" aria-hidden="true">&#128279;</a></h2>
<p><code>$route</code>服务通常结合<a href="https://docs.angularjs.org/api/ngRoute/directive/ngView">ngView</a>指令使用。<code>ngView</code>指令的作用是根据当前路由将视图模版加载到布局模板中去。</p>
<blockquote>
<p>注意：从Angular 1.2版本开始，<code>ngRoute</code>作为一个独立的模块，必须要额外加载<code>angular-route.js</code>文件，我们刚才已经通过Bower下载了它</p>
</blockquote>
<p><code>app/index.html</code>：</p>
<pre><code>&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot; ng-app=&quot;phonecatApp&quot;&gt;
&lt;head&gt;
...
  &lt;script src=&quot;bower_components/angular/angular.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;bower_components/angular-route/angular-route.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;js/app.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;js/controllers.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

  &lt;div ng-view&gt;&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>我们给index模板添加了两个<code>&lt;script&gt;</code>标签来为应用程序加载JavaScript文件：</p>
<ul>
<li><code>angular-route.js</code>：定义了Angular的<code>ngRoute</code>模块，它将给我们提供路由功能</li>
<li><code>app.js</code>：这个文件现在将担任应用的路由模块</li>
</ul>
<p>需要注意的是我们把之前<code>index.html</code>模板中的大部分代码都移除了，取而代之的只有一个带有<code>ng-view</code>标签的div元素。移除的代码被移动到了<code>phone-list.html</code>模板中去：</p>
<p><code>app/partials/phone-list.html</code>：</p>
<pre><code>&lt;div class=&quot;container-fluid&quot;&gt;
  &lt;div class=&quot;row&quot;&gt;
    &lt;div class=&quot;col-md-2&quot;&gt;
      &lt;!--Sidebar content--&gt;

      Search: &lt;input ng-model=&quot;query&quot;&gt;
      Sort by:
      &lt;select ng-model=&quot;orderProp&quot;&gt;
        &lt;option value=&quot;name&quot;&gt;Alphabetical&lt;/option&gt;
        &lt;option value=&quot;age&quot;&gt;Newest&lt;/option&gt;
      &lt;/select&gt;

    &lt;/div&gt;
    &lt;div class=&quot;col-md-10&quot;&gt;
      &lt;!--Body content--&gt;

      &lt;ul class=&quot;phones&quot;&gt;
        &lt;li ng-repeat=&quot;phone in phones | filter:query | orderBy:orderProp&quot; class=&quot;thumbnail&quot;&gt;
          &lt;a href=&quot;#/phones/{{phone.id}}&quot; class=&quot;thumb&quot;&gt;&lt;img ng-src=&quot;{{phone.imageUrl}}&quot;&gt;&lt;/a&gt;
          &lt;a href=&quot;#/phones/{{phone.id}}&quot;&gt;{{phone.name}}&lt;/a&gt;
          &lt;p&gt;{{phone.snippet}}&lt;/p&gt;
        &lt;/li&gt;
      &lt;/ul&gt;

    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>同时我们给手机详细视图临时添加了一个简单的模板：</p>
<p><code>app/partials/phone-detail.html</code>：</p>
<pre><code>TBD: detail view for &lt;span&gt;{{phoneId}}&lt;/span&gt;
</code></pre>
<p>需要注意的是我们使用了<code>phoneId</code>表达式，这将在<code>PhoneDetailCtrl</code>中定义。</p>
<hr>
<h2 id="app">App模块 <a class="header-anchor" href="#app" aria-hidden="true">&#128279;</a></h2>
<p>为了完善应用程序的架构，我们使用了<code>ngRoute</code>模块，并且将控制器都移动到了它们自己所属的模块<code>phonecatControllers</code>内（如下所示）。 我们给<code>index.html</code>添加了一个<code>angular-route.js</code>引用，同时在<code>controllers.js</code> 中创建了一个新的<code>phonecatControllers</code> 模块。但我们所要做的将不仅限于此。我们需要给应用添加模块依赖。通过在phonecatApp中列出这两个模块作为依赖，我们就可以使用它们提供的指令和服务了。</p>
<p><code>app/js/app.js</code>：</p>
<pre><code>var phonecatApp = angular.module('phonecatApp', [
  'ngRoute',
  'phonecatControllers'
]);

...
</code></pre>
<p>注意传入到<code>angular.module</code>方法中的第二个参数<code>['ngRoute', 'phonecatControllers']</code>，这个数组中列出的是<code>phonecatApp</code>将要依赖到的模块。</p>
<pre><code>...

phonecatApp.config(['$routeProvider',
  function($routeProvider) {
    $routeProvider.
      when('/phones', {
        templateUrl: 'partials/phone-list.html',
        controller: 'PhoneListCtrl'
      }).
      when('/phones/:phoneId', {
        templateUrl: 'partials/phone-detail.html',
        controller: 'PhoneDetailCtrl'
      }).
      otherwise({
        redirectTo: '/phones'
      });
  }]);
</code></pre>
<p>在<code>phonecatApp.config()</code>方法中，我们请求给配置方法注入<code>$routeProvider</code>，并使用<code>$routeProvider.when()</code>方法来定义我们的路由。 我们的应用路由定义如下：</p>
<ul>
<li><code>when('/phones')</code>：当URL匹配到<code>/phones</code>时，页面将会显示手机列表视图。Angular会使用<code>phone-list.html</code>模板和<code>PhoneListCtrl</code>控制器来构造这个它</li>
<li><code>when('/phones/:phoneId')</code>：当URL匹配到<code>/phones/:phoneId</code>（<code>:phoneId</code>是URL的一个参数）时，页面将会显示手机详细视图。 Angular会使用<code>phone-detail.html</code>模板和<code>PhoneDetailCtrl</code>来构造它</li>
<li><code>otherwise({redirectTo: '/phones'})</code>：当浏览器地址没有匹配上我们定义的路由时重定向到<code>/phones</code></li>
</ul>
<p>我们复用了在前面的教程中构建的<code>PhoneListCtrl</code>控制器，并且在<code>app/js/controllers.js</code>文件中为手机详细视图创建了一个空白的<code>PhoneDetailCtrl</code>控制器。 注意在第二条路由定义中使用到的<code>:phoneId</code>参数。<code>$route</code>服务会将<code>/phones/:phoneId</code>声明当成一个模板来使用。所有使用<code>:</code>前缀声明的变量都会被提取到<code>$routeParams</code>对象中去。</p>
<hr>
<h2 id="-5">控制器 <a class="header-anchor" href="#-5" aria-hidden="true">&#128279;</a></h2>
<p><code>app/js/controllers.js</code>：</p>
<pre><code>var phonecatControllers = angular.module('phonecatControllers', []);

phonecatControllers.controller('PhoneListCtrl', ['$scope', '$http',
  function ($scope, $http) {
    $http.get('phones/phones.json').success(function(data) {
      $scope.phones = data;
    });

    $scope.orderProp = 'age';
  }]);

phonecatControllers.controller('PhoneDetailCtrl', ['$scope', '$routeParams',
  function($scope, $routeParams) {
    $scope.phoneId = $routeParams.phoneId;
  }]);
</code></pre>
<p>注意到我们创建了一个名为<code>phonecatControllers</code>的新模块。对一些小型AngularJS应用而言或许一个模块就够用了，但是随着应用的增长，将代码重构到不同的模块中去是非常普遍的做法。对大型应用来说，你很可能会为应用的每一个主要功能都创建不同的模块。 因为我们的教学应用相对来说比较小，所以我们把所有的控制器添加到<code>phonecatControllers</code>模块中就完事了。</p>
<hr>
<h2 id="-6">测试 <a class="header-anchor" href="#-6" aria-hidden="true">&#128279;</a></h2>
<p>为了验证应用的正确性，我们编写了一些端到端测试来验证当URL发生变化时应用是否渲染了正确的视图。</p>
<pre><code>...
   it('should redirect index.html to index.html#/phones', function() {
    browser.get('app/index.html');
    browser.getLocationAbsUrl().then(function(url) {
        expect(url).toEqual('/phones');
      });
  });

  describe('Phone list view', function() {
    beforeEach(function() {
      browser.get('app/index.html#/phones');
    });
...

  describe('Phone detail view', function() {

    beforeEach(function() {
      browser.get('app/index.html#/phones/nexus-s');
    });


    it('should display placeholder page with phoneId', function() {
      expect(element(by.binding('phoneId')).getText()).toBe('nexus-s');
    });
  });
</code></pre>
<p>你可以通过执行<code>npm run protractor</code>来观察测试运行</p>
<h2 id="-7">课外扩展 <a class="header-anchor" href="#-7" aria-hidden="true">&#128279;</a></h2>
<p>尝试给<code>index.html</code>添加一个<code>{{orderProp}}</code>绑定，你会发现即使正处在手机列表视图中它也没有引发任何改变。这是因为<code>orderProp</code>模型只在<code>PhoneListCtrl</code>管理的作用域中可见。如果你把同样的绑定添加到<code>phone-list.html</code>模板内它就会如预期一般地工作了。</p>
<h2 id="-8">总结 <a class="header-anchor" href="#-8" aria-hidden="true">&#128279;</a></h2>
<p>既然已经设置好了路由与手机列表视图，我们就可以准备通过<a href="/p/angular-tutorial-more-templating/">step 8</a>来实现详细视图了。</p>
]]></description><pubDate>Mon Dec 28 2015 20:26:38 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/angular-tutorial-routing-and-multiple-views</link><guid isPermaLink="true">https://blog.wxsm.space/p/angular-tutorial-routing-and-multiple-views</guid></item><item><title>Angular 教程：模板化的链接与图片</title><description><![CDATA[<p>在这一步中你将学习给手机列表添加一个图片链接（暂时不会链接到其他地方）。随后你将使用链接来给手机列表显示一些附加的信息。</p>
<ul>
<li>列表中现在包含图片与链接了</li>
</ul>
<p>最重要的改动如下所示。你可以在<a href="https://github.com/angular/angular-phonecat/compare/step-5...step-6" title="See diff on Github">GitHub</a>上查看它与之前的代码有何区别。</p>
<hr>
<h2 id="">数据 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h2>
<p>需要注意的是<code>phones.json</code>文件中每条手机记录都包含了ID与图片URL，URL指向的是<code>app/img/phones/</code>目录。</p>
<p><code>app/phones/phones.json</code>：</p>
<pre><code>[
  {
    ...
    &quot;id&quot;: &quot;motorola-defy-with-motoblur&quot;,
    &quot;imageUrl&quot;: &quot;img/phones/motorola-defy-with-motoblur.0.jpg&quot;,
    &quot;name&quot;: &quot;Motorola DEFY\u2122 with MOTOBLUR\u2122&quot;,
    ...
  },
  ...
]
</code></pre>
<hr>
<h2 id="-2">模板 <a class="header-anchor" href="#-2" aria-hidden="true">&#128279;</a></h2>
<p><code>app/index.html</code> ：</p>
<pre><code>...
        &lt;ul class=&quot;phones&quot;&gt;
          &lt;li ng-repeat=&quot;phone in phones | filter:query | orderBy:orderProp&quot; class=&quot;thumbnail&quot;&gt;
            &lt;a href=&quot;#/phones/{{phone.id}}&quot; class=&quot;thumb&quot;&gt;&lt;img ng-src=&quot;{{phone.imageUrl}}&quot;&gt;&lt;/a&gt;
            &lt;a href=&quot;#/phones/{{phone.id}}&quot;&gt;{{phone.name}}&lt;/a&gt;
            &lt;p&gt;{{phone.snippet}}&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
...
</code></pre>
<p>动态生成的链接以后将会链接到手机的详细信息页面，我们使用了熟悉的双花括号来给<code>href</code>属性添加绑定。</p>
<p>在step 2中，我们使用了<code>{{phone.name}}</code>来绑定元素内容。在这一步中<code>{{phone.id}}</code>将作为元素属性的绑定。 同时我们也使用<code>&lt;img&gt;</code>标签以及<a href="https://docs.angularjs.org/api/ng/directive/ngSrc">ngSrc</a>指令给每一条手机记录添加了一张图片。这个指令的目的是防止浏览器将Angular表达式按照字面意思去读取，然后发起一个错误的请求URL <a href="http://localhost:8000/app/%7B%7Bphone.imageUrl%7D%7D">http://localhost:8000/app/{{phone.imageUrl}}</a>（比如我们这样写<code>&lt;img src=&quot;{{phone.imageUrl}}&quot;&gt;</code>）。使用<code>ngSrc</code>指令可以防止浏览器向错误的地址发起请求。</p>
<hr>
<h2 id="-3">测试 <a class="header-anchor" href="#-3" aria-hidden="true">&#128279;</a></h2>
<p><code>test/e2e/scenarios.js</code>：</p>
<pre><code>...
    it('should render phone specific links', function() {
      var query = element(by.model('query'));
      query.sendKeys('nexus');
      element.all(by.css('.phones li a')).first().click();
      browser.getLocationAbsUrl().then(function(url) {
        expect(url).toBe('/phones/nexus-s');
      });
    });
...
</code></pre>
<p>我们给端到端测试添加了一项新的内容来验证应用生成了正确的链接。我们将会在接下来的步骤中实现它们。 你可以通过执行<code>npm run protractor</code>来观察测试运行。</p>
<h2 id="-4">课外扩展 <a class="header-anchor" href="#-4" aria-hidden="true">&#128279;</a></h2>
<p>将<code>ng-src</code>替换成原始的<code>src</code>属性，通过一些开发工具（比如Firebug或者Chrome开发者工具）来观察应用是否发起了错误的请求，比如说<code>/app/%7B%7Bphone.imageUrl%7D%7D</code>或者<code>/app/{{phone.imageUrl}}</code>造成这个问题的原因是浏览器会在读取到<code>&lt;img&gt;</code>标签的瞬间就向其地址发起请求，这时候Angular都还没有来得及计算表达式的结果呢。</p>
<h2 id="-5">总结 <a class="header-anchor" href="#-5" aria-hidden="true">&#128279;</a></h2>
<p>现在我们给列表添加了图片和连接，通过<a href="/p/angular-tutorial-routing-and-multiple-views/">step 7</a>来学习Angular的布局模板以及Angular是如何让创建多页面应用变得简单的。</p>
]]></description><pubDate>Mon Dec 28 2015 15:46:08 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/angular-tutorial-templating-links-and-images</link><guid isPermaLink="true">https://blog.wxsm.space/p/angular-tutorial-templating-links-and-images</guid></item><item><title>Angular 教程：异步加载和依赖注入</title><description><![CDATA[<p>我已经受够了用hard-coded数据来写应用。。。现在我们来尝试使用Angular提供的<a href="https://docs.angularjs.org/api/ng/service/$http">$http</a>服务来从后台抓取一个大一点的数据集。我们会使用<a href="https://docs.angularjs.org/guide/di">依赖注入</a>的方式来给<code>PhoneListCtrl</code>控制器提供<a href="https://docs.angularjs.org/guide/services">服务</a>。</p>
<ul>
<li>现在页面上有一个从服务端获取的包含20台手机设备的列表</li>
</ul>
<p>最重要的改动如下所示。你可以在<a href="https://github.com/angular/angular-phonecat/compare/step-4...step-5" title="See diff on Github">GitHub</a>上查看它与之前的代码有何区别。</p>
<hr>
<h2 id="">数据 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h2>
<p>项目中的<code>app/phones/phones.json</code>文件是一个使用JSON格式储存的包含更多手机数据的数据集。如下是其中的一段：</p>
<pre><code>[
 {
  &quot;age&quot;: 13,
  &quot;id&quot;: &quot;motorola-defy-with-motoblur&quot;,
  &quot;name&quot;: &quot;Motorola DEFY\u2122 with MOTOBLUR\u2122&quot;,
  &quot;snippet&quot;: &quot;Are you ready for everything life throws your way?&quot;
  ...
 },
...
]
</code></pre>
<hr>
<h2 id="-2">控制器 <a class="header-anchor" href="#-2" aria-hidden="true">&#128279;</a></h2>
<p>我们通过使用Angular的<code>$http</code>服务来向服务端发送HTTP请求并且获取<code>app/phones/phones.json</code>文件中的数据。<code>$http</code>只是Angular内置的处理一般任务的众多服务的其中之一。当你需要使用它们的时候Angular会将它们注入到你需要的地方去。 服务（Service）是由Angular的<a href="https://docs.angularjs.org/guide/di">依赖注入系统</a>管理的。依赖注入可以帮助我们更科学地构造应用程序（比如说把组件分为视图，数据与模型），以及让耦合度更低（各组件之间的依赖不是由组件自身去解决的，而是通过依赖注入系统）。</p>
<p><code>app/js/controllers.js</code>：</p>
<pre><code>var phonecatApp = angular.module('phonecatApp', []);

phonecatApp.controller('PhoneListCtrl', function ($scope, $http) {
  $http.get('phones/phones.json').success(function(data) {
    $scope.phones = data;
  });

  $scope.orderProp = 'age';
});
</code></pre>
<p><code>$http</code>会向服务器发送一次HTTP GET请求，请求的内容是<code>phones/phones.json</code>（url是相对于<code>index.html</code>文件的）。服务器通过提供文件中的数据来做出响应（当然响应数据也可以是由服务器动态生成的，对我们来说看到的都是一样的结果，在这个教程中考虑到简单性我们就直接使用了一个json文件）。<code>$http</code>方法返回了一个带<code>success</code>方法的<a href="https://docs.angularjs.org/api/ng/service/$q">Promise</a>对象。我们通过调用这个方法来处理异步响应并且把数据交付给控制器之下的作用域，一个叫<code>phones</code>的数组。需要注意的是Angular会检测到响应类型是JSON并且为我们自动转换数据类型。 当需要使用一个Angular服务的时候，我们只需要声明我们需要的服务名并且把它们作为参数传入到控制器中去即可，如下：</p>
<pre><code>phonecatApp.controller('PhoneListCtrl', function ($scope, $http) {...}
</code></pre>
<p>Angular依赖注入器会在控制器初始化的时候提供服务，同时也会照顾到服务所依赖的服务（服务通常会依赖于其它的服务）。</p>
<p><img src="https://raw.githubusercontent.com/wxsms/wxsms-img-holder/master/tutorial_05.png" alt=""></p>
<h3 id="-3">$前缀命名转换 <a class="header-anchor" href="#-3" aria-hidden="true">&#128279;</a></h3>
<p>你可以创建自定义的服务（实际上在本教程的step 11中将要这么做）。作为一种命名之间的转换，Angular的内置服务，比如scope以及其它的一些API名字中有一个<code>$</code>前缀。</p>
<p><code>$</code>前缀存在的意义是为了区分Angular所提供的内置服务。为了不引起冲突，最好不要给自定义的模型或者服务等任何东西加上<code>$</code>前缀。</p>
<p>如果你深入查看scope服务的话，你会发现一些属性使用了<code>$$</code>前缀。这些属性应当被认为是私有变量，你不应该尝试去读取或者修改它们。</p>
<h3 id="-4">最小化的注意事项 <a class="header-anchor" href="#-4" aria-hidden="true">&#128279;</a></h3>
<p>鉴于Angular依靠辨别控制器中函数构造器的参数名字来完成依赖注入，如果你将<code>PhoneListCtrl</code>控制器的JavaScript代码最小化的话，则与此同时函数的参数也会被最小化，因此依赖注入器就无法正确地识别这些注入声明了。 我们可以通过在声明函数的同时也声明依赖名来解决这个问题（提供不会被最小化的字符串）。目前有两种方式来做到这一点：</p>
<ul>
<li>给控制器创建一个包含字符串数组的<code>$inject</code>属性。数组中的每一个字符串代表着一个相应的将要被注入的服务名。如下所示：</li>
</ul>
<pre><code>function PhoneListCtrl($scope, $http) {...}
PhoneListCtrl.$inject = ['$scope', '$http'];
phonecatApp.controller('PhoneListCtrl', PhoneListCtrl);
</code></pre>
<ul>
<li>使用内联声明，在原先提供控制器函数的地方提供一个数组。数组包含一连串的服务名，最后则是函数本身：</li>
</ul>
<pre><code>function PhoneListCtrl($scope, $http) {...}
phonecatApp.controller('PhoneListCtrl', ['$scope', '$http', PhoneListCtrl]);
</code></pre>
<p>以上两种方法对Angular来说都是一样的，所以实际使用哪一种取决于你项目的风格就可以了。 当使用第二种方法的时候，一般情况下会用匿名函数构造器来内联地注册控制器：</p>
<pre><code>phonecatApp.controller('PhoneListCtrl', ['$scope', '$http', function($scope, $http) {...}]);
</code></pre>
<p>根据以上的观点，我们对<code>PhoneListCtrl</code>做了如下改动。</p>
<p><code>app/js/controllers.js</code>：</p>
<pre><code>var phonecatApp = angular.module('phonecatApp', []);

phonecatApp.controller('PhoneListCtrl', ['$scope', '$http',
  function ($scope, $http) {
    $http.get('phones/phones.json').success(function(data) {
      $scope.phones = data;
    });

    $scope.orderProp = 'age';
  }]);
</code></pre>
<hr>
<h2 id="-5">测试 <a class="header-anchor" href="#-5" aria-hidden="true">&#128279;</a></h2>
<p>因为我们开始使用依赖注入并且控制器也有所依赖了，所以在测试中构造相同的控制器变得稍微麻烦了一些。我们可以通过给它<code>new</code>一个假的<code>$http</code>实现。然而，Angular已经给我们的单元测试提供了一位<code>$http</code>演员。我们通过使用<code>$httpBackend</code>服务中提供的方法来配置一个假的服务器响应。</p>
<p><code>test/unit/controllersSpec.js</code>：</p>
<pre><code>describe('PhoneCat controllers', function() {

describe('PhoneListCtrl', function(){
  var scope, ctrl, $httpBackend;

  // Load our app module definition before each test.
  beforeEach(module('phonecatApp'));

  // The injector ignores leading and trailing underscores here (i.e. _$httpBackend_).
  // This allows us to inject a service but then attach it to a variable
  // with the same name as the service in order to avoid a name conflict.
  beforeEach(inject(function(_$httpBackend_, $rootScope, $controller) {
    $httpBackend = _$httpBackend_;
    $httpBackend.expectGET('phones/phones.json').
        respond([{name: 'Nexus S'}, {name: 'Motorola DROID'}]);

    scope = $rootScope.$new();
    ctrl = $controller('PhoneListCtrl', {$scope: scope});
  }));
</code></pre>
<p>注意：因为我们在测试环境中加载了Jasmine和<code>angular-mocks.js</code>，所以可以使用<a href="https://docs.angularjs.org/api/ngMock/function/angular.mock.module">module</a>以及<a href="https://docs.angularjs.org/api/ngMock/function/angular.mock.inject">inject</a>方法来接入/配置注入器。 我们根据以下方法在测试环境中创建控制器：</p>
<ul>
<li>我们使用<code>inject</code>方法将<a href="https://docs.angularjs.org/api/ng/service/$rootScope">$rootScope</a>，<a href="https://docs.angularjs.org/api/ng/service/$controller">$controller</a>和<a href="https://docs.angularjs.org/api/ng/service/$httpBackend">$httpBackend</a>服务实例注入到Jasmine的<code>beforeEach</code>方法内。这些实例来自于每次测试前都临时创建的注入器。这保证了每个测试都将处于同样的起跑线上并且测试结果不会相互影响</li>
<li>我们使用<code>$rootScope.$new()</code>方法给控制器创建了一个新的作用域（scope）</li>
<li>我们调用了注入的<code>$controller</code>函数，给它传入了控制器的名字<code>PhoneListCtrl</code>以及创建好的scope作为参数</li>
</ul>
<p>目前的代码使用了<code>$http</code>服务来获取手机列表数据，因此在创建<code>PhoneListCtrl</code>子作用域之前，我们需要告诉测试代码去期望一个来自控制器的请求：</p>
<ul>
<li>给<code>beforeEach</code>方法注入<code>$httpBackend</code>服务。这个服务可以看成是原服务的一个演员，来扮演生产环境中发生的XHR以及JSONP请求。这个演员可以使测试代码避免与真正的API与全局状态发生关联，两者都将对测试造成不可预知的影响</li>
<li>使用<code>$httpBackend.expectGET</code>方法来告诉<code>$httpBackend</code>服务去期待一个将要到来的HTTP请求并且告诉它如何回复。注意的是在我们调用<code>$httpBackend.flush</code>方法以前它是不会真正做出响应的</li>
</ul>
<p>现在我们可以下一个断言了，在获得响应之前<code>scope</code>作用域中不会存在<code>phones</code>模型：</p>
<pre><code>it('should create &quot;phones&quot; model with 2 phones fetched from xhr', function() {
  expect(scope.phones).toBeUndefined();
  $httpBackend.flush();

  expect(scope.phones).toEqual([{name: 'Nexus S'},
                               {name: 'Motorola DROID'}]);
});
</code></pre>
<ul>
<li>我们调用<code>$httpBackend.flush()</code>方法将浏览器中的请求队列处理了。这将导致<code>$http</code>服务返回的promise对象被训练过的响应解决。通过<a href="https://docs.angularjs.org/api/ngMock/service/$httpBackend">mock $httpBackend</a>文档来查看为什么这一步是必须的</li>
<li>我们同时下了验证<code>phone</code>模型存在的断言</li>
</ul>
<p>最后，我们来验证<code>orderProp</code>的默认值是正确的：</p>
<pre><code>it('should set the default value of orderProp model', function() {
  expect(scope.orderProp).toBe('age');
});
</code></pre>
<p>你现在应该能从Karma终端中看到如下输入：</p>
<pre><code>Chrome 22.0: Executed 2 of 2 SUCCESS (0.028 secs / 0.007 secs)
</code></pre>
<h2 id="-6">课外扩展 <a class="header-anchor" href="#-6" aria-hidden="true">&#128279;</a></h2>
<p>在<code>index.html</code>的底部添加如下绑定来查看json格式的数据：</p>
<pre><code>&lt;pre&gt;{{phones | filter:query | orderBy:orderProp | json}}&lt;/pre&gt;
</code></pre>
<p>在<code>PhoneListCtrl</code>中，对HTTP响应做一些预处理，将手机数量限制为从头开始的5条记录。在<code>$http</code>回调中添加如下代码：</p>
<pre><code>$scope.phones = data.splice(0, 5);
</code></pre>
<h2 id="-7">总结 <a class="header-anchor" href="#-7" aria-hidden="true">&#128279;</a></h2>
<p>现在你知道使用Angular服务是多么简单的一件事了（这得感谢Angular的依赖注入）。在<a href="/p/angular-tutorial-templating-links-and-images/">step 6</a>中你将会学习的是如何给手机列表添加一些图片和连接。</p>
]]></description><pubDate>Mon Dec 28 2015 15:01:49 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/angular-tutorial-xhrs-and-dependency-injection</link><guid isPermaLink="true">https://blog.wxsm.space/p/angular-tutorial-xhrs-and-dependency-injection</guid></item><item><title>Angular 教程：双向绑定</title><description><![CDATA[<p>在这一步中，你将会通过添加一个新的模型变量给手机列表增加一个动态排序功能 。这个功能通过给循环器添加一个新的属性实现，然后让数据绑定来自动完成其余的工作。</p>
<ul>
<li>现在除了搜索框，应用还显示了一个允许用户对手机列表进行排序的下拉框</li>
</ul>
<!--more--> 最重要的改动如下所示。你可以在
<p><a href="https://github.com/angular/angular-phonecat/compare/step-3...step-4" title="See diff on Github">GitHub</a>上查看它与之前的代码有何区别。</p>
<hr>
<h2 id="">模板 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h2>
<p><code>app/index.html</code>：</p>
<pre><code>Search: &lt;input ng-model=&quot;query&quot;&gt;
Sort by:
&lt;select ng-model=&quot;orderProp&quot;&gt;
  &lt;option value=&quot;name&quot;&gt;Alphabetical&lt;/option&gt;
  &lt;option value=&quot;age&quot;&gt;Newest&lt;/option&gt;
&lt;/select&gt;


&lt;ul class=&quot;phones&quot;&gt;
  &lt;li ng-repeat=&quot;phone in phones | filter:query | orderBy:orderProp&quot;&gt;
    &lt;span&gt;{{phone.name}}&lt;/span&gt;
    &lt;p&gt;{{phone.snippet}}&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>我们对<code>index.html</code>模板进行了如下修改：</p>
<ul>
<li>首先，我们在HTML中添加了一个名叫<code>orderProp</code>的<code>&lt;select&gt;</code>节点，然后用户才能选择他们想要的排序方式</li>
<li>然后我们把<code>orderBy</code>过滤器串联到了<code>filter</code>过滤器的后面，它可以对循环器的输入再做进一步的处理。<code>orderBy</code>过滤器会接受一个输入数组，复制并且返回排序后的副本</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wxsms/wxsms-img-holder/master/tutorial_04.png" alt=""></p>
<p>Angular为选中的元素与<code>orderProp</code>模型创建了一个双向的数据绑定。<code>orderProp</code>于是就作为了<code>orderBy</code>过滤器的一个输入。 正如我们在Step 3中讨论过的有关数据绑定与循环器的内容，无论模型在何时发生变化（比如用户改变下拉框的值），Angular的数据绑定都会引起视图的自动刷新。我们再也不用编写任何臃肿的DOM维护代码了！</p>
<hr>
<h2 id="-2">控制器 <a class="header-anchor" href="#-2" aria-hidden="true">&#128279;</a></h2>
<p><code>app/js/controllers.js</code>：</p>
<pre><code>var phonecatApp = angular.module('phonecatApp', []);

phonecatApp.controller('PhoneListCtrl', function ($scope) {
  $scope.phones = [
    {'name': 'Nexus S',
     'snippet': 'Fast just got faster with Nexus S.',
     'age': 1},
    {'name': 'Motorola XOOM™ with Wi-Fi',
     'snippet': 'The Next, Next Generation tablet.',
     'age': 2},
    {'name': 'MOTOROLA XOOM™',
     'snippet': 'The Next, Next Generation tablet.',
     'age': 3}
  ];

  $scope.orderProp = 'age';
});
</code></pre>
<ul>
<li>我们对<code>phones</code>模型（就是这个数组）稍微做了些改变，并且给每条记录添加了一个<code>age</code>属性，这个属性是用来排序的</li>
<li>在最下面的一行我们把默认的排序方式设置成了<code>age</code>。如果我们不在这里设置一个默认值，那么在用户选择一个排序方式以前<code>orderBy</code>过滤器都不会被初始化</li>
</ul>
<p>现在我们可以说说双向的数据绑定了。注意当应用在浏览器中加载的时候，下拉列表就已经选中了 Newest 项。这是因为我们在控制器中把<code>orderProp</code>属性的值设置为了<code>age</code>，因此从模型到视图的方向发生了一次绑定。如果你现在选择<code>Alphabetically</code>项的话，模型也会跟着视图发生改变，并且手机列表也会重新进行排序。这就是一次反方向的数据绑定：从视图到模型。</p>
<hr>
<h2 id="-3">测试 <a class="header-anchor" href="#-3" aria-hidden="true">&#128279;</a></h2>
<p>现在我们更新一下单元测试和端到端测试，首先看看单元测试：</p>
<p><code>test/unit/controllersSpec.js</code>：</p>
<pre><code>describe('PhoneCat controllers', function() {

  describe('PhoneListCtrl', function(){
    var scope, ctrl;

    beforeEach(module('phonecatApp'));

    beforeEach(inject(function($controller) {
      scope = {};
      ctrl = $controller('PhoneListCtrl', {$scope:scope});
    }));

    it('should create &quot;phones&quot; model with 3 phones', function() {
      expect(scope.phones.length).toBe(3);
    });


    it('should set the default value of orderProp model', function() {
      expect(scope.orderProp).toBe('age');
    });
  });
});
</code></pre>
<p>单元测试现在会验证是否设置了一个默认的排序属性。 我们在<code>beforeEach</code>中使用Jasmine的API来构造控制器，因此在父级<code>describe</code>代码块下的所有测试都能共享它。 你应该可以从Karma终端中看到如下结果：</p>
<pre><code>Chrome 22.0: Executed 2 of 2 SUCCESS (0.021 secs / 0.001 secs)
</code></pre>
<p>再来看端到端测试：</p>
<p><code>test/e2e/scenarios.js</code>：</p>
<pre><code>...
it('should be possible to control phone order via the drop down select box', function() {

  var phoneNameColumn = element.all(by.repeater('phone in phones').column('phone.name'));
  var query = element(by.model('query'));

  function getNames() {
    return phoneNameColumn.map(function(elm) {
      return elm.getText();
    });
  }

  query.sendKeys('tablet'); //let's narrow the dataset to make the test assertions shorter

  expect(getNames()).toEqual([
    &quot;Motorola XOOM\u2122 with Wi-Fi&quot;,
    &quot;MOTOROLA XOOM\u2122&quot;
  ]);

  element(by.model('orderProp')).element(by.css('option[value=&quot;name&quot;]')).click();

  expect(getNames()).toEqual([
    &quot;MOTOROLA XOOM\u2122&quot;,
    &quot;Motorola XOOM\u2122 with Wi-Fi&quot;
  ]);
});...
</code></pre>
<p>端到端测试验证了排序的结果是否正确。 你可以执行<code>npm run protractor</code>来观察测试的运行。</p>
<h2 id="-4">课外扩展 <a class="header-anchor" href="#-4" aria-hidden="true">&#128279;</a></h2>
<p>在<code>PhoneListCtrl</code>控制器中尝试把初始化<code>orderProp</code>的代码给删除掉，你可以看到Angular会给下拉列表临时添加一个空白的选项作为默认值，并且手机列表会暂时处于原始的排序状态下。 给<code>index.html</code>添加一个<code>{{orderProp}}</code>绑定来观察它的值是如何变化的。 通过给排序值添加一个<code>-</code>号来使排序反向进行：</p>
<pre><code>&lt;option value=&quot;-age&quot;&gt;Oldest&lt;/option&gt;
</code></pre>
<h2 id="-5">总结 <a class="header-anchor" href="#-5" aria-hidden="true">&#128279;</a></h2>
<p>现在你已经给应用添加了一个排序功能以及相应的测试，快快通过<a href="/p/angular-tutorial-xhrs-and-dependency-injection/">step 5</a>来学习Angular服务（Service）以及如何使用Angular的依赖注入。</p>
]]></description><pubDate>Sat Dec 26 2015 18:01:24 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/angular-tutorial-two-way-data-binding</link><guid isPermaLink="true">https://blog.wxsm.space/p/angular-tutorial-two-way-data-binding</guid></item><item><title>Angular 教程：过滤循环器</title><description><![CDATA[<p>在上一步中我们花了大量精力去给应用搭建框架，所以现在来做些简单的事情：给列表添加一个关键词搜索（真的很简单）。同时我们会编写一个端到端测试，它将一直监控着我们的应用并且及时发现问题。</p>
<ul>
<li>应用现在包含一个搜索框。需要注意的是页面上显示的手机列表现在与搜索框中的输入内容有关。</li>
</ul>
<p>最重要的改动如下所示。你可以在<a href="https://github.com/angular/angular-phonecat/compare/step-2...step-3" title="See diff on Github">GitHub</a>上查看它与之前的代码有何区别。</p>
<hr>
<h2 id="">控制器 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h2>
<p>控制器没有发生任何变化。</p>
<hr>
<h2 id="-2">模板 <a class="header-anchor" href="#-2" aria-hidden="true">&#128279;</a></h2>
<p><code>app/index.html</code>：</p>
<pre><code>&lt;div class=&quot;container-fluid&quot;&gt;
  &lt;div class=&quot;row&quot;&gt;
    &lt;div class=&quot;col-md-2&quot;&gt;
      &lt;!--Sidebar content--&gt;

      Search: &lt;input ng-model=&quot;query&quot;&gt;

    &lt;/div&gt;
    &lt;div class=&quot;col-md-10&quot;&gt;
      &lt;!--Body content--&gt;

      &lt;ul class=&quot;phones&quot;&gt;
        &lt;li ng-repeat=&quot;phone in phones | filter:query&quot;&gt;
          {{phone.name}}
          &lt;p&gt;{{phone.snippet}}&lt;/p&gt;
        &lt;/li&gt;
      &lt;/ul&gt;

    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>我们给页面添加了一个标准的 HTML 输入框<code>&lt;input&gt;</code>，然后使用 Angular 的过滤（filter）功能结合用户输入来对 ngRepeat 指令进行处理。<span style="line-height: 1.5;">这允许用户输入搜索关键词然后即时地在手机列表中看到结果。</span></p>
<p><span style="line-height: 1.5;">新添加的代码做了如下示范：</span></p>
<ul>
<li>数据绑定：Angular 的核心特色之一。当页面加载的时候，Angular 会将输入框的值绑定到一个有着与其相同名字的数据模型上并且保持两者之间的同步。在这段代码中，用户在输入框中输入的数据（名为<code>query</code>）会即时地成为列表循环中的过滤器（<code>phone in phones | filter:query</code>）。数据的改动影响到循环器的输入，然后循环器根据模型的实时状态来更新 DOM</li>
<li><code>filter</code>过滤器的使用：<a href="https://docs.angularjs.org/api/ng/filter/filter">filter</a> 功能使用<code>query</code>的值来创建一个由只包含匹配<code>query</code>的记录组成的新数组</li>
</ul>
<p><code>ngRepeat</code>在<code>filter</code>过滤器返回的数组改变之时会自动更新视图，这之中的过程对开发者来说是完全不可见的。</p>
<p><img src="https://raw.githubusercontent.com/wxsms/wxsms-img-holder/master/tutorial_03.png" alt=""></p>
<hr>
<h2 id="-3">测试 <a class="header-anchor" href="#-3" aria-hidden="true">&#128279;</a></h2>
<p>在上一步中，我们学习了如何编写和执行单元测试。</p>
<p>单元测试对应用中的使用 JavaScript 编写的控制器和其它部件可以很好地发挥作用，但是不能测试 DOM 的修改以及应用整体逻辑。对这些情况，端到端测试是更好的选择。</p>
<p>既然搜索功能是完全通过模板与数据绑定实现的，我们就开始编写一个端到端测试来验证它是否正确地工作：</p>
<p><code>test/e2e/scenarios.js</code>：</p>
<pre><code>describe('PhoneCat App', function() {

  describe('Phone list view', function() {

    beforeEach(function() {
      browser.get('app/index.html');
    });


    it('should filter the phone list as a user types into the search box', function() {

      var phoneList = element.all(by.repeater('phone in phones'));
      var query = element(by.model('query'));

      expect(phoneList.count()).toBe(3);

      query.sendKeys('nexus');
      expect(phoneList.count()).toBe(1);

      query.clear();
      query.sendKeys('motorola');
      expect(phoneList.count()).toBe(2);
    });
  });
});
</code></pre>
<p>这个测试验证了搜索框与循环器之间连接的正确性。同样，十分简洁。</p>
<h3 id="protractor">使用 Protractor 执行端到端测试 <a class="header-anchor" href="#protractor" aria-hidden="true">&#128279;</a></h3>
<p>虽然这个测试看起来很像是使用 Jasmine 为控制器编写的单元测试，但端到端测试使用的是 <a href="https://github.com/angular/protractor">Protractor</a> 提供的 API，可以从这里获取更多信息： <a href="http://angular.github.io/protractor/#/api">http://angular.github.io/protractor/#/api</a></p>
<p>就像 Karma 是单元测试的执行者一样，我们使用 Protractor 来执行端到端测试。尝试使用<code>npm run protractor</code>来运行它。</p>
<p>端到端测试是比较慢的，因此不像单元测试，Protractor 会在测试结束后退出，并且不会在文件发生变化时自动重启。使用<code>npm run protractor</code>来重新执行测试。</p>
<blockquote>
<p>注意：在使用 Protractor 执行测试的时候必须保证应用运行在 Web 服务器下。你可以使用<code>npm start</code>启动服务器。你也必须保证在运行<code>npm run protractor</code>之前已经安装了 Protractor 并且更新了相关驱动。通过在终端中输入<code>npm install</code>和<code>npm run update-webdriver</code>来完成以上事情。</p>
</blockquote>
<h2 id="-4">课外扩展 <a class="header-anchor" href="#-4" aria-hidden="true">&#128279;</a></h2>
<h3 id="query">实时显示 Query 的值 <a class="header-anchor" href="#query" aria-hidden="true">&#128279;</a></h3>
<p>通过给<code>index.html</code>模板添加一个<code>{{query}}</code>绑定来实时显示<code>query</code>模型的值，看看它在用户输入的时候是如何发生变化的。</p>
<h3 id="query-2">在标题中显示 Query <a class="header-anchor" href="#query-2" aria-hidden="true">&#128279;</a></h3>
<p>我们来看看如何让<code>query</code>的值实时地显示在 HTML 页面标题（Title）上。</p>
<ul>
<li>给<code>describe</code>代码块添加一个端到端测试，现在<code>test/e2e/scenarios.js</code>长这样：</li>
</ul>
<pre><code>describe('PhoneCat App', function() {

  describe('Phone list view', function() {

    beforeEach(function() {
      browser.get('app/index.html');
    });

    var phoneList = element.all(by.repeater('phone in phones'));
    var query = element(by.model('query'));

    it('should filter the phone list as a user types into the search box', function() {
      expect(phoneList.count()).toBe(3);

      query.sendKeys('nexus');
      expect(phoneList.count()).toBe(1);

      query.clear();
      query.sendKeys('motorola');
      expect(phoneList.count()).toBe(2);
    });

    it('should display the current filter value in the title bar', function() {
      query.clear();
      expect(browser.getTitle()).toMatch(/Google Phone Gallery:\s*$/);

      query.sendKeys('nexus');
      expect(browser.getTitle()).toMatch(/Google Phone Gallery: nexus$/);
    });
  });
});
</code></pre>
<p>执行 Protractor（<code>npm run protractor</code>）可以发现测试失败了。</p>
<ul>
<li>你可能觉得直接给<code>&lt;title&gt;</code>标签加个<code>{{query}}</code>就好了：</li>
</ul>
<pre><code>&lt;title&gt;Google Phone Gallery: {{query}}&lt;/title&gt;
</code></pre>
<p>然而，当你刷新页面的时候，你不会看到预期的结果。因为“query”模型只能活在定义在<code>&lt;body&gt;</code>标签下的<code>ng-controller=&quot;PhoneListCtrl&quot;</code>的作用域中：</p>
<pre><code>&lt;body ng-controller=&quot;PhoneListCtrl&quot;&gt;
</code></pre>
<p>如果你想要把 query 模型绑定到<code>&lt;title&gt;</code>标签上去，你必须把<code>ngController</code>的声明<strong>移动</strong>到<code>&lt;html&gt;</code>标签上，因为它是<code>&lt;body&gt;</code>和<code>&lt;title&gt;</code>标签共同的祖先节点：</p>
<pre><code>&lt;html ng-app=&quot;phonecatApp&quot; ng-controller=&quot;PhoneListCtrl&quot;&gt;
</code></pre>
<p>同时，记得把<code>&lt;body&gt;</code>上定义的<code>ng-controller</code>指令<strong>删除</strong>。</li></p>
<ul>
<li>重新执行<code>npm run protractor</code>就可以发现测试通过了</li>
<li>当在 title 节点中使用双花括号感觉还不错的情况下，你可能会发现，在页面还处于加载中的短暂时间内它们直接地就打印到用户的浏览器中去了。使用 <a href="https://docs.angularjs.org/api/ng/directive/ngBind">ngBind</a> 或者 <a href="https://docs.angularjs.org/api/ng/directive/ngBindTemplate">ngBindTemplate</a> 将会是一种更好的选择，它们在页面加载的过程中不会显示任何东西：</li>
</ul>
<pre><code>&lt;title ng-bind-template=&quot;Google Phone Gallery: {{query}}&quot;&gt;Google Phone Gallery&lt;/title&gt;
</code></pre>
<h2 id="-5">总结 <a class="header-anchor" href="#-5" aria-hidden="true">&#128279;</a></h2>
<p>现在我们给应用添加了一个关键词搜索框并且包含了一个保证其功能正确的测试。现在我们可以前往 <a href="/p/angular-tutorial-two-way-data-binding/">step 4</a> 来学习如何给手机应用添加排序功能。</p>
]]></description><pubDate>Fri Dec 25 2015 17:09:58 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/angular-tutorial-filtering-repeaters</link><guid isPermaLink="true">https://blog.wxsm.space/p/angular-tutorial-filtering-repeaters</guid></item><item><title>Angular 教程：动态模版</title><description><![CDATA[<p>现在我们可以用 AngularJS 把页面变成动态的了，同时使用一个小测试来验证我们将要添加的代码正确性。 一个应用可以有很多种组织形式，对于 Angular 应用来说，使用 MVC 设计模式来解耦代码应该是比较合适的。接下来我们会使用一小点 Angular/JavaScript 代码来给应用添加模型，视图以及控制器。</p>
<ul>
<li>手机设备列表现在是由动态数据生成的了</li>
</ul>
<p>最重要的改动如下所示。你可以在 <a href="https://github.com/angular/angular-phonecat/compare/step-1...step-2" title="See diff on Github">GitHub</a> 上查看它与之前的代码有何区别。</p>
<hr>
<h2 id="">视图与模板 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h2>
<p>在 Angular 世界中，<strong>视图</strong>可以理解为<strong>模型</strong>在 HTML **模板 **上的投影。这意味着无论模型在何时发生变化，Angular 都会通过刷新被影响的绑定节点来更新视图。</p>
<p>视图现在由以下 Angular 模板组成：</p>
<p><code>app/index.html</code>：</p>
<pre><code>&lt;html ng-app=&quot;phonecatApp&quot;&gt;
&lt;head&gt;
  ...
  &lt;script src=&quot;bower_components/angular/angular.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;js/controllers.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body ng-controller=&quot;PhoneListCtrl&quot;&gt;

  &lt;ul&gt;
    &lt;li ng-repeat=&quot;phone in phones&quot;&gt;
      &lt;span&gt;{{phone.name}}&lt;/span&gt;
      &lt;p&gt;{{phone.snippet}}&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ul&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>现在 Hard Code 的手机列表被 <a href="https://docs.angularjs.org/api/ng/directive/ngRepeat">ngRepeat</a> 指令以及两条 <a href="https://docs.angularjs.org/guide/expression">Angular表达式</a> 替代了：</p>
<ul>
<li><code>&lt;li&gt;</code>元素中的<code>ng-repeat=&quot;phone in phones&quot;</code>是 Angular 的循环指令。它会告诉 Angular 为 ‘phones’ 中的每个 ‘phone’ 使用<code>&lt;li&gt;</code>元素中的模板来创建一个<code>&lt;li&gt;</code>元素</li>
<li>被双花括号包围的表达式（<code>{{phone.name}}</code>与<code>{{phone.snippet}}</code>）会被表达式得出的值所替代</li>
</ul>
<p>我们给<code>&lt;body&gt;</code>元素添加了一个名叫<code>ng-controller</code>的新指令，这会将<code>PhoneListCtrl</code>控制器关联到<code>&lt;body&gt;</code>节点中，此时：</p>
<ul>
<li>双花括号中的表达式（<code>{{phone.name}}</code>与<code>{{phone.snippet}}</code>）将与<code>PhoneListCtrl</code>控制器中建立的模型绑定</li>
</ul>
<p>注意：我们使用<code>ng-app=&quot;phonecatApp&quot;</code>指定了一个名为<code>phonecatApp</code>的 <a href="https://docs.angularjs.org/api/ng/type/angular.Module">Angular模块</a>，这个模块中将包含<code>PhoneListCtrl</code>控制器。</p>
<p><img src="https://raw.githubusercontent.com/wxsms/wxsms-img-holder/master/tutorial_02.png" alt=""></p>
<hr>
<h2 id="-2">模型与控制器 <a class="header-anchor" href="#-2" aria-hidden="true">&#128279;</a></h2>
<p>数据<strong>模型</strong>（一个由对象组成的简单数组）现在在<code>PhoneListCtrl</code><strong>控制器</strong>内被初始化了。<strong>控制器</strong>是一个简单的、带<code>$scope</code>参数的函数构造器。</p>
<p><code>app/js/controllers.js</code>：</p>
<pre><code>var phonecatApp = angular.module('phonecatApp', []);

phonecatApp.controller('PhoneListCtrl', function ($scope) {
  $scope.phones = [
    {'name': 'Nexus S',
     'snippet': 'Fast just got faster with Nexus S.'},
    {'name': 'Motorola XOOM™ with Wi-Fi',
     'snippet': 'The Next, Next Generation tablet.'},
    {'name': 'MOTOROLA XOOM™',
     'snippet': 'The Next, Next Generation tablet.'}
  ];
});
</code></pre>
<p>在此我们定义了一个名为<code>PhoneListCtrl</code></p>
<p>的控制器，同时在 Angular 模块中注册它。注意我们在<code>&lt;html&gt;</code></p>
<p>标签上定义的<code>ng-app</code></p>
<p>指令现在为这个 Angular 应用指定了引导模块为<code>phonecatApp</code>模块。</p>
<p>虽然这个控制器此时并没有做什么事情，但是它起着至关重要的作用。这个控制器通过提供数据模型的上下文来允许我们在模型与视图中创建数据绑定。</p>
<ul>
<li><code>&lt;body&gt;</code>标签上的 <a href="https://docs.angularjs.org/api/ng/directive/ngController">ngController</a> 指令引用了控制器的名字：<code>PhoneListCtrl</code>（在<code>controllers.js</code>文件中）</li>
<li><code>PhoneListCtrl</code>将手机数据附加到被注入进来的<code>$scope</code>上。scope 是在应用程序被定义时创建的根作用域的一个后代。这个控制器的作用域对<code>&lt;body ng-controller=&quot;PhoneListCtrl&quot;&gt;</code>标签内的所有绑定都是有效的。</li>
</ul>
<h3 id="-3">作用域 <a class="header-anchor" href="#-3" aria-hidden="true">&#128279;</a></h3>
<p>在 Angular 中作用域的概念很关键。</p>
<p>作用域可以视为使模板，模型以及控制器在一起工作的粘合剂。Angular 使用作用域以及模板，模型，控制器中所包含的信息来保持模型与视图的分离与同步。任何对模型的改动都会反映到视图上；任何对视图的改变也会反映到模型上。 通过 <a href="https://docs.angularjs.org/api/ng/type/$rootScope.Scope">Angular作用域文档</a> 来学习更多关于作用域的知识。</p>
<hr>
<h2 id="-4">测试 <a class="header-anchor" href="#-4" aria-hidden="true">&#128279;</a></h2>
<p>Angular 分离控制器与视图的方式使得测试代码将更容易编写。如果控制器是可以通过全局命名空间访问的，我们就可以简单地使用一个<code>scope</code>演员对象来实例化它：</p>
<pre><code>describe('PhoneListCtrl', function(){

  it('should create &quot;phones&quot; model with 3 phones', function() {
    var scope = {},
        ctrl = new PhoneListCtrl(scope);

    expect(scope.phones.length).toBe(3);
  });

});
</code></pre>
<p>这个测试实例化了<code>PhoneListCtrl</code>，并且通过验证作用域中包含 3 条记录来验证了手机数组的正确性。代码十分简洁。</p>
<h3 id="-5">测试非全局的控制器 <a class="header-anchor" href="#-5" aria-hidden="true">&#128279;</a></h3>
<p>一般来说，没有人会想要把控制器直接挂载到全局命名空间上。</p>
<p>实际上你可以看到我们把通过使用一个匿名函数构造器把它注册在了<code>phonecatApp</code>模块下。 在这个例子中，Angular 提供了一个名为<code>$controller</code>的服务，它将为你根据名字获取到相应的控制器。以下是通过<code>$controller</code>完成的与之前相同的测试：</p>
<p><code>test/unit/controllersSpec.js</code>：</p>
<pre><code>describe('PhoneListCtrl', function(){

  beforeEach(module('phonecatApp'));

  it('should create &quot;phones&quot; model with 3 phones', inject(function($controller) {
    var scope = {},
        ctrl = $controller('PhoneListCtrl', {$scope:scope});

    expect(scope.phones.length).toBe(3);
  }));

});
</code></pre>
<ul>
<li>在每一次测试之前我们都告诉 Angular 要加载<code>phonecatApp</code>模块</li>
<li>告诉 Angular 要为测试方法注入<code>$controller</code>服务</li>
<li>使用<code>$controller</code>来实例化<code>PhoneListCtrl</code></li>
<li>通过这个实例，我们就可以验证手机数组的正确性了</li>
</ul>
<h3 id="-6">编写和执行测试 <a class="header-anchor" href="#-6" aria-hidden="true">&#128279;</a></h3>
<p>Angular 开发者偏好于使用 Jasmine’s Behavior-driven Development (BDD) 框架来编写测试。虽然 Angular 并没有要求使用 Jasmine，我们还是使用 Jasmine v1.3 来编写了教程中的所有测试。</p>
<p>你可以从 <a href="http://jasmine.github.io/">Jasmine主页</a> 以及 <a href="http://jasmine.github.io/1.3/introduction.html">Jasmine文档</a> 中学习 Jasmine</p>
<p>Angular-seed 项目使用 <a href="http://karma-runner.github.io/">Karma</a> 来执行单元测试，你可以通过执行<code>npm install</code>来确保 Karma 以及它所必须的插件都已经被安装。</p>
<p>使用<code>npm test</code>来执行单元测试并且监听文件的改动：</p>
<ul>
<li>Karma 会自动启动新的 Chrome 和 Firefox 浏览器进程，忽略并且让它们在后台运行就好了。Karma 会使用这些浏览器来执行测试</li>
<li>如果你只安装了 Chrome 或者 Firefox 的其中一款浏览器，请在运行测试前修改 Karma 配置文件。找到<code>test/karma.conf.js</code>，并且修改其中的<code>browsers</code>属性，比如说你只安装了 Chrome：</li>
</ul>
<pre><code>...
  browsers: ['Chrome'],
  ...
</code></pre>
<ul>
<li>你将在终端中看到类似以下的输出，可以发现测试通过了（或者并没有）：</li>
</ul>
<pre><code>info: Karma server started at http://localhost:9876/
  info (launcher): Starting  browser &quot;Chrome&quot;
  info (Chrome 22.0): Connected on socket id tPUm9DXcLHtZTKbAEO-n
  Chrome 22.0: Executed 1 of 1 SUCCESS (0.093 secs / 0.004 secs)
</code></pre>
<ul>
<li>如果想要重新执行一遍测试，只需要修改任意源代码或者<code>test.js</code>文件即可。Karma 会监听到改动然后重新执行测试。这一定很贴心吧~</li>
</ul>
<blockquote>
<p>当 Karma 启动的时候务必不要将浏览器窗口最小化。在一些操作系统中，分配给最小化的浏览器的内存是有限的，这会导致 Karma 的执行速度非常慢。</p>
</blockquote>
<h2 id="-7">课外扩展 <a class="header-anchor" href="#-7" aria-hidden="true">&#128279;</a></h2>
<p>尝试给<code>index.html</code>再添加些绑定，比如说：</p>
<pre><code>&lt;p&gt;Total number of phones: {{phones.length}}&lt;/p&gt;
</code></pre>
<p>在控制器中创建一个新的属性并且将它绑定到模板上，比如说：</p>
<pre><code>$scope.name = &quot;World&quot;;
</code></pre>
<p>然后给<code>index.html</code>添加绑定：</p>
<pre><code>&lt;p&gt;Hello, {{name}}!&lt;/p&gt;
</code></pre>
<p>刷新浏览器，看看它说的是不是“Hello, World!”</p>
<p>更新单元测试<code>./test/unit/controllersSpec.js</code>来映射上一步的改动，比如说：</p>
<pre><code>expect(scope.name).toBe('World');
</code></pre>
<p>给<code>index.html</code>添加一个循环器来构造一个简单的表格：</p>
<pre><code>&lt;table&gt;
  &lt;tr&gt;&lt;th&gt;row number&lt;/th&gt;&lt;/tr&gt;
  &lt;tr ng-repeat=&quot;i in [0, 1, 2, 3, 4, 5, 6, 7]&quot;&gt;&lt;td&gt;{{i}}&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
</code></pre>
<p>现在通过在绑定中给i加1来把表格变成从 1 开始的：</p>
<pre><code>&lt;table&gt;
  &lt;tr&gt;&lt;th&gt;row number&lt;/th&gt;&lt;/tr&gt;
  &lt;tr ng-repeat=&quot;i in [0, 1, 2, 3, 4, 5, 6, 7]&quot;&gt;&lt;td&gt;{{i+1}}&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
</code></pre>
<p>附加题：</p>
<p>尝试使用嵌套的<code>ng-repeat</code>来创建一个 8×8 的表格。</p>
<p>将<code>expect(scope.phones.length).toBe(3)</code>改成<code>toBe(4)</code>看看单元测试是不是没有通过。</p>
<h2 id="-8">总结 <a class="header-anchor" href="#-8" aria-hidden="true">&#128279;</a></h2>
<p>你现在拥有了一个 MVC 构造形态的动态应用了，并且在开发过程中编写了单元测试。现在我们可以通过 <a href="/p/angular-tutorial-filtering-repeaters/">step 3</a> 来学习如何给应用添加关键字搜索功能。</p>
]]></description><pubDate>Thu Dec 24 2015 17:30:38 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/angular-tutorial-angular-templates</link><guid isPermaLink="true">https://blog.wxsm.space/p/angular-tutorial-angular-templates</guid></item><item><title>Angular 教程：静态模版</title><description><![CDATA[<p>为了更好地说明 Angular 是如何扩展标准 HTML 的，我们创建了一个纯静态的 HTML 页面，然后通过实践将它转换成 Angular 可以识别的动态模板，它们将表现出一样的数据集。 在这一步教程中你会给HTML页面添加两条手机设备的基本信息。</p>
<ul>
<li>页面现在包含一个关于两台手机的列表</li>
</ul>
<p>最重要的改动如下所示。你可以在 <a href="https://github.com/angular/angular-phonecat/compare/step-0...step-1" title="See diff on Github">GitHub</a> 上查看它与之前的代码有何区别。</p>
<p><code>app/index.html</code>：</p>
<pre><code>&lt;ul&gt;
  &lt;li&gt;
    &lt;span&gt;Nexus S&lt;/span&gt;
    &lt;p&gt;
      Fast just got faster with Nexus S.
    &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;span&gt;Motorola XOOM™ with Wi-Fi&lt;/span&gt;
    &lt;p&gt;
      The Next, Next Generation tablet.
    &lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<h2 id="">课外扩展 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h2>
<p>尝试给静态页面<code>index.html</code>再加多点东西，比如：</p>
<pre><code>&lt;p&gt;Total number of phones: 2&lt;/p&gt;
</code></pre>
<h2 id="-2">总结 <a class="header-anchor" href="#-2" aria-hidden="true">&#128279;</a></h2>
<p>这节教程给应用添加了一个由静态 HTML 组成的列表。现在我们可以通过 <a href="/p/angular-tutorial-angular-templates/">step 2</a> 来学习如何使用 Angular 来动态地生成同样的列表。</p>
]]></description><pubDate>Wed Dec 23 2015 17:52:43 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/angular-tutorial-static-template</link><guid isPermaLink="true">https://blog.wxsm.space/p/angular-tutorial-static-template</guid></item><item><title>Angular 教程：起步</title><description><![CDATA[<p>在这一步中，你将对本项目中最重要代码有所了解，以及学习如何启动使用 angular-seed 打包过的开发服务器，并且让应用程序在浏览器上跑起来。 在此之前，请确认你已经配置好了开发环境并且所有依赖包都已经安装好。参考<a href="/p/angular-tutorial-phonecat-tutorial-app/">开发环境搭建教程</a>。</p>
<p>在<code>angular-phonecat</code>目录中执行以下命令：</p>
<pre><code>git checkout -f step-0
</code></pre>
<p>这条命令会将工作空间重置到和这一步教程相关的状态下。 在这以后每开始一步新的教程你都需要将 step-number 中的数字替换成当前教程的序号，这会导致没有保存的修改丢失。 如果你还没有安装过项目中的依赖，可以执行以下命令：</p>
<pre><code>npm install
</code></pre>
<p>为了让我们的应用程序在浏览器中跑起来，我们要打开一个独立的终端或者命令行，然后执行<code>npm start</code>命令来启动 Web 服务器。</p>
<p>现在可以用浏览器打开 <a href="http://localhost:8000/app/">http://localhost:8000/app/</a> 看到一个简单的页面了。 如果你在切换 Branch 之前已经运行过了一次项目，无需重启服务器，刷新页面即可。</p>
<p>在浏览器中你可以看到一个简单的页面：”Nothing here yet!”。这句话是使用以下代码实现的。代码中包含了一些接下来的教程中会用到的 Angular 要素。</p>
<p><code>app/index.html</code>：</p>
<pre><code>&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot; ng-app&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;title&gt;My HTML File&lt;/title&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;bower_components/bootstrap/dist/css/bootstrap.css&quot;&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;css/app.css&quot;&gt;
  &lt;script src=&quot;bower_components/angular/angular.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

  &lt;p&gt;Nothing here {{'yet' + '!'}}&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<hr>
<h2 id="">代码做了些什么？ <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h2>
<h3 id="ngapp-directive">ngApp 指令（Directive） <a class="header-anchor" href="#ngapp-directive" aria-hidden="true">&#128279;</a></h3>
<pre><code>&lt;html ng-app&gt;
</code></pre>
<p class="lang:default highlight:0 decode:1 inline:1 ">
  <code>ng-app</code>属性代表了一个名字为<code>ngApp</code>的指令（Angular 使用小写带破折号的spinal-case来表示它的自定义属性，使用驼峰命名法camelCase来表示与属性一致并且是其实现的指令）。
</p>
<p>我们把该指令标志在了 html 元素节点上，Angular 就会认为这就是应用程序的根节点。这给了开发者一定的自由度，我们可以选择使用 Angular 去驱动整个 HTML 页面，或者只是其中的一小部分。</p>
<h3 id="angularjs">引入 AngularJS 脚本 <a class="header-anchor" href="#angularjs" aria-hidden="true">&#128279;</a></h3>
<pre><code>&lt;script src=&quot;bower_components/angular/angular.js&quot;&gt;
</code></pre>
<p>这段代码加载了<code>angular.js</code>脚本，脚本注册了一个会在浏览器加载完页面内容后触发的回调事件。当回调事件触发时，Angular 会在页面上查找<code>ngApp</code>指令，如果找到了，它就会随着定义了<code>ngApp</code>指令的 DOM 节点引导应用程序。</p>
<h3 id="-2">使用双花括号绑定表达式 <a class="header-anchor" href="#-2" aria-hidden="true">&#128279;</a></h3>
<pre><code>Nothing here {{'yet' + '!'}}
</code></pre>
<p>这个简单的例子包含了 Angular 模版功能的两个核心特色：</p>
<ul>
<li>使用双花括号<code>{{ }}</code>作为“绑定”的标志</li>
<li>在“绑定”之中使用简单的表达式<code>'yet' + '!'</code></li>
</ul>
<p>“绑定”会告诉 Angular 它应该计算花括号内表达式的值，然后替代“绑定”文本本身并且插入到 DOM 中去。</p>
<p>我们会在接下来的教程中发现，比起在学习 Angular 之前的一次性插入，绑定的表现内容将会随着表达式的值的变化而发生连续不断的改变。</p>
<p>Angular 表达式是由 Angular 在当前模型作用域（model scope）的上下文（context）中计算的，类似于一小片 JavaScript 的代码。区别于使用全局上下文（window）。 根据以上的逻辑，一旦模板被 Angular 解释，HTML 页面就会显示：”Nothing here yet!”</p>
<hr>
<h2 id="angularjs-2">引导 AngularJS 应用 <a class="header-anchor" href="#angularjs-2" aria-hidden="true">&#128279;</a></h2>
<p>使用<code>ngApp</code>指令来自动引导 AngularJS 应用在大多数情况下都是简单实用的。在有较高需求的时候（比如说使用 script loaders 的情况下），可以使用<a href="https://docs.angularjs.org/guide/bootstrap">手动方法</a>来引导。 在应用程序被引导的过程中会发生 3 件重要的事情：</p>
<ol>
<li>为了使用依赖注入，创建了一个<a href="https://docs.angularjs.org/api/auto/service/$injector">注入器（injector）</a></li>
<li>注入器为应用创建<a href="https://docs.angularjs.org/api/ng/service/$rootScope">根作用域</a>，它将成为应用模型的上下文</li>
<li>Angular 开始从标志了<code>ngApp</code>的根节点编译DOM，处理途中发现的所有指令以及绑定</li>
</ol>
<p>一旦应用程序被引导完成后，它将开始监听将要到来的，可能会改变模型（Model）的浏览器事件（比如鼠标点击，键盘点击或者收到的 HTTP 响应）。一旦有类似的事件发生，Angular 会检测它是否造成了 model 的改变，如果发现了改变，Angular 会通过更新所有受到影响的绑定来把它们反映到视图上。</p>
<p>现在我们的应用程序的结构非常简单。模板只包含了一条指令以及一个静态绑定，模型也是空的。在接下来的教程中就会发生变化。</p>
<p><img src="https://raw.githubusercontent.com/wxsms/wxsms-img-holder/master/tutorial_00.png" alt=""></p>
<hr>
<p> </p>
<h2 id="-3">关于项目中的一些文件来源 <a class="header-anchor" href="#-3" aria-hidden="true">&#128279;</a></h2>
<p>工作目录中大多数的文件来自于 <a href="https://github.com/angular/angular-seed">angular-seed</a> 项目，该项目的目的是用来引导新的 Angular 项目。seed 预配置了通过 bower 安装 Angular 框架以及通过 npm 安装相关工具的一些代码。 为了适应本教程，我们对 seed 项目做了一些改动：</p>
<ul>
<li>去掉了样例应用</li>
<li>往<code>app/img/phones/</code>中添加了一些设备的图片</li>
<li>往<code>app/phones/</code>中添加了一些设备细节数据（JSON）</li>
<li>往<code>bower.json</code>中添加了一项 <a href="http://getbootstrap.com/">Bootstrap</a> 的依赖</li>
</ul>
<h2 id="-4">课外扩展 <a class="header-anchor" href="#-4" aria-hidden="true">&#128279;</a></h2>
<p>尝试给<code>index.html</code>添加一些新的表达式，比如和数学有关的：</p>
<pre><code>&lt;p&gt;1 + 2 = {{ 1 + 2 }}&lt;/p&gt;
</code></pre>
<h2 id="-5">总结 <a class="header-anchor" href="#-5" aria-hidden="true">&#128279;</a></h2>
<p>现在我们可以开始<a href="/p/angular-tutorial-static-template/">step 1</a>，给应用添加一些内容了。</p>
]]></description><pubDate>Tue Dec 22 2015 09:10:52 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/angular-tutorial-bootstrapping</link><guid isPermaLink="true">https://blog.wxsm.space/p/angular-tutorial-bootstrapping</guid></item><item><title>Angular 教程：手机展示应用</title><description><![CDATA[<p>本系列教程是<a href="https://docs.angularjs.org/tutorial">AngularJs官方教程</a>（基于<a href="http://creativecommons.org/licenses/by/3.0/">CC BY 3.0协议</a>发布）的个人翻译，原版权属<a href="https://angularjs.org/">AngularJs官方网站</a>所有，主要用于学习与分享，如有纰漏敬请指出。转载请注明出处。 学习AngularJs的方法之一就是跟着本教程做一个完整的项目，这个项目会向你介绍一个 AngularJS Web App 应有的架构体系。项目的目的是构建一个安卓设备目录，它可以显示一个带过滤/排序功能的列表页，同时允许用户点击列表中的设备以查看其中的详细内容。就像这样：</p>
<p><img src="https://raw.githubusercontent.com/wxsms/wxsms-img-holder/master/catalog_screen.png" alt=""></p>
<p>在不使用任何原生扩展包以及插件的情况下，跟随本教程来体会 Angular 是如何让浏览器变得更聪明的：</p>
<ul>
<li>学习使用客户端数据绑定来创建会随着用户操作而改变的带有动态数据的视图（View）</li>
<li>学习不使用 DOM 操作来保持视图与数据的同步</li>
<li>学习使用 Karma 和 Protractor 测试框架</li>
<li>学习使用依赖注入（Dependency Injection）和服务（Services）来使得 Web 设计更优雅</li>
</ul>
<p>本教程可以让你学会：</p>
<ul>
<li>在主流浏览器上创建一个 Angular 动态应用</li>
<li>使用数据绑定让你的数据模型（Model）和视图互连</li>
<li>使用 Karma 创建和执行单元测试</li>
<li>使用 Protractor 创建和执行端到端测试</li>
<li>将应用的控制逻辑从模板（Template）转移到控制器（Controller）</li>
<li>使用 Angular Service 从服务端获取数据</li>
<li>使用 ngAnimate 为应用添加动画效果</li>
<li>如何寻找其它 Angular 的学习资源</li>
</ul>
<p>本教程将指导构读者建一个简单应用的完整过程，包括如何编写 / 执行单元 / 端到端测试。每个步骤最后的试验环节将为你提供更多的关于学习 AngularJS / 本项目的建议。 几个小时或者一天的时间就足以完成教程了。</p>
<!--more-->
<h2 id="">起步 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h2>
<p>本章节余下的内容会指导你完成本地开发环境的搭建，如果你只想读教程的话就可以直接进入第一步：<a href="/p/angular-tutorial-bootstrapping/">Step 0 - 起步</a></p>
<h2 id="-2">使用代码 <a class="header-anchor" href="#-2" aria-hidden="true">&#128279;</a></h2>
<p>本教程使用 <a href="http://git-scm.com/">Git</a> 来管理源代码。</p>
<h3 id="git">安装Git <a class="header-anchor" href="#git" aria-hidden="true">&#128279;</a></h3>
<p>从 <a href="http://git-scm.com/download">http://git-scm.com/download</a> 下载和安装 Git，在 git 命令行界面中，将会使用到的命令有：</p>
<ul>
<li><code>git clone</code>：克隆一个远程代码仓库到本地机器</li>
<li><code>git checkout ...</code>：登入 / 登出一个仓库的不同分支或标签</li>
</ul>
<h3 id="angular-phonecat">下载 angular-phonecat <a class="header-anchor" href="#angular-phonecat" aria-hidden="true">&#128279;</a></h3>
<p>用以下命令从 GitHub 下载 <a href="https://github.com/angular/angular-phonecat">angular-phonecat repository</a>：</p>
<pre><code>git clone --depth=14 https://github.com/angular/angular-phonecat.git
</code></pre>
<p>这条命令会在你的当前目录下创建<code>angular-phonecat</code>代码仓库。</p>
<blockquote>
<p><code>--depth=14</code>选项会告诉 Git 只拉取最新的14条 Commits，这会让你的下载速度快很多。</p>
</blockquote>
<p>把当前目录转到<code>angular-phonecat</code>：</p>
<pre><code>cd angular-phonecat
</code></pre>
<p>从现在开始，如非特别说明，教程中所有的指令都是在<code>angular-phonecat</code>目录下执行的。</p>
<h3 id="nodejs">安装 Node.js <a class="header-anchor" href="#nodejs" aria-hidden="true">&#128279;</a></h3>
<p>如果想要运行已经预配置好的 web 服务器和测试工具，你还需要安装 <a href="http://nodejs.org/">Node.js v0.10.27+</a></p>
<p>你可以通过 <a href="http://nodejs.org/download/">http://nodejs.org/download/</a> 下载 Node.js 安装包。 使用以下命令查看安装好的 Node.js 版本：</p>
<pre><code>node --version
</code></pre>
<p>在基于 Debian 的分布式系统下，存在另外一个名叫<code>node</code>的工具，这样一来名字就冲突了。推荐的解决方案是安装<code>nodejs-legacy</code>包，这个包会将我们需要的<code>node</code>重命名为<code>nodejs</code></p>
<pre><code>apt-get install nodejs-legacy npm
nodejs --version
npm --version
</code></pre>
<blockquote>
<p>如果需要在本地环境下运行不同版本的 Nodejs，可以考虑安装 <a href="https://github.com/creationix/nvm" title="Node Version Manager Github Repo link">Node Version Manager (nvm)</a></p>
</blockquote>
<p>安装好 Nodejs 后，可以通过以下命令安装项目依赖：</p>
<pre><code>npm install
</code></pre>
<p>这条指令会读取 angular-phonecat 目录下的<code>package.json</code>文件，并且把以下内容下载到<code>node_modules</code>目录：</p>
<ul>
<li><a href="http://bower.io/">Bower</a> - 客户端的包管理器</li>
<li><a href="https://github.com/nodeapps/http-server">Http-Server</a> - 一个简单的本地静态 web 服务器</li>
<li><a href="https://github.com/karma-runner/karma">Karma</a> - 单元测试框架</li>
<li><a href="https://github.com/angular/protractor">Protractor</a> - 端到端（E2E）测试框架</li>
</ul>
<p>执行<code>npm install</code>也会自动地使用 bower 将 Angular 下载到<code>app/bower_components</code>目录。</p>
<blockquote>
<p>需要注意的是，angular-phonecat 项目使用 npm 脚本来安装和运行这些工具，这意味着它们在默认情况下没有被全局安装。查看下面的<strong>安装帮助工具</strong>以获得更多信息。</p>
</blockquote>
<p>本项目为了简化开发过程中一些无关紧要的任务，已经预设了一些 npm 脚本：</p>
<ul>
<li>
<p><code>npm start</code></p>
<ul>
<li>启动一个本地开发服务器</li>
</ul>
</li>
<li>
<p><code>npm test</code></p>
<ul>
<li>启动 Karmar</li>
</ul>
</li>
<li>
<p><code>npm run protractor</code></p>
<ul>
<li>启动 Protractor</li>
</ul>
</li>
<li>
<p><code>npm run update-webdriver</code></p>
<ul>
<li>安装 Protractor 的依赖驱动</li>
</ul>
</li>
</ul>
<h3 id="-3">安装帮助工具（可选） <a class="header-anchor" href="#-3" aria-hidden="true">&#128279;</a></h3>
<p>Bower，Http-Server，Karma 和 Protractor 模块同时也是可执行的工具，可以全局安装并且通过终端、命令行直接执行。在本教程中你不需要这么做，但是如果你想要直接执行它们，你可以使用<code>sudo npm install -g ...</code>全局安装这些模块。</p>
<p>比如，使用以下命令来全局安装Bower：</p>
<pre><code>sudo npm install -g bower
</code></pre>
<p>（如果在 windows 下请忽略 sudo ）</p>
<p>然后你就可以直接执行 bower 工具了，像这样：</p>
<pre><code>bower install
</code></pre>
<h3 id="-4">启动开发服务器 <a class="header-anchor" href="#-4" aria-hidden="true">&#128279;</a></h3>
<p>虽然本 Angular 应用是以纯客户端代码组成，并且可以使用浏览器通过点击文件系统中的页面直接打开，但我们还是需要一个 Http web 服务器，尤其是出于一些安全方面的考虑，在页面是从文件系统中直接加载的情况下，大多数主流浏览器会阻止 JavaScript 发送异步请求。 本项目使用了一个简单的静态 Web 服务器来搭载应用。使用以下命令来启动它：</p>
<pre><code>npm start
</code></pre>
<p>这条命令会创建一个监听 8000 端口的本机服务器，你现在可以通过以下地址访问应用了： <a href="http://localhost:8000/app/index.html">http://localhost:8000/app/index.html</a></p>
<blockquote>
<p>如果想要更改 Web 服务器启动的 ip 或者 port， 可以编辑<code>package.json</code>中的<code>start</code>脚本。你可以使用<code>-a</code>来设置地址，使用<code>-p</code>来设置端口号。</p>
</blockquote>
<h3 id="-5">执行单元测试 <a class="header-anchor" href="#-5" aria-hidden="true">&#128279;</a></h3>
<p>单元测试关注应用程序中细小且独立的代码块，以保证 JavaScript 代码运行的正确性。单元测试的代码存放在<code>test/unit</code>目录中。 本项目使用 <a href="https://github.com/karma-runner/karma">Karma</a> 作为单元测试框架，使用以下命令启动 Karma：</p>
<pre><code>npm test
</code></pre>
<p>这条命令会启动 Karma 单元测试执行器。Karma 会读取配置文件<code>test/karma.conf.js</code>，在其指导下完成：</p>
<ul>
<li>打开 Chrome 浏览器并且连接到 Karma</li>
<li>在浏览器中执行所有单元测试</li>
<li>在终端或命令行中打印测试结果</li>
<li>监听项目下的所有 JavaScript 代码，当它们发生改变的时候重新执行单元测试</li>
</ul>
<p>你可以在开发过程中保持 Karma 后台运行，它会及时地告诉你修改后的代码是否通过了单元测试。</p>
<h3 id="-6">执行端到端测试 <a class="header-anchor" href="#-6" aria-hidden="true">&#128279;</a></h3>
<p>端到端测试通过模拟一个真正的用户与运行在浏览器上的应用程序实时交互来保证整个应用在客户端上表现与行为的正确性。 端到端测试的代码存放在<code>test/e2e</code>目录中。 本项目使用 <a href="https://github.com/angular/protractor">Protractor</a> 来执行端到端测试。Protractor 为了与浏览器交互将依赖于一些驱动，你可以通过以下指令安装它们：</p>
<pre><code>npm run update-webdriver
</code></pre>
<p>（运行一次就够了）</p>
<p>因为 Protractor 通过与应用程序交互来工作，所以我们需要先启动 Web 服务器：</p>
<pre><code>npm start
</code></pre>
<p>然后在另外一个终端或命令行窗口中，使用以下命令启动 Protractor 测试脚本：</p>
<pre><code>npm run protractor
</code></pre>
<p>Protractor 会读取配置文件<code>test/protractor-conf.js</code>，在其指导下完成：</p>
<ul>
<li>打开 Chrome 浏览器并连接到应用程序</li>
<li>在浏览器中执行所有的端到端测试</li>
<li>在终端或命令行中打印测试结果</li>
<li>关闭浏览器并退出</li>
</ul>
<p>当你对 HTML 视图做出改动或者想要测试整个应用程序是否运行正常的时候，最好是执行一次端到端测试。在提交代码前执行此类测试是一种普遍的做法。</p>
<p>现在你已经在本地机器上搭好了环境，我们可以从头开始本教程了：<a href="/p/angular-tutorial-bootstrapping/">Step 0 - 起步</a></p>
]]></description><pubDate>Mon Dec 21 2015 09:04:01 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/angular-tutorial-phonecat-tutorial-app</link><guid isPermaLink="true">https://blog.wxsm.space/p/angular-tutorial-phonecat-tutorial-app</guid></item><item><title>jQuery 写的 2048 小游戏</title><description><![CDATA[<p><img src="https://raw.githubusercontent.com/wxsms/wxsms-img-holder/master/20151212214138.jpg" alt="2048"></p>
<p>Game：<a href="http://anubarak.com/others/games/2048/" target="_blank">http://anubarak.com/others/games/2048/</a></p>
<p>Code：<a href="https://github.com/edisond/jquery-2048-game" target="_blank">https://github.com/edisond/jquery-2048-game</a></p>
<p>几年前还在学校的时候刚学JS/jQuery，为了找点事情练练手寻思着做点什么，当时又特别沉迷于一个叫2048的小游戏，于是就有了这么个东西。刚做出来的时候开心了好一阵子，现在回头看代码觉得简直惨不忍睹，根本不像是一个学过算法的人写出来的，字里行间充斥的都是简单与暴力。那时候主要是为了学一门新语言就没有在意这些东西。以后有时间再来优化一下。 在开始的时候是有记分，重启，排行榜一票功能的，现在为了纯粹一点就把垃圾都去掉了。太臭的代码就不说了，有兴趣或者疑问的可以留下评论。</p>
<h3 id=""> <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h3>
]]></description><pubDate>Sat Dec 12 2015 21:58:15 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/2048-game-base-on-jquery</link><guid isPermaLink="true">https://blog.wxsm.space/p/2048-game-base-on-jquery</guid></item><item><title>MEAN.js 学习笔记</title><description><![CDATA[<p><img src="https://raw.githubusercontent.com/wxsms/wxsms-img-holder/master/meanjs-logo.png" alt=""></p>
<p>之前一直以为MEAN只是一个概念上的东西，表示以<a href="http://mongodb.org/">Mongodb</a> <a href="http://expressjs.com/">Express</a> <a href="http://angularjs.org/">AngularJs</a> <a href="http://nodejs.org/">NodeJs</a>为基础的全栈应用开发模式。这几天在公司接手相应项目的时候发现已经有人做出来并且维护着一些这样的App结构体，用过以后觉得还不错。<a href="https://github.com/meanjs/mean">MEANJS</a>是一个开源的JavaScript全栈应用解决方案，主要用到的技术自然就是以上提到的那些。使用成熟的解决方案可以使自己的项目更加易于开发以及维护，等等好处就不再赘述。</p>
<h2 id="mean">关于MEAN <a class="header-anchor" href="#mean" aria-hidden="true">&#128279;</a></h2>
<p>本文主要关注MEANJS本身，对于MEAN之中的种种技术就不再多做介绍。下面贴MEANJS给出的一些链接。</p>
<ul>
<li>MongoDB - Go through <a href="http://mongodb.org/">MongoDB Official Website</a> and proceed to their <a href="http://docs.mongodb.org/manual/">Official Manual</a>, which should help you understand NoSQL and MongoDB better.</li>
<li>Express - The best way to understand express is through its <a href="http://expressjs.com/">Official Website</a>, which has a <a href="http://expressjs.com/starter/installing.html">Getting Started</a> guide, as well as an <a href="http://expressjs.com/guide/error-handling.html">ExpressJS Guide</a> guide for general express topics. You can also go through this <a href="http://stackoverflow.com/questions/8144214/learning-express-for-node-js">StackOverflow Thread</a> for more resources.</li>
<li>AngularJS - Angular’s <a href="http://angularjs.org/">Official Website</a> is a great starting point. You can also use <a href="http://www.thinkster.io/">Thinkster Popular Guide</a>, and the<a href="https://egghead.io/">Egghead Videos</a>.</li>
<li>Node.js - Start by going through <a href="http://nodejs.org/">Node.js Official Website</a> and this <a href="http://stackoverflow.com/questions/2353818/how-do-i-get-started-with-node-js">StackOverflow Thread</a>, which should get you going with the Node.js platform in no time.</li>
</ul>
<h2 id="">安装依赖 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h2>
<p>作为一个集大成者，MEANJS需要的运行环境还是挺多的，但是相对Java项目来说简直不值一提。</p>
<ul>
<li><strong>NodeJs</strong> - 没有Node谈何MEAN，注意的是目前的MEANJS版本（0.3.x）还不支持最新的5.x NodeJs，我就中了这招</li>
<li><strong>MongoDB</strong> - 和NodeJs的集成比较好，下载安装包一路next即可</li>
<li><strong>Ruby/Python/.Net 2+</strong> - 一些Node的模块需要用到这些东西，毕竟Node只是一个runtime，在服务器端一些稍微底层的操作还是要用到其他东西（12-14-2015更新：Python必须是2.x版本）</li>
<li><strong>Bower</strong> - 前端包管理器，和npm组成一前一后的完整管理体系，相当于Java的Maven</li>
<li><strong>Grunt/Grunt CLI</strong> - JavaScript世界的自动化工具，重复工作全靠它。CLI是Grunt的命令行工具。</li>
<li><strong>Sass/Less</strong> - MEANJS用到了Sass去编译CSS，所以也要添加它的支持。其实我个人感觉这个有点多余了。</li>
</ul>
<h2 id="meanjs-app">启动MEANJS APP <a class="header-anchor" href="#meanjs-app" aria-hidden="true">&#128279;</a></h2>
<h3 id="-2">安装依赖模块 <a class="header-anchor" href="#-2" aria-hidden="true">&#128279;</a></h3>
<p>完成以上安装以及相应环境变量的配置以后，就可以准备启动 MEANJS 服务器了。首先需要在文件夹根目录运行 <code>$ npm install</code> 指令，根据 Readme 中的说法，这条指令做了以下的事情：</p>
<ol>
<li>安装运行所需的 Node 模块</li>
<li>如果是测试环境则安装开发测试所需的 Node 模块</li>
<li>最后执行 bower 安装前端模块</li>
</ol>
<p>不过我在最后一步有时候会遇到问题，需要手动再进行一次 <code>$ bower install</code>，另外，npm 的官方源在大陆访问并不稳定，可以使用<a href="http://npm.taobao.org/">淘宝镜像</a>替代，Ruby 也是同理：<a href="https://ruby.taobao.org/">Ruby镜像</a>。</p>
<p>12-14-2015 更新：这一步容易出现问题，一般仔细看 Log 都能找到问题所在，无非是哪个依赖没有配置环境变量/版本不对等，重新配置好以后删除 <code>Node_modules</code> 文件夹再重新运行命令。</p>
<h3 id="mongodb">启动 Mongodb <a class="header-anchor" href="#mongodb" aria-hidden="true">&#128279;</a></h3>
<p>因为 MEANJS 默认为我们做了一个简单的用户注册登录模块，里面有一些数据库的增删查改，所以在启动服务器之前需要先启动数据库。随便找一个地方打开控制台输入 <code>$ mongod --dbpath ***</code>，***处填写一个路径，mongod 就能够在指定位置创建一个文件型数据库并连接之，如果该位置已存在数据库文件则会直接打开连接。</p>
<h3 id="-3">启动服务器 <a class="header-anchor" href="#-3" aria-hidden="true">&#128279;</a></h3>
<p>在以上都准备完成以后，我们就可以在项目根目录通过一条简单的指令 <code>$ grunt</code> 来启动服务器了，启动成功后可以在 <a href="http://localhost:3000">http://localhost:3000</a> 看到项目主页。</p>
<h3 id="grunt">关于Grunt <a class="header-anchor" href="#grunt" aria-hidden="true">&#128279;</a></h3>
<p><code>$ grunt</code> 这条指令会读取项目目录下的 <code>gruntfile.js</code>** **文件，并执行文件中定义的 task。MEANJS 的文档中并没有对其功能进行说明，以下是我的解读：</p>
<h4 id="-4">插件配置 <a class="header-anchor" href="#-4" aria-hidden="true">&#128279;</a></h4>
<p>以下都是 grunt task 中用到的插件的相关配置，具体插件以及相关文档都可以在<a href="http://www.gruntjs.net/plugins">Grunt插件页面</a> 找到。</p>
<pre><code>env: {
      test: {
        NODE_ENV: 'test'
      },
      dev: {
        NODE_ENV: 'development'
      },
      prod: {
        NODE_ENV: 'production'
      }
    }
</code></pre>
<p><strong>env</strong>定义了三个服务器的运行环境：测试，开发，以及产品，在文件的最后会用到。</p>
<pre><code>//......
defaultAssets = require('./config/assets/default'),
testAssets = require('./config/assets/test'),
//......
watch: {
      serverViews: {
        files: defaultAssets.server.views,
        options: {
          livereload: true
        }
      },
      //......
    }
</code></pre>
<p><strong>watch</strong>指定了动态监听的目录/文件，可以看到在每一个View/Js/Css监听列表中都加入了 <code>livereload</code> 选项，这个选项的作用是当被监听的文件发生变化时，浏览器会自动刷新。不过 watch 会再创建一个监听端口（默认为 35729），打开 <a href="http://localhost:35729/">http://localhost:35729/</a> 可以发现。被加载的首先是配置文件 <code>./config/assets/default.js</code> 与相应的 <code>test.js</code> 等，然后再配置文件内可以找到文件列表，其中已经包括已经用到的以及将来会加入的文件（通过通配符实现），只要我们在开发时把文件放在相应结构位置上，grunt 就会自动监听。</p>
<pre><code>nodemon: {
      dev: {
        script: 'server.js',
        options: {
          nodeArgs: ['--debug'],
          ext: 'js,html',
          watch: _.union(defaultAssets.server.gruntConfig, defaultAssets.server.views, defaultAssets.server.allJS, defaultAssets.server.config)
        }
      }
    }
</code></pre>
<p><code>nodemon</code>** **配置了服务器自动重启。当 server 端的 config/views/js 文件发生变化时，<code>server.js</code> 脚本就会自动执行。由于只是服务器的重启而不是重新执行 grunt，所以几乎是秒速。以前用过一些类似的 node module 叫 superviso r和 forever，不过这个集成到了 grunt task 中。写过 JavaEE project 的人再用这个才能体会到时间的宝贵。</p>
<pre><code>concurrent: {
      default: ['nodemon', 'watch'],
      debug: ['nodemon', 'watch', 'node-inspector'],
      options: {
        logConcurrentOutput: true
      }
    }
</code></pre>
<p><code>concurrent</code>插件可以使任务并发执行，让前端与服务器端监听同时在一个终端窗口中执行/ Log</p>
<p><code>cshint/csslint</code>这两个插件主要是为了在 build 的时候顺便检查一下js/css文件中有没有常见的 warning / error，存在 error 时会停止 build tas k并给出提示，不过控制台输出用户体验不是很好，开发过程中作用不大，我们都有 IDE，需要作为产品上线时跑一遍可能会更有参考价值。</p>
<p>后面的<code>ngAnnotae</code>插件可以在build的过程中对 angular j s的 annotation 进行简化以减少代码量，提高效率，属于锦上添花型。<code>uglify/cssmin</code>则相应地执行 js/css 代码压缩任务。至于<code>sass/less</code>很明显就是 css 编译器了。再之后的多是 debug / test 插件。</p>
<h4 id="-5">注册任务 <a class="header-anchor" href="#-5" aria-hidden="true">&#128279;</a></h4>
<pre><code>grunt.registerTask('taskName', ['***', '***']);
</code></pre>
<p>类似像这样的代码就是向grunt注册一个任务，第二个数组参数则是注册任务的内容，里面可以填另一个任务的名字或者是插件的名字，或者直接填写function取代该数组。通过在控制台输入 <code>$ grunt taskName</code> 执行任务，而不输入 taskName 的话则是执行 default 任务，当前 <code>gruntfile.js</code> 中的default task如下：</p>
<pre><code>// Run the project in development mode
  grunt.registerTask('default', ['env:dev', 'lint', 'mkdir:upload', 'copy:localConfig', 'concurrent:default']);
</code></pre>
<p>这个任务里面包含了一些子任务，就不一一说明了，有兴趣的可以自行查看，到这里终于可以说说 <code>$ grunt</code> 指令到底做了什么：</p>
<ol>
<li>设置运行环境为 dev，即开发</li>
<li>执行 js/css 等文件的语法检查</li>
<li>确保上传路径存在（MEANJS 默认带了一个用户上传头像的功能）</li>
<li>加载一个自定义配置文件（里面可以填写 db 以及一些 api key 等信息）</li>
<li>default 模式启动 concurrent 前后端热部署</li>
</ol>
<p>可以看到这里面并没有启动服务器的指令，其实在nodemon中已经配置了服务器入口即 <code>server.js</code>。于是在所有准备工作完成后，开发环境的服务器就启动起来了。</p>
<p>当然 gruntfile 中也包含了 dev 以及 tes t环境的 task，需要切换运行环境的时候只需要在 grunt 命令中加入相应参数即可，还是比较方便的。</p>
<h2 id="-6">项目结构 <a class="header-anchor" href="#-6" aria-hidden="true">&#128279;</a></h2>
<h3 id="-7">根目录结构 <a class="header-anchor" href="#-7" aria-hidden="true">&#128279;</a></h3>
<pre><code>├── bower.json
├── config
├── gruntfile.js
├── modules
├── package.json
└── server.js
</code></pre>
<p>以上是精简过后的根目录组成，不包括node_modules和public文件夹，以及一些optional和test相关的文件。</p>
<ul>
<li><strong>bower.json/package.json</strong> - 前端/后端依赖说明文件，需要添加依赖时在文件里指定 ID /版本，再运行 <code>$ bower install</code> 或者 <code>$ npm install</code> 就会将指定包下载到 <code>node_modules/public</code> 文件夹中</li>
<li><strong>gruntfile.js</strong> - grunt 任务配置文件</li>
<li><strong>server.js</strong> - 服务器启动文件</li>
<li><strong>config</strong> - 配置文件</li>
<li><strong>modules</strong> - App 模块，也就是需要我们大量写代码的地方了，可以看到 MEANJS 项目已经包含了若干模块，我们可以在这基础之上添加自己的业务逻辑，或者推到重来</li>
</ul>
<p>由于 MEANJS 的目录原则是模块优先，所以前后端的 MVC 会在相应模块目录内得到体现，这点与使用 express js 创建的目录结构有所区别。不过之前公司一位 STE share ExtJs 的时候提到其实都是大同小异，反正到最后目录结构都会变得臃肿。</p>
<h3 id="-8">模块结构 <a class="header-anchor" href="#-8" aria-hidden="true">&#128279;</a></h3>
<pre><code>modules
│   └── moduleName
│       ├── client
│       │   ├── config
│       │   ├── controllers
│       │   ├── css
│       │   ├── img
│       │   ├── services
│       │   └── views
│       └── server
│           ├── config
│           ├── controllers
│           ├── models
│           ├── policies
│           ├── routes
│           └── templates
</code></pre>
<p>一个模块一般包含以上目录，首先从前端/后端分开，然后是各自的配置/ MVC，非常科学。值得一提的是每个模块各自用到的独立 css / image 等资源也是分开存放的，grunt 会在 build 的时候把它们全部读取并且载入，如果是 production 环境更会将同类压缩到一个文件中去，所以我们并不需要写很多的 include 之流。</p>
<h2 id="-9">总结 <a class="header-anchor" href="#-9" aria-hidden="true">&#128279;</a></h2>
<p>相对于手动使用 MEAN 各项技术结合写程序来说，使用 MEANJS 解决方案可以让我们更方便且快速地搭建项目，并且使我们不用太过于关注业务逻辑以外的问题，开发效率在全栈统一的保证下又提高了不少，不得不说确实是值得中小型项目去研究并且尝试使用一下。至于企业级大型项目，不知道有没有研究或者什么公司尝试过，不太清楚是否适合。</p>
]]></description><pubDate>Thu Dec 10 2015 16:35:33 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/mean-js-note</link><guid isPermaLink="true">https://blog.wxsm.space/p/mean-js-note</guid></item><item><title>Git SSH key 生成与 GitExtension 配置</title><description><![CDATA[<p>使用ssh key配置git可以省去每次操作时输入ID/Password的麻烦，操作一旦频繁起来还是很有必要的。实际操作需要添加一些环境变量，或者到git/bin目录下执行。<!--more--></p>
<h3 id="gitusernameemail">设置Git的默认username和email <a class="header-anchor" href="#gitusernameemail" aria-hidden="true">&#128279;</a></h3>
<p>这一步没有验证过是否可以省略。</p>
<pre><code>$ git config --global user.name &quot;xxx&quot;
$ git config --global user.email &quot;xxx@xxx.xxx&quot;
</code></pre>
<h3 id="ssh-key">本地生成SSH Key <a class="header-anchor" href="#ssh-key" aria-hidden="true">&#128279;</a></h3>
<h4 id="">查看是否已有密钥 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h4>
<p>有的教程说通过 <code>$ cd ~/.ssh</code> 查看目录是否存在，不过我的机器上测试无论有没有这一步的结果都是不存在。所以我的方法是到c:/users/username/下查看是否存在.ssh文件夹，存在则将里面的内容删除。</p>
<h4 id="-2">生成密钥 <a class="header-anchor" href="#-2" aria-hidden="true">&#128279;</a></h4>
<p>执行 <code>$ ssh-keygen</code>，连续回车确认，到最后 ssh key 就会在 <code>.ssh</code> 文件夹下生成，带 .pub 后缀的为公钥。遇到找不到路径的情况则需要手动指定 <code>.ssh</code> 文件夹的正确位置，我尝试把它放在 D 盘结果 server 不认，还是要指定 <code>c:/users/username/.ssh</code> 这个目录去生成，密钥名字为 id_rsa</p>
<h4 id="server">上传到server <a class="header-anchor" href="#server" aria-hidden="true">&#128279;</a></h4>
<p>生成结束后需要将公钥上传到相应 server，以 <a href="https://github.com" target="_blank">Github</a> 为例：</p>
<p><img src="https://raw.githubusercontent.com/wxsms/wxsms-img-holder/master/20151208161540.png" alt=""></p>
<p>将公钥文件中的所有内容copy到key输入框中，添加保存即可。</p>
<h3 id="git-extensionwindows">配置Git Extension（windows） <a class="header-anchor" href="#git-extensionwindows" aria-hidden="true">&#128279;</a></h3>
<p>以上步骤执行完后可以使用命令行执行推拉等操作，但是在Git Extension就死活不行，后来发现这个工具安装的时候默认使用了putty作为ssh代理，需要手动换成git自带的ssh工具，如图所示：</p>
<p><img src="https://raw.githubusercontent.com/wxsms/wxsms-img-holder/master/20151208162525.png" alt=""></p>
]]></description><pubDate>Tue Dec 08 2015 16:26:07 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/git-ssh-key-gen-and-gitextension-configuration</link><guid isPermaLink="true">https://blog.wxsm.space/p/git-ssh-key-gen-and-gitextension-configuration</guid></item><item><title>第十章</title><description><![CDATA[<p>虚无的空间渐渐模糊，再次变得黑暗，当刘意恢复视力的时候，却是置身于一个小房间中，这房间的风格朴实，简单，给人的感觉是到处都是褐色的，只有两个壁柜，一张看起来十分沉重结实的木凳子而已。很快的，母体烙印便给出提示：</p>
<p>“这里是你在母体里的专属房间，外人未得你允许不能进入，你身上不可携回现实世界的装备均将存放在此。若是身体有所创伤，在此可以迅速恢复，同时扣除一定积分点数。进出本房间的钥匙就是母体烙印，在母体中，母体默认对你的外表模糊化，因此与他人交流时候，切勿透露自己在现实中的身份，以免引来不必要的严重后果。有任何需求，可以通过母体印记索取查询，但均要消耗一定数量的积分。”</p>
<p>刘意思索着这番话的含义，稍顷她出声道：</p>
<p>“查询我目前所拥有的积分，并且解释潜能点的用处。”</p>
<p>很快的，她就得到回应：</p>
<p>你离开剧情世界的时候总分为1550分，扣除任务必要条件300分。目前拥有的积分为：1250分。潜能点乃是用来升级基本技能和战斗技能所用。</p>
<p>战斗技能初始只能学习三个，基本技能以及基本技能进阶修炼则不受此限制，共有八项，分别为基本腿法，基本拳法，基本掌法，基本近战，基本远战，基本步法，基本擒拿，基本腰力。</p>
<p>学习高级战斗技能的前提，大多都需要娴熟的基本技能为支撑。例如先前袭击你的人使用的技能回旋攻击，是从街头霸王二中剧情人物狮王布兰卡(BLANKA)处习得，学习回旋攻击的前提是，基本腿法LV12，基本步法LV9，基本腰力LV13。</p>
<p>一些高级装备，也需要某些战斗技能或者是基本技能进阶才能装备。如您获取的：奈克斯的赤血手套，便需要空手搏击术五级。而学习空手搏击术的前提，则是要基本近战LV3，基本拳法LV7，基本腿法LV6。技能等级越高，提升起来耗费的潜能点就越多。例如将一项基本技能从1级升到10级，需要的点数是1X3+2X3+3X3+4=22点！若是战斗技能，那么耗费的潜能点就更多！每完成一次隐藏任务，将视难度获得1到5点的潜能点。</p>
<p>技能的提升也可通过对自身刻苦的锻炼达到目的，通常只是在学习新技能或是遇到瓶颈时，才使用潜能点。比如一个在现实世界中的世界散打冠军，那么很可能她刚入世界，就具备了高级的基本拳法，空手搏击术等技能。</p>
<p>基本技能和部分战斗技能可以在母体中以积分购买后，运用潜能点提升。高级技能则要通过自行领悟或者在与剧情世界中的人物互动后习得。</p>
<p>看到这里，刘意已经对此有了大概的认识。她想了一想后，发觉自己目前的潜能点一共六点，又调出了母体印记中的储物空间，发觉先前一战时候，自己放在里面的许多战利品纵然是因为“不可携出本世界”的属性而掉落，但是还是有许多东西剩了下来，其中价值最高的便是杀掉那火红色巨锤士掉落的银币二十枚，可以换取1000积分。此外还有好几十件品质低劣的银饰，加起来也可以林林总总的兑换六百五十点积分。当然，那对绿色套装手套与斯科恩的狂战斧她是没有打算要处理给商店的了。</p>
<p>拥有了两千余积分的刘意，却面对眼前调出来的基本技能出售栏大皱眉头。一个LV1的基本拳法都要2000积分来购买，而购买后还得使用潜能点升级。她自然不愿意将目前有限的资金在这上面耗费一空。</p>
<p>推门出去自己的专属房间以后，刘意回头一看，那门户已经完全溶解在墙壁上，看不出丝毫痕迹，并且还在作着匀速的移动，这当然也是为了他人从房间来对号入座辨认你的身份。</p>
<p>刘意转身过来抬头一看，饶是她早有心理准备，一时间也有些恍惚，眼前竟是一个巨大无比的空间！若要准确的说，周围的墙壁就仿佛是一个拱形的巨大蛋壳，而自己的房间就被包围在壳中。地面并不坚硬，反而有些微软，给人的感觉似是橡胶一般，还发出微微的光芒，而眼前是宽阔异常的广场，少说也有近千人在上面或蹲或站，嘈杂说话，像是菜市场一般，只是每个人的头部都笼罩了一层雾气，氤氤氲氲的连五官也看不真切，想来是母体特设的保护作用。</p>
<p>刘意信步就向最近的一个聚集处行去，果然不出她的所料，蹲着的人是在摆摊出售东西，尽是一些从剧情世界中带出来的装备什么的，甚至她还发现了E级技能切割术卷轴当然，价格也低廉无比，只售60点积分而已，并且显然无人问津。她咬了咬下唇，看了看自己掌握的真实之切割术，只觉当真是因祸得福了。</p>
<p>这时候她逛完一半地方，却看到了一本基本步法LV3的羊皮卷，这羊皮卷上还泛出暗淡的金色，微微一怔，行过去拿了起来。母体中不似剧情世界，自然有保护机制，其中规则良多，不能攻击他人，交易也有自动的检测保护机能。</p>
<p>随即她立即得到提示，基本步法LV3卷轴，学习后可以直接掌握基本步法LV3，并且只消耗一点潜能点。</p>
<p>她上下打量了一下卖主，这人身材魁梧，虽然看不清楚面容，却也可以看出乃是白种人，他或许会对自己的那件银色剧情装备斯科恩的狂战斧有所兴趣，便先问价道：</p>
<p>“怎么卖？”</p>
<p>那白种人张口吐出一串流利的法文，刘意虽然甚是聪明，但竭尽全力也只能知道他说的是法文，若是在现实世界里，其具体内容则完全茫然，而此时母体烙印则直接将对方要表达的原意翻译了过来，连其中的不耐烦之意也表达得惟妙惟肖。</p>
<p>“两万积分。”</p>
<p>刘意现在的所有身家，还不到他索价的十分之一，那卖家似乎看出刘意拿不出来，不耐烦的挥挥手，要赶人滚蛋。但有了母体的各种安全保护措施，刘意也就放下了不少戒心，微微一笑，将那把银色剧情武器斯科恩的狂战斧摆了出来。</p>
<p>这人先前还咕哝了几句破铜烂铁，但见到这斯科恩的狂战斧上闪耀的淡淡银光，立即动容，伸手就拿了过去把玩。单单是攻击倒也罢了，那特殊属性却着实令人心动，立即叫了人来。</p>
<p>他们两人在一旁咕哝，刘意倒很是想知道这两人说些什么，忽然右肩一热，母体烙印的两只狰狞眼睛骤然发出微弱的血红光芒，这两人刻意压低了声音的谈话却一字不漏的传入了她的耳中。</p>
<p>“戈登，这玩意儿攻击虽然低了些，但拼着耗些钱去对面的锻造室把它升上几级，倒也绝不吃亏。何况武器升前6级的时候，爆掉的可能很小的。”</p>
<p>“嗯，我听说那群美国人每月都要花积分和道具进圆桌武士世界去刷一次，目的就是为了弄这把斧头，预备过那一个死亡率极高的关卡用。”</p>
<p>“这菜鸟不知道怎么弄来的，真走运。”</p>
<p>他们却不知道这东西是刘意做隐藏任务时候，单人杀死斯科恩才获得的。因为一来隐藏任务有爆率的加成，一来刘意又是首次进入剧情世界。所以才爆出的奖励极好。</p>
<p>而刘意却从这两人的对话中获得了好几条极其有用的信息：一，装备可以通过在这母体中的锻造室中升级进行强化。二，每一个月可以花费积分去指定的某个世界探险。三：这把斧头特技似乎适合一个难度极高的场景。而且似乎大多数人都必须经历。四，她可以放心大胆的狮子开口敲一笔了。</p>
<p>……</p>
<p>戈登两人商量了一会儿，慢悠悠的走了过来，傲慢道：</p>
<p>“你这斧头不错，不过换我这本技能卷轴还差了些，加些积分就换给你。”</p>
<p>刘意淡淡“哦”了一声，拿了斧头转身就走，那人只当她会嫌贵还价，哪里知道是这种结果？双目圆睁，却见这小子竟然凑到了旁边的那英国人的地头上去了，他眼珠子都几乎瞪了出来，这东西落到了那英国人手中，哪里还有自己的份儿？急忙大步赶上去拉住刘意道：</p>
<p>“嘿，有话好商量。”</p>
<p>刘意也不是真想走，她对那本书其实也极有兴趣，这基本步法决定了移动的速度，对自己大有帮助，并且还能节约下两点珍贵的潜能值。并且她到目前为止，已经逛完了小半个市场，依然没有发觉类似的卷轴，而面前这两人想来早已将基本步法练了几级，自然这东西派不上用场。</p>
<p>她故意将斯科恩的狂战斧拿了出来，令其上微弱的银光不停闪现，不急不徐的道：</p>
<p>“算了，你们的卷轴卖得太贵，还是不换了，我去其他地方转转吧。”</p>
<p>戈登悠悠道：</p>
<p>“便宜一些也不是不可以，这样，我也不要你加钱了，就拿技能卷轴换长斧吧！”</p>
<p>刘意忽然叹了口气道：</p>
<p>“其实我都学了2级基本步法了，这东西对我基本没多大用。”</p>
<p>戈登正想说话，另一人却沉着脸道：</p>
<p>“你要什么价，就直截了当的开出来吧。”</p>
<p>刘意心中一凛，笑了笑道：</p>
<p>“我都不知道你们有什么，这价怎么开得出来。”</p>
<p>那人倒是十分爽快，将刘意拉到一边，直接将能拿出来交换的东西都拿了出来。但其中大多都是蓝色装备，唯一一件金色的却是一个加敏捷3，精神力4，施术损耗-1的戒指，叫做豺狼之戒。</p>
<p>刘意微微摇了摇头，她自知自己精神力比旁人高出许多，因此刻意的就想交换，寻找一些需要高精神力才能修炼的技能或者装备。然而这种装备，技能似乎十分稀少。而那个金色戒指上的施术损耗1的属性也十分宝贵，就是说施展技能本来需要2点精力的，现在只要1点就可以了。</p>
<p>遗憾的是戒指中特别注明：若那技能只耗费1点精力，那么则不受本戒指的影响。</p>
<p>她想了一想，抛出了一个匪夷所思的价格：</p>
<p>“拿戒指和那本技能书来换我的斧头。”</p>
<p>听到这句话，那人似被戳痛了的猴子一般叫了起来，咬牙切齿的道：</p>
<p>“休想！”</p>
<p>刘意很无奈的摊开手叹了口气，便转身离开了，她书读了不少，自然懂得用最小的代价来换取最大的价值。于是继续在摊位中穿行，寻找着自己希望找到的东西，直到走到尽头，一无所得的刘意不仅没有沮丧，反而急忙调出只能在母体中才能查看的菜单仔细搜寻，微微一笑，确定了一件事情，于是也开始摆起摊来。</p>
<p>“她卖的，便是那在圆桌武士世界里携带回来的黑麦点心！这东西是由不能携带的黑麦面包制成，一个面包能够切割三块，虽然这东西消耗挺大，但是那黑麦面包的爆率也挺高，以至于她眼下还剩了三十余块左右。</p>
<p>而一块黑麦点心，刘意卖的是100积分！她敢卖这么贵的原因十分简单，母体中所出售的能在战斗时候疗伤的药物昂贵非常，就是只恢复100点体力值的，也要800积分，并且服用后，还有高达半小时的冷却时间！</p>
<p>很快的，就有人走了过来，拿起她卖的东西：黑麦点心：(纯正)，类别：食物，可携带，效果：回复体力值十五。看了看以后，也不还价，直接就买走了。</p>
<p>隔了不久，正有另外一个人想将刘意面前仅存的五块黑麦点心全部都给扫了。</p>
<p>谁知道一个魁梧的身影强行挤了过来，那人十分恼怒，没好气的道：</p>
<p>“你加十块这个点心，戒指和书就拿去。”</p>
<p>刘意微微一笑，将那把斯科恩的狂战斧递了出去道：</p>
<p>“成交。”</p>
<p>她此时觉得自己占了好大便宜，索性把剩余的二十块黑麦点心全交易了过去，那人面色稍和，重重的把戒指和羊皮卷拍了过来，转移了拥有权。刘意笑了笑，转身走开后，顺手便把那枚黄金色的豺狼之戒装备上了。</p>
<p>此时也已经淘不到什么好东西，便回到了自己的私人空间里，直接花费了2000积分，学习了那基本步法LV3卷轴。立即觉得浑身上下都轻松得多了，连行动速度也增加了三分之一左右。同时得到提示：基本技能提升以3级为一个阶段，1～3级只需要耗费1点潜能点，3～6级每升一级，则需要2点潜能点，6级以上每提升1级技能，则需要3点潜能点，刘意支持着看完，已经觉得精神颇为困倦，便调出空间菜单草草设置了一个卧室和浴室简单洗漱之后就睡了。</p>
]]></description><pubDate>Thu Nov 12 2015 00:10:11 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/matrix-chapter-10</link><guid isPermaLink="true">https://blog.wxsm.space/p/matrix-chapter-10</guid></item><item><title>第九章</title><description><![CDATA[<p>照理说，寻常人遇到这等恐怖之事，早已吓得手脚酸麻，但是刘意是什么人？一个年幼时就敢设下杀人圈套的变态！其心理素质何等稳固，何况此时还是鲜血杀戮，体力武力都是颠峰状态的战士？</p>
<p>她不待那只手掌发力，手中的短剑已是挥割而出，生生将那只外焦里嫩的黑手斩断！</p>
<p>那只被烧得焦黑的手掌被远远的割飞，掉落在地上，啪嗒一声抽搐着，而断腕处却并没有流淌多少血出来。</p>
<p>刘意面带笑意地继续向下掘着，忽然一顿，眼前出现了一片隐约可见血纹的重型盔甲碎片。她在心中微微谓息，巴拉森虽然只是她手上的一枚棋子，但两人相处的这些时光，也终究不能一带而过。</p>
<p>很快的，眼前又出现了一只痉挛挣扎着的焦黑手臂，还在袅袅的冒着烟气，刘意毫不犹豫，一刀就砍了下去。废墟里立即又传来一声极其闷钝的尖叫！分明是斯科恩的声音，少女眯了眯眼睛，像是在回味似的想了想，转身换了个方位继续挖掘，不久又将斯科恩的双腿也刨了出来，直接斩断。最后才将之完全掘了出来。</p>
<p>斯科恩自然是奄奄一息，身上那套银色盔甲也早为烈火所溶，但也变相的保住了他的一条性命，刘意想了一想，却不急杀他。她心中又有了打算，找来一块尚完好的木板系上绳子，将已被削成人棍的斯科恩载上，仿佛一个满载而归的土匪蟊贼一样愉快地哼着歌，徐徐拖着身后的木板找地方藏了起来。</p>
<p>……</p>
<p>十四小时后。</p>
<p>三个气度不凡的男人行进了这所还冒着袅袅青烟的小镇。这三个男人中，一人使弯剑，一人用双手重剑，另外一个肌肉男人则持了两把大斧，便是三名剧情主角的蓝斯洛，普西奥和亚瑟。他们三人看着充满了血腥杀戮的战场，眼神十分愤怒，持斧头摔先冲前，就要去找寻这屠庄的凶手。而这三人的身后，则还随了整整十名穿着打扮都杂乱无章，完全与这个世界格格不入的人。</p>
<p>第820小队！</p>
<p>看着三名剧情主角向前走去，那十人也出现了一阵骚动，很快就有一个声音喝道：</p>
<p>“跟上，快跟上，这一次对你们这些菜鸟来说只是锻炼，没什么风险，能多捞些积分就多捞些积分，若是能将斯科恩从这三个家伙手里抢到最后一下，那就是最好不过的了！”</p>
<p>剩余的人一惊，纷纷赶了上去，只是他们寻觅良久，却发觉一片死寂的镇子里，只有袅袅青烟和遍地的尸体，诡异无比。一干人却乱作一团，忽然惊叫起来：</p>
<p>“任务失败！怎么会这样？刚刚进来为什么就会失败？”</p>
<p>然而残酷的现实令这些乱叫的人开始惨叫起来，痛楚倒地抽搐，很快的就死去。三名剧情人物此时已经走远，根本没有发觉这一幕，这时候，躲避在不远处房屋中的刘意才用力斩断了人棍骑士斯科恩的脖子！她甩了甩手上的血，满意的看着自己的任务栏：</p>
<p>任务一，杀死七名面具奴仆，两名重剑士，获得积分300以上。</p>
<p>未完成：面具奴仆7(43)，重剑士2(7)，积分300(299)。括号内是已经达到的数值。</p>
<p>任务二，阻止编号第820小队杀死惩戒骑士斯科恩。</p>
<p>任务已完成。</p>
<p>任务三，令编号第820小队中至少减员4名成员。”</p>
<p>任务已完成。</p>
<p>隐藏任务：巴拉森的救援，任务难度中(C等级)。任务目标：帮助巴拉森见到玛丽娜，时间限制，8小时。</p>
<p>已完成。奖励：1点潜能点。</p>
<p>隐藏任务：刺杀惩戒骑士斯科恩。任务难度，A，任务目标，取得惩戒骑士斯科恩的头颅。任务时限，二十四小时。</p>
<p>已完成。奖励：2点潜能点。</p>
<p>选择此时才杀死斯科恩，刘意是经过了深思熟虑的，若在这些人未进入前杀掉，很难说他们的任务会不会出现改变，若是对手有了警觉，那么杀死他们其中的4人未免就要大费周折了。而这时候来干这件事，虽然麻烦了些，才是万无一失，不会出现任何纰漏！</p>
<p>“现在……是应该完成任务的时候了？”刘意很仔细的想了一想，她的手中把玩着一件普通的银饰，只要将这东西立即使用母体烙印兑换成积分，那么就可以彻底完成任务。</p>
<p>“不，还得等等。”刘意从斯科恩的身上寻找到了一把淡金色的钥匙，顺手打开了召唤出来的淡金宝箱，得到了一条金色腰带和一件武器。</p>
<p>“巨力之骑士腰带：神话，佩带前必须通过灵魂绑定，品质标准，增加力量2点，母体烙印空间20格。需要力量5，敏捷3。能够携带出本世界。可以用来兑换500积分。”</p>
<p>“斯科恩的狂战斧：银色剧情装备，双手武器。仅可能由惩戒骑士斯科恩所掉落，佩带前必须通过灵魂绑定，品质标准，攻击5～13，攻击敌人时有50%的可能出现横扫效果：在3秒内攻击速度提高100%，对周围敌人造成自身攻击30%的伤害。需要力量二十二，体力17，基本近战LV2，基本腰力LV4。装备剩余属性：未鉴定。注：鉴定后很可能出现装备需求提升，请谨慎行事。”</p>
<p>刘意毫不犹豫的将腰带佩带上，其余两件收入了被扩展了的母体烙印自带的空间中，顿时觉得轻松了不少，她是一个谨慎的人，在没有寻找到代替品以前，是不愿意用真实切割术对其进行加工的，毕竟还是有21%的装备消失的可能。</p>
<p>她这时候的目光却是盯住了街道之上。还有一个人影立在了横七竖八的尸体当中，这人影看起来矮小猥琐，先前在那十人中乃是最不起眼的一个，然而偏偏貌不出众的他，却能活下来！</p>
<p>这个人……很不简单！一定有什么特殊的道具能够保证他任务失败后都不会被抹杀。</p>
<p>搞不好……是个资深者！</p>
<p>刘意见这人呆在那里，似是一动不动，可是猛然间，他便浑身上下缩成了一个球一般，高速旋转着以难以想象的速度向自己这方滚撞过来！单是劲风扑击到面上，便是生疼！</p>
<p>“哗啦！”一声，石墙竟被生生撞裂，那一撞之势竟是如此猛烈！</p>
<p>刘意乃是决断之人，立即醒悟了过去，这人先前的呆滞，必定是在查看母体烙印传来的任务提示！而他的任务，很可能就是杀死自己！他的技能如此迅捷猛烈，目前定是难以匹敌，因此她在奔逃的过程中，毫不犹豫的卖出了那只早就预备好的高级银饰！激活了任务一的完成条件！</p>
<p>面具奴仆7(43)，重剑士2(7)，积分300(550)。</p>
<p>“你的积分已经达到任务要求，是否选择回归母体空间？”</p>
<p>刘意立即选择了“是。”这时候，那矮小猥琐的男人的滚撞已再次发动！只是他这一次撞到的，却是空气！这少年的身体，已经渐渐变淡，消失，只有嘴角的那丝嘲讽的微笑，留存在他的记忆当中。</p>
<p>虚无的空间中，刘意面前出现了一个巨大的屏幕。她杀死面具奴仆，重剑士，以及坑死的那九名820小队成员的情景一一闪现，接下来是重剑士首领斯温与惩戒骑士斯科恩的被杀。而那名重锤巨盾士奈克斯因为是巴拉森所杀的缘故，所以未能计入。</p>
<p>接着屏幕出现了以下信息：</p>
<p>场景：圆桌武士1-1幕，痛觉削弱度70%，个人近战能力强化度2倍。场景难度D级(容易)。</p>
<p>任务完成度：80%</p>
<p>任务完成评价：A，注：最低级为：E，最高级为完美SSS。</p>
<p>任务奖励：自身属性强化点，3点，潜能点数：2，积分1000。</p>
<p>人物目前潜能点为：初始3点+5点减学习技能所用1点=7点。自身属性强化点数已经自动分配。刘意一看，点数全加在了精神上。然后屏幕化作一团耀眼的白光，将她吞没。</p>
<p>其实她此次经历的这个世界的任务实在是可难可易。若是对自身没有信心的人，大可以杀够面具奴仆，赚够积分后便袖手旁观。因为这一次的820小队中，多出了那名身材矮小的资深者，所以惩戒骑士斯科恩的难度是非常高的。</p>
<p>而刘意能将之单杀，不仅是因为巴拉森自身进化了一次，属性变态的关系，从很大程度上来说，那柄异变过后的裂魂大棒却是起到了十分关键的作用。要是她什么都不做，任820小队去正面碰撞斯科恩，尽管他们有三名剧情人物的帮助，但是一出来这些人就会被斯科恩的军队所围困，令820小队减员四人简直易如反掌。</p>
<p>而最后斯科恩虽然会被打败，却会有极大可能是被三名剧情人物所杀死。820小队中人自保都成问题，哪里还有空来拣这便宜？只有那名资深者有一定可能令刘意的任务失败，但是在这母体世界里，生或者死的风险本来就是极高，又哪有百分之百的事情？</p>
<p> </p>
<p>PS：关于剧本结算奖励中的自由属性点被自动分配的说明。原本在笔者的设想中，这种类似于无限恐怖世界观的引擎，应该是具有高度自由性的，属性点分配也应该是由轮回者自行分配。但是前期在考虑到一些可能出现的问题后，又不得不改为自动分配。分配的原则是根据轮回者在当次表现最突出的那部分能力，小依理所当然的被全部加了精神。</p>
<p>可能出现的问题①，因为前期新人在面对剧本怪物时的脆弱会促使相当大一部分人选择体敏对点，极端甚至病态地追求生存与逃生能力，造成同质化效应剧烈，这违反了母体存在的初衷。</p>
<p>问题②，玩过经典RPG的老骨灰都知道，自由分配属性点搭配人物技能造成的实力区间可以大得离谱，以暗黑破坏神2为例，一个老手玩家通过合理地分配属性点和技能点在普通难度下不到两个小时就能杀到大菠萝的闺房而且把他办了，而若是不合理的分配或者说因为被国产游戏荼毒太深而在加属性和技能点上惯性地追求均衡追求特色或者什么团队互补之类，那恐怕连艹个安达利尔也会被反日，然后卧薪尝胆洗心革面地去找小boss刷等级刷装备，好好的一个通关游戏硬是玩得跟种田似的，说是菜鸟但对游戏数据有能说得头头是道，什么门道都略懂一点，只能说是思想变成了羔羊，空有一身力量却不懂得运用，遇到了难题总是下意识地去寻求更强力的装备和技能来解决问题。</p>
<p>以上也是笔者多年玩游戏经历的感悟，真可谓痛心疾首，扼腕叹息。</p>
]]></description><pubDate>Sun Nov 01 2015 18:13:12 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/matrix-chapter-9</link><guid isPermaLink="true">https://blog.wxsm.space/p/matrix-chapter-9</guid></item><item><title>第八章</title><description><![CDATA[<p>巴拉森与刘意到达村外的那一刻，惩戒骑士斯科恩率领的军队也刚好突破防御，攻入小镇。开始杀人放火，掠夺抢劫，镇上的一些富人贵族也不会束手待毙，趁着这混乱便赶着马车四散而去。</p>
<p>斯科恩自然不会看着这些油水丰厚的家伙溜掉，一声令下，便有人追奔而去。逃走的马车一共五辆，斯科恩手下具备骑术的，就只有和巴拉森同一兵种的重盾巨锤士，这些钢铁堡垒纷纷追出，正好符合了刘意的预计。</p>
<p>面对这些恶名昭彰的凶残部队，绝望了的镇民纷纷聚集到附近坚固的建筑物里进行最后的殊死抵抗。因为要掠夺财富的缘故，那些重剑士与面具奴仆又不敢放火焚烧，因此竟是陷入了局部的僵持，斯科恩的兵力，就被成功的分散了开来。</p>
<p>刘意便在这个时候率领巴拉森潜入了村中。</p>
<p>凭借巴拉森身上的盔甲，他们一路上根本没有受到拦阻。在黑夜的火光朦胧下，他盔甲上的血纹并不明显，反而散发出一股敬畏之意，令得所到之处的重剑士与面具奴仆都是纷纷退让。</p>
<p>很快的，他们就见到惩戒骑士斯科恩正立在镇中一处地势较高的台上，身边只随侍了两名重剑士与四名面具奴仆。这强大邪恶的骑士身高近两米，浑身上下都被保护在了银白色的甲胄里，连脸都没有露出来，给人以一种细长，敏捷的感觉，手中持的，是一柄长而可怕的银色斧头，单单是看了，就能构想出它挥舞起来的莫大杀伤力。</p>
<p>见到这个家伙，巴拉森的呼吸立即粗重了起来，就仿佛是铁匠在拉着一口破旧的风箱。刘意望了一眼他赤红的眼睛，忽然幽幽的道：</p>
<p>“你害怕了？”</p>
<p>巴拉森猛然转身过来怒目而视。</p>
<p>刘意面无表情的道：</p>
<p>“若想为玛莉亚复仇，你最好还是听我的。”</p>
<p>提到玛莉亚三个字，巴拉森仿佛遇到了克星一般退缩了，只有那对赤红的眼睛，仿佛噬人太多的凶兽，在火光里分外觉得凶残。默默的等候着刘意的布置。</p>
<p>很快的，斯科恩旁边的人手就发觉旁边有一个惊慌无比的平民，背着个大包袱慌慌张张的跑了过去，路上想来是过于忙乱的缘故，还摔了一跤，包袱里跌出了许多黄澄澄的金币，一干人的眼睛都直了，连斯科恩也咽了口唾沫，略一点头，身边的四名面具奴仆就冲了过去。</p>
<p>然而黑暗就仿佛将这四人吞噬了一般，再也没有反馈出任何声音。这也难怪，巴拉森手上那根异变之裂魂大棒乃是何等强劲的武器？加上这变异重盾巨锤士力量高达五十，敲到这些面具奴仆身上，还不是一棍一个？</p>
<p>那两名重剑士对望一眼，心里不惊反喜，他们丝毫没有想到会有人暗袭，倒是怕这四人见钱货众多，私吞逃了，也不请示立即追了出去。很快黑暗里传来两声金属撞击巨响，好一会儿才传来“扑扑”两声落地的轻响，就仿佛是两口破麻袋跌落在地。</p>
<p>斯科恩凝了一凝，嗅出了其中的阴谋味道来，但是他毕竟自视甚高，便拖着自己的长斧拔下一支火把行了过去，他身上的盔甲乃是魔法加持，品质极佳，只是在行进间要发出哐当眶当的声音，刚刚转过弯角，斯科恩就踢到了一具凸眼吐舌，死状凄惨无比的尸体，看样子乃是一名面具奴仆，身下暗红色的血液正汩汩流淌而出。</p>
<p>紧接着数十步以外，又有一具头颅被砸得似个烂掉西瓜的重剑士横在当地，血迹一直徐徐延伸到旁边的一座坚固仓库中。斯科恩正有些踌躇，忽听里面传来一声剧烈惨叫，一惊之下，急忙赶将进去。</p>
<p>阴暗的光线里，有暗红色的条纹闪动，迎面就有一股血腥杀气直扑而来，还有空气被极速破开的呼啸声。斯科恩冷冷一笑，这种程度的攻击还不放在他的眼里，竟是不闪不躲，运力使动斧头，横斩而出！</p>
<p>只听“卡啪”一声巨响，火光四溅，整座仓库都为之颤抖，尘土簌簌落下！斯科恩这志在必得的一斧，竟是落了个空，生生斩在了旁边的石柱上！深入近尺，</p>
<p>而暗中突袭的巴拉森，一锤就敲在了斯科恩肩头的铠甲上，连串火星溅射而出，发出了“乓当”的怪异清脆响声！</p>
<p>巴拉森先后连杀六人，无论杀势还是心中的战意，都被激发到了最高点上，他此时含恨一击，却只能将斯科恩打了个踉跄！两人之间的差距，可想而知！</p>
<p>斯科恩虽然浑身上下铠甲的防护力惊人，只是一直被人压着打不能还手，却实在是忍不下这口恶气，他怪叫连声，奋力斩出数斧，却都为周围的石柱所阻，白白吃了几下重的以后，索性将斧头抛了，空手来斗这区区叛徒重盾巨锤士。</p>
<p>此处却是刘意精心选择的战场，目的就是要这大BOSS以己之短，来战己之长，然而她潜在一旁越看越是心惊，这空手的斯科恩竟也能与巴拉森斗了个平手，更是渐占上风。她身上的银色铠甲防护力十分强大，打了片刻，巴拉森的损血值已近半，而斯科恩还不到五分之一！</p>
<p>这时候，刘意轻吹了一声口哨，巴拉森自知其意，立即留神，而斯科恩却是一头雾水，猛然见对手转身就逃，立即尖声嘲笑着追了过去！谁知道脚下忽然一紧一滑，身体都失去了平衡向前跌倒过去！</p>
<p>原来刘意早在暗中缚了许多绳索，一等机会，便将其拉直，巴拉森自然知道，便小心脚下，而斯科恩立即中计！</p>
<p>巴拉森趁机往嘴里塞了数块能够持续回血的黑麦点心这自然是刘意的杰作，然后身上冒出血光，狂吼一声猛扑了上去。这一扑却是用上了他的技能。</p>
<p>怒意狂击：在瞬间击出8次，每次的攻击力是普通攻击力的30%，需要耗费1点精力值。</p>
<p>只听得：“乓当”“乓当”的敲击盔甲的连串声音响了起来，还伴着斯科恩狂怒的尖叫声。原来这怒意狂击却又触发了那异变之裂魂大棒上的武器特技：有15%几率对敌人造成额外10点伤害并且出现失明效果。</p>
<p>斯科恩的血条骤然掉落，眼前更是一片黑暗，看不到任何目标，他踉跄着爬将起来，手舞足蹈的好像是一个醉汉，而巴拉森躲到一旁，继续吞吃着能够战斗回血的黑麦点心，尝到了甜头的他等到怒意狂击冷却以后，骤然再次和身扑上，施展技能！</p>
<p>又是连声脆响，还未从失明效果中恢复的斯科恩再中特效，无论他怎么强大，无论他如何霸道，骤然由一个明眼人变作了瞎子，这其中的不适应可想而知。便是想要挣扎反击，却是拳拳着空，处处碰墙。反倒是巴拉森在刘意的特制黑麦点心的滋润下，血量徐徐回升。</p>
<p>只是这良性循环持续了没多少时间，却发生了一件很致命的事！</p>
<p>巴拉森的精力值耗完了！</p>
<p>他纵然是等同于一个小BOSS的存在，然而也不能不遵守世界的规则，并且看他的模样，也怎么不像是那种很有头脑的家伙，智慧极高的家伙，倒是四肢着实发达。</p>
<p>但是此事也依然在刘意的预计之中。</p>
<p>她手中一晃，便已点燃了外面早已堆好了的柴草。</p>
<p>此时镇中四面火起，决计无人能注意到这么一间仓库着火。而刘意布置许久，这火势越发凶猛，瞬间就焚得周围一片通红，火光照出屋外刘意眼中的森然冷意，也点燃了火中巴拉森眼里的惊怒、绝望，与决然。</p>
<p>巴拉森本来就是万念俱灰，他猛的冲身，死死将斯科恩拖在仓中，奈何两人实力相差过大，终于还是被他挣脱冲到了门口。巴拉森奄奄一息的瘫在地上，命在旦夕。</p>
<p>但是门口却忽然多出来一个人！</p>
<p>斯科恩哑叫一声，凶残出手，抓住了那人的肩头一阵疯狂撕扯，竟将这个人的血肉之躯若布条般生生扯得粉碎，只有头颅在空中抛飞，骨碌碌的滚到了倒在地上，此时的巴拉森头盔都被打飞，满脸鲜血的，奄奄一息，然而见到了这头颅，竟是不知道哪里来的力气，势若疯虎的扑出将斯科恩生生拖回了火场当中！</p>
<p>先前挡门的那个人，却是一具尸体。</p>
<p>玛莉亚的尸体！</p>
<p>这时候大火已经烧透顶蓬，大梁不断坍塌落下，轰然将出口堵死。熊熊烈火，烧碎了一切逃生的希望。</p>
<p>……</p>
<p>大火整整烧了一个多小时。</p>
<p>刘意口咬着短剑，在这附近也捕杀着落单的那些面具奴仆，她经过了这段时间的洗礼，身上又有世界属性的加成，因此若不是直接与重剑武士交手，便是大有胜算，加上面具奴仆装备的爆率虽然极低，但是十个中，总还是有一人能留下个木箱子，里面大多都是黑面包一个。</p>
<p>有了她的真实之切割术的支持，常常能将这等只能在非战斗状态下使用的劣质食物，化为战斗中都能持续恢复的黑麦点心。</p>
<p>因此渐渐的，刘意在这场杀戮中，技巧也渐渐娴熟，各种属性也开始徐徐提升这种提升于每一个初入此处的新人来说，是自身潜力被渐渐开发出来的表现，都是再正常不过的。不过此次过后，若无奇遇，自身属性便被基本固定，只能慢慢增长了。倒是自身的技能，或者可以通过磨练，或者可以通过完成各种任务后所给出的潜能点进行学习提高。</p>
<p>当仓库的火渐渐熄灭以后，刘意看了一下自己的属性已是大有增长，力量8(6)，敏捷10(6)，体力8(6)，精神力17(5)。注：并未计算世界属性加成，括号内为正常30岁成年男人素质。正面单挑一名重甲剑士已无问题。自身大概只耗费不到一半的血量，在黑麦点心的滋润下，就能很快恢复。</p>
<p>而失去了首领BOSS的指挥以后，攻入镇中的那些面具奴仆与重剑士也士气渐渐低落，还有掠财逃跑的，偏偏那些主持局面，能够骑马的重盾巨锤士又去追击逃跑的人，一时间局面竟是被镇中决死一战的民众徐徐反扳了回来！</p>
<p>刘意却在翻动着废墟。</p>
<p>她可没有忘记自己的任务条件：</p>
<p>隐藏任务，刺杀惩戒骑士斯科恩。任务难度，A，任务目标，取得惩戒骑士斯科恩的头颅。任务时限，二十四小时。</p>
<p>眼下距离二十四小时的期限还很是充裕，这斯科恩的头颅也得早取，迟则生变。</p>
<p>但就在这时候，废墟下忽然伸出一只烧得焦黑的手掌，猛然捏住了刘意的咽喉！</p>
]]></description><pubDate>Sun Nov 01 2015 17:17:11 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/matrix-chapter-8</link><guid isPermaLink="true">https://blog.wxsm.space/p/matrix-chapter-8</guid></item><item><title>第七章</title><description><![CDATA[<p>巴拉森粗壮的身躯忽然定住，他呆滞的望着玛莉亚痛苦呆板的面容，还有那只惨白色下垂的手臂，正在微微的摇晃着。这一刻，他忘记了疼痛，忘记了凶险，忘记了一切，取而代之的，是铺天盖地，汹涌而来的狂怒！</p>
<p>这时候，刘意肩头的母体烙印忽然发出提示：隐藏任务完成，获得潜能点1，本关评价上升，巴拉森已由黑铁重盾巨锤士，异变为血腥重盾巨锤士！</p>
<p>这提示刚刚一响起，只见那头本来占据上风的火红色重盾巨锤士忽然闷哼一声，踉跄倒退，而巴拉森直冲了上去，低头顶在了他的胸口，剩余的那只长角，深深的刺入了他的盔甲当中！</p>
<p>一股鲜血从盔甲的缝隙间直浇了出来，淋漓泛滥而过，巴拉森狂吼一声，埋头猛撞对方胸膛，每一下凶狠的冲撞都刺出一个个喷洒着血浆的黑洞！甚至隐约可见里面森森的白骨，那股股血液洒在他的盔甲上并不掉落，却是流淌出一条条诡异血腥的纹理，仿佛是猛兽身上的花纹一般！</p>
<p>刘意看着巴拉森仿佛凶兽一般的气势，心中也是骇然，哪怕在对手失去了生命的情况下，巴拉森也疯狂将之践踏，攻击，直到其变成了一摊烂泥也似的血肉！</p>
<p>让他平静下来的是玛莉亚的尸体。</p>
<p>刘意直接将这惨死的女子默默的放到了巴拉森的眼前，这狂暴的巨汉顿时僵住，扑倒在尸体上大哭起来，刘意在旁边却也没闲着，发觉那火红色重盾巨锤士的身体已经渐渐变得透明，也留下了一件亮银色珍藏，她行过去拾起，回到旁边的教堂中召唤出了一个亮银色的宝箱，打开以后，跳出以下显示：</p>
<p>“获得奈克斯的赤血手套一只(右)：至宝，品质纯正，佩带之前必须通过灵魂绑定，攻击47，附带掠夺效果，将对敌人百分之三的伤害转化为自身体力值。注：凑齐一对后，将会有特殊效果出现，装备后显示。需要力量十，体力九，空手搏击术五级以上，能够携带出本世界，可以用来兑换700积分。”</p>
<p>“获得银币二十枚，品质标准，贵重物：可以在中古时期场景中使用，可以用来兑换1000积分。”</p>
<p>刘意正在考虑要不要施展自己的真实切割术，外间却忽然传来沉闷的渐渐远去的脚步声，她急忙追赶了出去。只见巴拉森粗壮沉重的身躯正抱着玛莉亚的身躯离去，她微微皱眉，忙喊道：</p>
<p>“你要去哪里？”</p>
<p>巴拉森却根本不答她，自顾自向前走，而刘意哪里舍得让他走，直接冲上去挡住了他的去路，忽然望见了这浑身上下都被包裹在了钢铁中的凶汉的眼睛！残忍，桀骜，凶戾！她急忙后跳，避开了巴拉森由上至下的死命一击，泥土飞溅里，急切的道：</p>
<p>“难道你不想为玛莉亚复仇了吗？”</p>
<p>只有在听到玛莉亚三个字的时候，巴拉森的眼睛里才掠过一丝生人的活气，他铿锵有声的道：</p>
<p>“我已经给她复仇了！”</p>
<p>“不，”刘意故作愤怒的道：“杀害玛莉亚的凶手，其实是惩戒骑士斯科恩。若不是他要劫掠我们小镇，一切都不会发生！你若真的爱她，就应该杀死斯科恩！”</p>
<p>她故意冲上前去，托起玛莉亚的头颅，将她绝望的双眼呈现在巴拉森的面前，大声道：</p>
<p>“你看她的眼睛，死了都没有瞑目！你还敢说已经为她复仇了？你这个懦夫！你口口声声说爱她，其实是在害怕！”</p>
<p>巴拉森立即是中箭的野兽一般，痛苦的狂吼了起来：</p>
<p>“我爱她！我一直都深深爱着她！我并不害怕！”</p>
<p>“那你就不要逃！”刘意冷冷的道：“斯科恩明天就会来到我们这个小镇。我陪你去杀了他！”</p>
<p>……</p>
<p>这正是刘意所要达到的目的！她乃是将自己任务铭记在心中的。</p>
<p>“任务一，杀死七名面具奴仆，两名重剑士，累计积分300以上。”</p>
<p>“任务二，阻止编号第820小队杀死惩戒骑士斯科恩。”</p>
<p>“任务三，令编号第820小队中至少减员4名成员。”</p>
<p>“无法完成任务的后果：抹去。”</p>
<p>其中第一项任务虽未完成，但面具奴仆与重剑士的数量早已杀够，连积分也被刻意的压制在299上。可以说只要愿意，随时都能完成。</p>
<p>而刘意一直在思索二三项任务，看起来似乎只有一条路可以走，那就是等候820小队进入世界后，自己暗中狙杀，削弱他们的力量。或者干脆就反水投靠惩戒骑士以保证其存活。相信大多数人也觉得这是唯一可行的法子，然而刘意却不这样想，也许这个少女的脑洞和常人不一样，她从一开始就对这个任务的提示有着别样的理解：</p>
<p>“提前杀死惩戒骑士斯科恩！”</p>
<p>只要这第一幕最后的BOSS是由自己亦或别人杀死的，那么当然就阻止了820小队杀死惩戒骑士斯科恩，而他们无法完成任务的下场，多半也是被抹杀！</p>
<p>刘意也很清楚，自己无论如何造势，修炼，也定然是拿这BOSS无济于事的，这与智力，布局，临敌应变无关，完全是压倒性的力量决定了一切，只能借助外来的力量！</p>
<p>在这个世界里，具备打倒斯科恩力量的，率先想到的，就应该是剧情中的英雄亚瑟和他的小兵们。但他们显然应该是和820小队一个阵营的，因此可以排除。</p>
<p>那么，这力量就只可能由自己去发现，培养了，并且很可能是出现在小镇当中，果然，在发现了隐藏的剧情以后，少女就从中觉察出了一丝曙光，这巴拉森应该就是这个变数！最重要的是：连隐藏剧情的要求也隐隐在向她暗示：那便是“帮助巴拉森见到玛莉亚”，并没有提到玛莉亚必须是活着的呀！这端的是丧心病狂。</p>
<p>而按照原始的剧本，若刘意不杀玛莉亚，此任务的发展便到此为止，看到活着的玛莉亚后，罗伦将会帮助巴拉森杀死那小BOSS火红色重盾巨锤士，那么就会加速惩戒骑士斯科恩的到来，守村之战会提前展开。后果当然是镇子被提前洗劫，而820小队和剧情英雄出现时就直接会被斯科恩一群人所包围，加大他们的难度。</p>
<p>而此时巴拉森的变异，则将剧情延伸向了一个极其偏僻的支线发展路线上！这是一条险路，甚至是绝路，偏偏这少女又是个十分喜欢行险棋走偏路的人！</p>
<p>不入虎穴，焉得虎子？没有高风险，哪来大回报？</p>
<p>巴拉森默默的立了半晌，玛莉亚的鲜血顺着铁甲一点一点的淌落，浸润入去，她的眼神里尽是呆滞的绝望，好一会儿才道：</p>
<p>“好。”</p>
<p>这句话一说，刘意肩头的母体烙印又是一热，眼前立即生出提示：</p>
<p>开启隐藏任务，刺杀惩戒骑士斯科恩。任务难度，A，任务目标，取得惩戒骑士斯科恩的头颅。任务时限，二十四小时。</p>
<p>当这排信息显示完毕以后，刘意又得到提示：</p>
<p>因为派出的两拨手下头目：银色重剑士斯温与火红色重盾巨锤士奈克斯先后被杀。(因为刘意未学得侦察术，所以辨认不出这两名剧情人物的名字)。惩戒骑士斯科恩异常愤怒，提前发动入侵时间，将于二十小时后抵达小镇。</p>
<p>刘意望着这信息，若有所思。此时天色变黑，她引着巴拉森回到了附近的一处残破镇子里，两人在熊熊的火堆呆坐，巴拉森始终抱住玛莉亚的身体不愿意放开，便是食用东西，也是以单手取用。</p>
<p>这时候刘意看见他手上的那柄流星锤已经在先前激烈的战斗中歪扭损坏了，忽然想起了自己杀死斯温后，还得到了一把双手重剑，这东西自己无法使用，又不可以携带出这个世界，只能换取不多的积分，她此时闲下来以后，正好使用那真实之切割术来为这把剑开光。</p>
<p>于是刘意闭上眼，用手中的短剑有意无意的在旁边的木头上轻斩，回忆在现实世界里剁排骨的那种奇妙感觉，好一会儿猛然睁眼，手上浮出一团蓝色的光芒，用力砍在了那把由剑士首领斯温爆出来的双手重剑上！</p>
<p>重剑的表面立即软化，若镜面般荡漾了起来，整把武器都朦胧在了蓝色光芒中，好一会儿才稳定下来，变成了一根歪歪扭扭的粗大棍子，表面乌黑中透露出隐约红光。</p>
<p>然而刘意却痛苦的呻吟了一声，她只觉得斩出这下以后，仿佛整个人的精力都被抽空了似的，太阳穴也在剧烈的跳疼着，好一会儿长吁出一口气，却发觉自己的个人数值的：精神一项，已经被降低到了只有3点的地步！正鲜红色的发着光仿佛在报警似的！</p>
<p>这种情况令头痛欲裂的刘意也紧张起来，连忙向母体烙印查询，得到的回答乃是：真实之切割术异变效果出现，使用精神力过度，建议立即休息，以免造成永久性损害效果！精神值目前的恢复速度，为每二十分钟恢复一点。进入深度睡眠四小时后彻底恢复。</p>
<p>听到这样的回答，刘意已经略微放心，谁知道旁边骤然传来“轰”的一声巨响，她转头一看，立即双眼圆睁，只见巴拉森不知道什么时候已经站了起身，将那根刚刚出炉的大棍拿到了手上，随意挥动之下，已是将旁边一座本来就歪斜的房屋砸得塌陷了下来！</p>
<p>“喂……”刘意很无奈的将质问咽回了喉咙里。直到巴拉森舞够了手上的新武器，开始微微喘息，她弱弱的道：“还顺手吗？”</p>
<p>巴拉森血红的双眼望了她一会儿，断折一角的头盔上下动了动，算是回答。然后重新坐回地上，抱起了玛莉亚的尸体。</p>
<p>刘意这时候才能接触到那根铁棍，手指却只能将之触碰到，却无法拿起，眼前自动浮出信息：</p>
<p>“异变之裂魂大棒：双手武器，品质完美，神话，攻击1～20，有15%几率对敌人造成额外100点伤害并且出现失明效果，需要力量45，体力40。已被巴拉森灵魂绑定。”</p>
<p>一看到需要力量45，体力40的苛刻条件，刘意就知道这东西与自己没有任何缘分了。而巴拉森这怪物竟然能用单手使用双手武器，其肉体的强横可见一斑。他装备上了这件无意中得来的武器，那么明日的袭杀任务刘意又多了几分把握。</p>
<p>算计或许只能接近事实，却不能完全预测未来，时间中总是充满了太多的变数。刘意仔细思索着自己的计划还有多少漏洞，直到反复推敲以后，才抬起头来对巴拉森道：</p>
<p>“嘿……我知道你现在很痛苦。”</p>
<p>巴拉森似一大团钢铁的废墟，一动不动。</p>
<p>少女从身后拿出了一个大皮口袋，拔开了塞子，顿时浓郁的烈酒气息从里面散发了出来。她仰起头将袋口悬在嘴上饮了一口，舒心的喘了口气。猛然间伸过来一只大手将袋子劈手夺了过去，咕嘟咕嘟的猛饮了起来。</p>
<p>看着以酒解愁的巴拉森，少女的唇角微微上扬，计划的第一步，已经开始实施了。若是这袋酒灌不醉巴拉森的话，那么，自己身后却还有满满一木桶……</p>
<p>被痛苦所折磨的神经，自然需要酒精的麻痹。</p>
<p>这却也是在刘意的谋划当中。</p>
<p>……</p>
<p>大醉后的巴拉森，由于身心俱伤疲的缘故，整整睡了十五个小时！</p>
<p>他是被香味所诱惑醒来的。</p>
<p>熊熊篝火上，烤了一头猪，正是熟透了的时候，一点点的油脂从肥肉里冒了出来，滴在火苗上发出“吱吱”的响声。</p>
<p>巴拉森的喉结上下抽搐了一下，只觉得口渴难忍，抱起身边酒桶的残酒就灌了一气，接着直接扯下一条猪后腿大啃了起来。此时夜幕又降临了，整整吃掉半头猪以后，巴拉森忽然疑惑望向西方，那处的天空已被染成了一片炽红。</p>
<p>那是血的色泽。</p>
<p>西方……正是自己镇子的方向！</p>
<p>巴拉森似被火灼了一般弹了起来，伸手就去抄盾和棍。却听旁边一个平淡的声音道：</p>
<p>“现在去，已经晚了。”</p>
<p>说话的正是刘意，她的神情被火光一映，竟给人一种奇诡的感觉。</p>
<p>“我故意让你醉到这时候方醒，就是不想你一时冲动误了大事。”</p>
<p>巴拉森粗壮的身躯因为愤怒而不住颤抖，拿手上的那根裂魂大棒指着她，却没能砸下去。</p>
<p>“什么，什么大事！！”</p>
<p>“惩戒骑士斯科恩身边至少有数十名重盾巨锤士保护，若算上重剑士和面具奴仆，根本不用他动手，其力量足已将你我碾得粉碎！还谈什么为玛莉亚复仇？”</p>
<p>“这和咱们现在干等着有什么关系？”巴拉森咆哮道。</p>
<p>刘意冷冷望了他一眼道：</p>
<p>“若不让镇子上的人消耗惩戒骑士斯科恩身边的实力，并且将其分散，我们又怎会有直接面对他的机会？”</p>
<p>巴拉森似一头愤怒的公牛，呼哧呼哧的喘着粗气，死死的瞪着刘意，却终究没有动手。刘意盯着他的眼睛淡淡的接着道：</p>
<p>“咱们都是为了给玛莉亚复仇，把命都豁出去了的。你若现在要想杀了我，那么随你动手就是。”</p>
<p>巴拉森忽然抱起了身边的酒桶，又开始狂饮起来！事实上，这狂暴猛烈的钢铁野兽，面对刘意这冷静“少年”，竟是处处受制，此人将他的心理要害拿捏得极其准确！就好似一只奇毒蜘蛛，早就编织了罗网，将一根根的丝缚在了他的身上！令得空有一身蛮力的巴拉森竟是无法动弹，只能凭借这“少年”的意志行事！</p>
<p>直到又过了些时候，闭目养神的刘意才忽然睁眼道：</p>
<p>“是时候了，咱们走吧。”</p>
]]></description><pubDate>Sun Nov 01 2015 14:55:12 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/matrix-chapter-7</link><guid isPermaLink="true">https://blog.wxsm.space/p/matrix-chapter-7</guid></item><item><title>第六章</title><description><![CDATA[<p>两人匆匆穿过混乱的小镇，结伴一道出门，却见特地回了一趟家后的巴拉森并没有穿戴上甲胄拿上武器，手上却持着一柄铁锹，直到围观和随出的村民各自散去后，这个粗壮的男人才望着刘意诚恳的道：</p>
<p>“罗伦，你能不能替我保守一个秘密？”</p>
<p>刘意听得秘密二字，心中大动，表面上却沉吟道：</p>
<p>“那要看是什么了，若是有可能危害镇子的事情，我则不能保证。”</p>
<p>“不是。”巴拉森急道。“我对这个镇子的爱，甚至要大过对玛莉亚的爱！只是希望你不要把等会看到的事情说出去就是了。”</p>
<p>刘意这时候才勉为其难的点了点头。巴拉森便和他行到村外的树林中，开始在一株大树下挖掘，不久就挖掘出一套通体漆黑的连身盔甲，身材粗壮的巴拉森穿戴上以后，再戴上头上生有双角的牛角黑色罩面盔，左手持着小圆盾，武器则是一柄铸有密密麻麻倒刺的流星锤！浑身上下都被厚重的铁甲所保护，看上去就犹如一个重心且稳且低的钢铁堡垒！</p>
<p>巴拉森见刘意的目光不住打量自己，叹息道：</p>
<p>“其实我以前就是邪恶大公加利波迪的军队中的一员，但有一次重伤后马儿受惊脱离了战场，带着我奔驰来到了这里，是玛莉亚救了我并且帮助我隐藏了身份，从此我便改变了信仰，只希望平静的在这里生活下去。”</p>
<p>他忽然抬起头来，坚定的道：</p>
<p>“我不希望有人来破坏它！哪怕是加利波迪的军队也一样！”</p>
<p>刘意点了点头，故意叹了口气拍了拍他的肩膀。唇角却已在背转身的时候微微上扬，在她的推测之中，巴拉森的实力顶多重剑士等同，但眼下看来，他的实力只怕比自己预先假设的要强悍得多！</p>
<p>……</p>
<p>两人顺着大路向玛莉亚被劫的地方急急的赶了过去，很快就遇到了一位逃出来的难民告诉他们，邪恶大公加利波迪的军队已经分成了三路，开始在周边洗劫一些没有抵抗力量的镇子村庄，其实根本不用他的指点，在远处地平线上升起的浓黑烟雾便已经为刘意和巴拉森指明了方向。</p>
<p>越是接近被洗劫的地方，出现的景象就越是有些不忍目睹，有的小孩子被活活摔死，有的女人赤裸身体，乳房却被割去，看着这一切，刘意露出震惊的神色，而巴拉森的脸被罩在了厚重的沉铁盔里，根本看不到他的表情，只能从那粗浊的呼吸里体会到他内心的愤怒！</p>
<p>前方开始出现了面具奴仆，他们染满鲜血的淡紫色袖子看起来格外显眼，这些人正在追逐杀戮着逃窜的平民，大概是因为巴拉森的打扮令他们实在熟悉的缘故，有几名面具奴仆毫不设防的走了过来，他们还拉着一个年轻哭叫着的姑娘的头发，想来是为了表示自己的敬意前来献出供品。</p>
<p>回应他们的是一根粗大而生满了倒刺的钢铁榔头。</p>
<p>随在巴拉森身后的刘意暗自乍舌，眼看着这粗重巨汉疯狂在在面具奴仆中扫荡冲杀的架势，当真是势若疯虎，她甚至亲眼看到一名惊恐无比的面具奴仆被巴拉森手上的小厚铁盾正面撞中，整整惨叫着飞出了三米多高，生生将撞破了旁边的屋子的板壁，自此再无声息。</p>
<p>直到巴拉森喘着粗气停止了自己的冲撞，刘意终于讶然发觉，方圆数百米内，已经没有了半个活人侵略者和被侵略者的血，都在地面上流淌，溶汇到了一起，而那柄生满倒刺的流星锤已被染成了鲜赤之色，上面甚至可以见到毛发与血肉的混合。眼见这等血肉屠场般的景象，刘意心中虽然有细微惊骇，但却见到一些面具奴仆的尸体上开始泛出微弱的光芒，她的心中一喜，忙抢过去翻尸寻找珍藏，最后总计收集了十数个木头箱子。只是一一翻开后都没有寻找到什么好东西，无非就是些很次等的回复品和低劣的装备。</p>
<p>刘意此时还不打算将自己的第一个任务完成，但有的无法携带走的东西，任之消失又觉得有些可惜，忽然想起昨日新学的那个鸡肋技能：切割术，便索性拿出身边的短剑练习了起来。</p>
<p>这不练不知道，一练之下刘意才知道这技能的鸡肋性，整整十数件物品，竟然没有一样成功，反而将两件东西切割得彻底消失了！并且一件道具被切割过后，无论结果如何，就不能再次被切割。</p>
<p>眼见得面前还只剩下了一只恢复30点体力值的黑麦面包(标准)，刘意拿着手上的短剑，决心要将这最后一次机会利用完备。她用短剑比了比，心里忽然涌现出一种十分奇特的感觉，就仿佛是在现实世界里拿着厚背斩刀，对着一大块的排骨一般。</p>
<p>心中还在回神，但是手已是毫不犹豫的斩了下去！</p>
<p>刹那间，那种奇特的感觉又浮现在心头，每当它出现的时候，刘意在现实世界里，就能战胜自己基因的缺陷，成功完成对自我的超越！只是她此时却是在另外一个神秘世界里，正在运用着这个世界特有的技巧！</p>
<p>箱子里安静躺着的黑麦面包，忽然在刹那间被均匀的切割成了三块！</p>
<p>刘意此时还沉浸在那种奇妙的体会中，好一会儿才回过神来，试着用手去箱子里拿起。冷不防旁边伸了一只大手过来，一巴掌就抓了进去，不是巴拉森是谁？</p>
<p>这粗鲁男子拉开面罩，就将掌中的面包块向嘴里塞了进去，咀嚼了几下瓮声瓮气的道：</p>
<p>“味道不错，你这切割术挺厉害。”</p>
<p>刘意有些目瞪口呆，好在箱底还剩余了一块面包，她拿了起来，信息立即浮现：</p>
<p>“黑麦点心(纯正)，类别：食物，可携带，效果：在80秒内回复体力值十五。”</p>
<p>“这……”她一下子就被震撼了，本来总共才回体力值30点的黑麦面包，被切割术加工后，分为了三块，每块都能回复十五点体力值，那么总计恢复力就上升到了四十五点，提升1.5倍！并且还有可以携带的属性，也就是说，在战斗时候若处于劣势，吃下一块后，也能起到缓缓恢复的效果！</p>
<p>而她此时再看自己的切割术技能，却也发觉换了个名字：</p>
<p>“真实之切割术：乃是将自身精神力与切割术契合而成的变异技能。本技能为圆桌武士世界特有，使用真实之切割术，将会消耗1点精神力。真实之切割术LV1效果：可以对所获取的战利品进行加工分割，有3%的机会加工出高级未知宝物，有60%的机会增加战利品的价值，有6%的可能使战利品出现异变。有21%的可能会令被加工物品完全消失。注：在加工装备时，完全消失的几率将翻倍。切割范围仅限于白色，灰色，蓝色装备，食物，与部分贵重物品。本变异技能只能通过熟练度的累积进阶，无法使用潜能点提升。”</p>
<p>(注：真实切割术的60%机会增加战利品的价值则是指，能够将标准品质提升成纯正，以此类推，若装备本身品质为完美的话，则能进行升阶。)</p>
<p>先前刘意一刀砍下，真实之切割术成功发动，将那黑麦面包(标准)，加工成为了黑麦点心(纯正)，不仅品质提升，其性质也由不可携带变成了可以携带。这便是切割术的异变能力发动！</p>
<p>这时候巴拉森粗鲁的挤了过来，拿她的一只大手拉住刘意，很不耐烦的道：</p>
<p>“喂，走了。”</p>
<p>刘意还在回味先前斩出那一刀的奇妙感觉，甩手皱眉道：</p>
<p>“等等。”</p>
<p>她忽然觉得脸上一痛，然后天旋地转，嘴里有一股腥咸的味道从舌底涌了出来，这时候面颊上才火辣辣的疼，当刘意恢复神智时，那根可怕的还沾染了血肉的巨大榔头已经无情的指着她，巴拉森仿佛一座笨重的杀人机器般立在她的面前，双眼血红的道：</p>
<p>“走。”</p>
<p>刘意从她的眼底读出了认真强烈的杀意。巴拉森压抑在心中多年的杀意杀性终于爆发了出来，这使得他的精神已经达到了一个偏执狂乱的地步！刘意默不作声的爬了起来，并没有因为挨了这重重的一下而沮丧，反而在纷乱的思绪中似乎捕捉到了什么东西，只欠缺关键的一条线索将之联系起来。</p>
<p>两人去的下一个目的地，便是邻近的那个同样被袭击的村庄，此时来时所乘的马儿已经不敢接近浑身浴血，状若野兽的巴拉森，连距离她丈余之远，也在作着不安的扬蹄低嘶。</p>
<p>与前一个镇子一样，这里依然充满了杀戮，血腥，掠夺和死亡，巴拉森喉头遽然发出一声野兽般的咕哝，刘意顺着他的目光看去，发现了在镇子里最为高大的建筑，教堂之前，停放了一辆颇新的马车，正是玛莉亚的坐车，有数十个人头晃晃悠悠的悬挂在车的顶蓬上，他们神情扭曲痛苦，显然生前受过了极大的折磨，连死后也不得安息。</p>
<p>刘意从人头中勉强分辨出了几张眼熟的面孔，毕竟就在昨天晚上的酒吧中，这几名遇难者还同她在一处喝酒，唯一值得安慰的是，这数十名遇难者中没有女性。</p>
<p>当然也可以理解为，玛莉亚现在所面对着的事情，很可能比死还可怕。</p>
<p>而此时巴拉森已经疯狂的冲了上去，两名看守马车的面具奴仆几乎在一瞬间就被砸得变了形，而教堂半掩的大门也立即内飞进去，但是紧接着内中传来了金属交击的一记巨大响声，疯牛般突入的巴拉森踉跄倒退出来，左前臂的黑色小厚铁盾上，已经多了明显的裂纹与凹痕。</p>
<p>紧接着，一名同样粗壮戴着牛角盔的重盾巨锤士行了出来，他身上的盔甲，武器的款式，与巴拉森均是一模一样，区别在于颜色却是火红。这人抬眼望了望喘息着的巴拉森，声音嗡然的道：</p>
<p>“叛徒，今天就是你的死期！”</p>
<p>他举起手中火红色的单手大锤，“咚咚咚咚”的向着巴拉森冲扑了上去！这两人的体格都是粗壮矮实，并且加上各自身上的全身重甲，刘意估计其总重量超过了半吨以上，这两人抱在一起扭打着扑入了道路对面的一处民居里，那可怜的房屋立即坍塌下来，激起了漫天的尘雾！</p>
<p>刘意在旁边冷静的思考着，她自然不会放过这个大好机会，三步并作两步就冲进了教堂里，直接与一名惊恐无比的面具奴仆对砍了一剑然后就看到了昏迷不醒的玛莉亚正被平放在神台上。</p>
<p>这时候，听得外面两名野蛮粗重的武士互殴，将彼此的盔甲击打得“铛铛”作响的声音。刘意反而犹豫了起来，她猛然眼前一亮，启动了母体烙印重新审核了那个接到的隐藏任务，将任务目标：帮助巴拉森见到玛莉亚这句话仔细阅读了几遍，唇角忽然露出一抹阴冷的微笑。</p>
<p>当刘意走近玛莉亚一步的时候，她便悠悠的醒了过来，一见到熟悉的人，立即本能的扑上来抱着她哭泣道：</p>
<p>“罗伦！你是来救我的吗？杰克他们都死了！”</p>
<p>刘意缓慢的道：</p>
<p>“是的，我是和巴拉森一同来救你的。”</p>
<p>玛莉亚脸上骤然露出惊怕之色：</p>
<p>“巴拉森！难道他再次穿上了那一身被加持了恶魔之力的邪恶盔甲？”</p>
<p>刘意微笑着点了点头，意味深长的道：</p>
<p>“为了你这个可爱的天使，他宁愿堕落成为魔鬼。你们的爱情，将在这教堂中见证永恒。”</p>
<p>玛莉亚还未来得及细想，忽然觉得肚子上一凉，刘意在这一瞬间，竟然将手中的短剑自下而上，从玛莉亚的小腹刺入，一直向上死死探入，最后几乎深插到了她的咽喉部位！</p>
<p>没有人能在受了这样的伤以后活着。</p>
<p>所以她很干脆，死了。圆睁的双眼里充满了痛苦，不甘，疑惑。刘意接着又迅速而从容的将玛莉亚的裙子撕破，伪装成一种曾经经历过激烈挣扎的模样，刻意的将她的大腿露了出来，雪白的大腿和暗红色的血液形成了鲜明的对照，然后歪着脑袋审视自己身上，用手上的短剑比划几下后猛地下手给自己增添了些伤势，抱起她走向了教堂外。</p>
<p>在经过先前那具面具奴仆的尸体的时候，一脸玩味的少女还顺道一脚踏在了尸体的咽喉上，将喉骨连同颈骨都踩得粉碎，她如此小心，便是要杜绝此事情泄露出去的一切可能。</p>
<p>四下里已成了一片废墟，在这两头钢铁怪物的角斗下，这时代的建筑很少有能经得起他们来回碰撞的。</p>
<p>巴拉森此时显然已落了下风，他头盔的一个角甚至已被打得断了，身上的黑甲不少地方也出现了裂纹，大量的鲜血从他的口角流淌出来，沾染在他浓密的胡须上。飞溅在他的黑色厚甲上点点都是！</p>
<p>刘意便在此时横抱着玛莉亚神情悲痛无比的跑了出来，痛苦的道：</p>
<p>“巴拉森！我去晚了！他们想要侮辱玛莉亚，她不肯顺从，那名面具奴仆又见我冲了进来，慌乱之下！就……就杀了她！”</p>
]]></description><pubDate>Sun Nov 01 2015 01:03:13 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/matrix-chapter-6</link><guid isPermaLink="true">https://blog.wxsm.space/p/matrix-chapter-6</guid></item><item><title>第五章</title><description><![CDATA[<p>又行了几里以后，前方又出现了一处哨卡，刘意在旁边悄悄潜伏了一会儿，大感欣慰：此处竟然只有四个面具奴仆和一名重剑士，那重剑士的身上，也没有穿着红色的披风，连身上的沉重盔甲也卸在了一旁。</p>
<p>她顿时醒悟过来，自己先前袭击的那个强大并且能够变异的重剑士，显然就是这附近邪恶大公加利波迪的军队的重剑士首领了，只有这样才能解释她有八个面具奴仆的侍侯，并且其气度，韧性都与眼前这个截然不同。</p>
<p>刘意想了一想，在旁边的污泥里打了个滚后，故意放重脚步，喘息着向那个正在放哨的面具奴仆奔跑而去。那家伙自然而然的一惊，立即叫了出声：</p>
<p>“干什么的？”</p>
<p>刘意狼狈无比，连滚带爬的向前奔了数步，脚下一软，就骨碌碌的向坡下的凹地滚了下去，故意面朝地下，故作昏迷不醒。</p>
<p>此时本是夜间，又有面具遮脸，在这样紧张的气氛下，谁能识得出她的真假？她只觉有人翻动了几下自己的身躯，就听那重剑士手忙脚乱的穿戴着沉重的链甲，气急败坏的催促道：</p>
<p>“你们三人赶快过去那边营地，留下一下服侍我着甲，我立即就来。”</p>
<p>三名面具奴仆急匆匆的拔出短剑赶了过去，刘意估计三人走远以后，忽然挣动了一下，呻吟着用含糊不清的语音道：</p>
<p>“大人，大人……”</p>
<p>这个动作自然吸引了剩下的重甲剑士和面具奴仆的目光，他们自然而然的就围了过来，刘意故意费力的作出濒死的动作，浑身上下都在不停的颤抖，艰难无比的伸屈着手指道：</p>
<p>“剑……剑……”</p>
<p>旁边那面具奴仆实在等不下去，主动的将他的剑递到了手上，刘意将剑紧紧握住，平端在了胸前，这才仿佛获得了安全感一般的对着那重剑士低声道：</p>
<p>“大人死前说……就由你继承他的位置。”</p>
<p>她的话说得极模糊，偏生又能让人听个大概，那重剑士心中一惊，接着又是狂喜，忍不住就凑上前来道：</p>
<p>“WHAT？”</p>
<p>刘意便在这瞬间轻松挥剑割断了他的喉咙！</p>
<p>接下来，她所要面对的，就只有一个惊恐无比的小兵。在这个世界两倍属性的加成下，解决他只花了不到半分钟的时间。</p>
<p>然后她又倒卧在地装死，此事于她而言，不仅是故技重施，并且更算得上是惯技重施。如法炮制之下，在付出了半条血槽以后，那三名面具奴仆又为刘意所杀，经过了最初的生涩与陌生以后，刘意发觉自己渐渐适应了这种生活，在杀人或者被杀中抉择，在死亡的阴影下生存，这不仅令她觉得刺激快慰，更能摆脱现实世界带给她的痛苦烦恼。</p>
<p>这个营地清理完毕以后，那任务一：杀死七名面具奴仆，两名重剑士，获得积分300以上。已经接近完成，只有积分还相差30而已。</p>
<p>刘意把玩着手上的短剑，思考了一会儿，而她面前的木箱中，还有着专门用来换取70积分的三件装饰银饰。她踌躇良久，将之收了起来并没有卖掉，而是转身向镇子外的住处行了回去。直觉告诉她，还不到疯狂攒分完成这第一个任务的时候，至少，现在还不是。</p>
<p>……</p>
<p>刘意直接回到了自己村外的那所破旧小木屋的住处，倒下头来沉沉睡去，她丝毫不担心可能遭受袭击，自己独身一人，又是首次加入这个世界，熟悉这个生存的模式，面对的敌人却是两大方面，若再安排组织个什么夜晚偷袭，那有关于此副本的说明简介，就根本不可能是容易二字！</p>
<p>经过了一番充足的睡眠后，醒来的刘意发觉自己不仅精力充沛，伤势尽数恢复，并且连数字化显示的个人能力也有了长足的进步，现在分别是力量4(3)，敏捷5(4)，体力6(4)，精神力13(13)。括号内为初入世界时候的数值，其中力量和敏捷各提升了一点，体力增加了2点，而精神力则原地踏步，想来是根本没有运用的缘故。</p>
<p>而刘意并未因此而对前景过分乐观，之所以个人的属性能够增长这么迅速，那是因为自己本来身体中具有潜力未曾开发。经过了昨天晚上的战斗后，将其充分发挥了出来。以后要想增长，就只能依靠自身的努力修炼才是。</p>
<p>她踏出门去，深吸一口早晨田园中略寒而极清新的空气，看惯了现实世界里的钢筋混凝土森林，这等中世界苍翠幽静的田园实在有些让人心醉神迷。</p>
<p>山间田野里，满目都是丛林、鲜花、碧草、绿野。山野里或绿油油的麦田，或绿油油的草地。即使是山坡，也是大片的草坪延伸而上，各种树木成为点缀耸立其间。田间小道两旁长满了青碧叶，开着小小的白色、紫色花朵，给人以和谐的自然美之感。零零散散的村落半掩在绿野里，虽然破旧，却有一种原始之美，连流淌着的溪水，给人的感觉也是特别的清澈。</p>
<p>刘意并不急着出门，在自己的破旧小屋前安静的坐了会儿，回忆总结着昨夜一战的各种细节得失，同时活动着身体。人不能在同一个坑里跌倒两次，更何况在这个看似宁静优美的世界里，蕴藏着的却是不可以重头再来的残酷直到她浑身上下都泛出了热汗，有了微微的气喘，便通过肩头的母体烙印，将昨天夜里获得的积分兑换了些这个世界通用的银币后，向着村中行去。</p>
<p>此时大概已是上午的十点多了，感觉到有些饥饿的刘意直接来到了镇子里唯一的一处小旅店中，睡眼惺忪的旅人们正打着呵欠从吱嘎作声的破旧的楼梯上行下来。</p>
<p>刘意的肚子实在也饿了，那种单纯为补充生命值的食物与填饱肚子的是截然不同的两类东西。她直截了当的点了小半条塞了蒜茸的羊腿肉和烤得发黄的小麦面包，就开始用肉就着面包细细吃起来，等到将肚子渐渐填饱，就叫了半只淡味整鸡和一杯啤酒，开始慢慢的撕着吃着，消磨着时间，她所选的位置十分巧妙，恰好是能够看出去但又很不引人注目。</p>
<p>似乎这样的生活很适合她目前的身份，看看到了中午，瘸了一条腿的旅店老板确定罗伦(刘意)的钱袋很是饱满以后，十分殷勤的又主动送上了两条敦实的阿尔灌肠，这东西是用来垫着面包切割的，一餐刀切下去，可以见到它的横剖面是粉红的细肉泥，中间还夹杂了肥肉丁和整粒的胡椒。</p>
<p>刘意很满意的享受完了这顿丰盛的午饭，然后正打算加入饭厅中那群人激烈的争论预备再从中获取些有用的消息的时候，小镇中心残破的石板路上忽然响起了急促的马蹄声，一个浑身是血的小伙子死死的箍着马脖子急驰了进来，惊慌失措的高叫道：</p>
<p>“不好了！镇外都是是邪恶大公加利波迪的军队，我们今天出发去城里不久，商队就遭受到了他们的袭击，玛莉亚也被劫掠了去！”</p>
<p>刘意的眼前一亮，玛莉亚岂不就是那个脸上有着几点雀斑的酒吧女郎？就是她，能让粗壮得好似石磨的巴拉森乖乖住口！看来自己昨天夜里没有选择直接完成第一项任务确实明智。</p>
<p>事实上，以前有着和她一样经历的人，进入世界后所应对的方法通常都是直接前去侦察那几个加利波迪军的营地，每个营地都会每隔一个小时，就会派遣一名面具奴仆前来打水，只需要将这个落单的面具奴仆杀死，便可以顺利过关。</p>
<p>接下来发生的事情是，玛莉亚为了验证罗伦(穿越者扮演的统一身份)，一早就来邀请他同行，去城中核实邪恶大公加利波迪军来袭的情报是否属实。与此同时，因为昨天夜里有一名面具奴仆失踪，潜藏在镇子外面的加利波迪军队就开始进行小规模的搜索他们夜里损失的人手越多，那么派出搜索的力量就越强。</p>
<p>通常情况下，只杀死一个面具奴仆，玛莉亚所组织的商队可以很轻松的将遭遇的巡逻队伍歼灭，而派给进入者的第一个任务则可以十分轻松的完成。</p>
<p>然而……刘意整整杀死了十二个面具奴仆，还将潜伏着的加利波迪军队的指挥官也干掉了！这不能不说与她在现实世界中，就已经有过连环杀人的经历有着莫大的关系。只是这样一来，邪恶大公加利波迪军队自然就是倾巢而出，强度甚至大到了可以让玛莉亚所组织的商队全军覆没！</p>
<p>这时候，刘意终于在乱作一团的镇子里，看到了粗壮的巴拉森，这个看起来顽固若一块坚硬岩石的男人，眼里燃烧着的是熊熊的怒火，他大声的呼喝咒骂着，想要将人手组织起来进行援救的工作，但是恐慌似瘟疫一般的蔓延，这个男人的努力只能以失败告终。此时刘意才大步走上前去，淡淡的道：</p>
<p>“我陪你去救玛莉亚！”</p>
<p>巴拉森犹豫了一下道：</p>
<p>“你一个人不行的。”</p>
<p>刘意望着她的眼睛，一字一句的道：</p>
<p>“那我们一起去就可以了！”</p>
<p>巴拉森的脸上陡然掠过一丝复杂，痛楚，矛盾的神情，刘意却好似没有看见一般，轻蔑的道：</p>
<p>“爱一个人，不是用口头说的。”</p>
<p>巴拉森被这句话刺得一下子捏住了刘意的领口，呼哧呼哧的喘息得似一头红了眼的公牛，然而刘意毫不畏惧的与之对视着，巴拉森深深吸了一口气，仰天叹息道：</p>
<p>“你说得对。”</p>
<p>这时候刘意肩头一热，母体烙印主动给出了相应的提示：</p>
<p>“启动隐藏任务：巴拉森的救援，任务难度中(C等级)。任务目标：帮助巴拉森见到玛莉亚，时间限制，8小时。”</p>
]]></description><pubDate>Sun Nov 01 2015 00:25:29 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/matrix-chapter-5</link><guid isPermaLink="true">https://blog.wxsm.space/p/matrix-chapter-5</guid></item><item><title>第四章</title><description><![CDATA[<p>夜晚很安静，凹地里只有篝火在有气无力的烧着，许多人都懒洋洋的靠在旁边的草铺上进入了梦乡。好一会儿才忽然有人道：</p>
<p>“提水的人怎么还没有回来？”</p>
<p>这句话立即得到众人的响应，他们都等着烧些热水喝了，烫一烫脚再美美的睡上一觉。这时候打水那面具奴仆终于一歪一斜的回来了，身上的衣物显得脏污潮湿，连脸上的面具也歪了些，显然是半路上跌了一跤。</p>
<p>这是一支显得有些超出了标准编制的队伍，领头的是一名身穿铁甲，身材高大的重剑士，他留着淡黄色的胡须，身着锁甲，外面罩着红色披风，令人望而生畏。</p>
<p>此时这位首领已经靠在最干燥石头边，抱着半人高的巨剑发出了鼾声，他身边有八名面具奴仆，平日里则为其保养兵器盔甲，侍侯生活起居，战场上则要跟随在旁边拼杀。</p>
<p>其余的七名面具奴仆已经等得有些不耐烦了，直接抢过那一瘸一拐的同伴手中的水桶，直接放到火上烧热洗漱，便纷纷倒头睡去，只有一个年长的模糊的交代了一声：</p>
<p>“你先守夜吧，顺便也好烘烘衣服！”</p>
<p>打水那面具奴仆身体扭动了一下，喉咙里咕哝了两声，似乎是在抗议。</p>
<p>这个夜晚静悄悄。</p>
<p>有的只是此起彼落的鼾声，呆坐在火堆旁边的那名面具奴仆忽然轻轻的站起身来！看她锐利阴翳的眼神，赫然正是刘意！</p>
<p>她行到了距离自己最近的人身前，她眼盯着这面具奴仆的咽喉。然后很果决的拔剑，一割！完全没有丝毫的犹豫，手软！</p>
<p>虽然剑刃并不锋利，但要割开脖子上薄弱的皮肤也是轻易而举的，接着剑刃余势未衰，又划断了其下的气管，喉管，颈动脉，迷走神经（注：支配呼吸系统、消化系统、心脏感觉的神经）。暗红色的鲜血顿时欢快的奔流了出来，刘意清晰的看到，视野里这面具奴仆的血条骤然变空，他的身躯陡然弹起，再重重跌落，死鱼的眼睛外凸，紧接着变得茫然。刘意眼疾手快，一把抄住了他脱手抛出的短剑，避免它撞到岩石上发出响声，接着凶狠的一脚踏在了尚在流血的伤口上，避免气管内呛入血液的“咯咯”轻声惊动了其他人。</p>
<p>这时候刘意注意到，视野里的左下方，出现了一行小小的数字：</p>
<p>重剑士0(2)，面具奴仆2(6)。(注：先前打水的那个也算)积分0(300)。</p>
<p>余下来的六名面具奴仆也在睡梦中被杀。</p>
<p>接着刘意行到了最干燥巨石边的那名重剑士的身前，依然打算如法炮制，她攻击的部位还是对方的咽喉这也是这敌人身上唯一没有被链甲包裹的要害。</p>
<p>然而在剑挥下的那一瞬间，这重剑士大概是由于一个姿势躺得太久的关系，遽然翻身！</p>
<p>人体致命之处刘意早在决心为奶奶复仇的时候，就已经在现实世界里研究过，遗憾的是，她杀那几个人大多都没有采取暴力的方式，因此并没有得到多少实践的机会，所以才有今次的失手。</p>
<p>那名因为睡眠中无意翻身躲过了致命一击的重剑士，立即清醒了过来，低吼一声。弹了起来对刘意发动了猛烈的突袭，然而刘意只是侧身，用手臂架住了她的大剑突刺，表面上向他挥砍了一剑，但真正的阴招却是用力踹出的一脚！</p>
<p>那一脚，踢在了这重剑士的裆部上。</p>
<p>甚至刘意的脚背都感觉到两个卵圆形的东西在瞬间炸成一塌糊涂的那种激烈痛楚，然后她注意到，自己的血条减少了五分之一，而这重剑士的血条顿时沉到了最底处，但只是最低之处，却并不算死亡！这重剑士脸上的头盔骤然破烂了开了，露出了扭曲狰狞的面孔，而双眼也变得血红，一下子就和身扑上，将刘意按倒在地，哪怕是她被这环境加倍了的力量属性，一时间竟也抵挡不住敌人的疯狂进袭！</p>
<p>变异！（注：NPC角色在遭受实力低于其正常能力的角色所造成的剧烈伤害而进入濒死阶段后，有一定几率产生的蜕变。）</p>
<p>闻着压在身上的重剑士浓重的汗臭气息，耳中听到的是他宛若野兽一般的疯狂喘声。刘意尽管脖子被卡住头晕目眩艰于呼吸，但是依然保持着冷静。</p>
<p>她完全放弃了挣扎的意图，却是猛然翻身！</p>
<p>两人一齐滚入了火堆中！</p>
<p>熊熊烈火，焚烧着这正在殊死搏斗的两人。火焰是公平的，一视同仁的炙烤着一切胆敢进入它势力范围的东西。刘意眼前属于自己的血条开始急剧下降，然而最先支持不住的，却还是压在她身上的这名变异重剑士。在火焰里呆了数十秒以后，他终于在喉咙中发出悠长无奈的一声嘶吟，颓然倒下。</p>
<p>死里逃生。</p>
<p>这是刘意心中的唯一想法。</p>
<p>其实这其中有许多运气的成分在里面，如果这重剑士不是因为睡觉而未穿上护裆甲，如果不是刘意身为女子在现实世界里自知力弱而涉及过一击杀人的知识，如果旁边恰好没有一个熊熊燃烧的火堆，如果……</p>
<p>这场短促而惊险的战斗，却令刘意明白了太多的东西。首先，这里的背景虽然是圆桌武士这种框架的世界，但是！里面的人，都是活生生的人！他们有智慧有思想有情感甚至有爆发力！若是轻视的后果，那便是死！</p>
<p>四下里静悄悄的，刘意喘息了一会儿，呸了口嘴里的泥沙，觉得心跳得几乎要弹出胸腔，而太阳穴也一阵一阵的弹跳着发痛，她皱着眉毛爬了起来，仔细检视了身体，发觉最重的伤还是拿手臂硬架的那一下重剑突刺！中剑之处的皮肉都凄厉无比的翻卷了，连血管也在瞬间为剑上附带的高温所灼焦，因此倒没有流多少血出来。</p>
<p>而此时身上的烧伤也开始隐隐作痛起来，刘意这时候才想到了场景提示中写着：痛觉削弱是70%，也就是说，目前伤势反馈给神经的痛感，被削弱了七层。依照她的忍耐力，除了左手的运动有些受到阻碍以外，其余的能力并未削弱多少。这时候刘意又发现了一件事，在旁边一具面具奴仆的尸体腰间，闪动着耀眼而并不刺目的光芒。</p>
<p>她好奇的行了过去，很容易的寻找到了一个灰扑扑的金属球。金属球到手以后，尸体变得透明，消失，母体烙印给出提示：你获得了普通珍藏一件，是否要立即召唤宝箱？是/否？</p>
<p>刘意见周围十分安全，便选取了召唤选项，原地出现了一个看起来颇为结实的木头箱子。开箱之后，刘意发觉里面放着一个黑色的小麦面包，她的手指触碰到以后，肩头的母体烙印立即作出了提示：</p>
<p>“获得黑面包一个，品质普通，不能携带，恢复体力值三十，是否立即服用？”</p>
<p>(注：本书中获取战利品的方式参考DOTA2，大部分都是上述方式，以后有特殊情况，会加以说明。宝箱和珍藏，不能被没有母体烙印的人所看到。物品保护时间为：72小时。)</p>
<p>刘意心中一喜，将面包吃下后发觉自己的血条攀升了一小段，赶忙留意其他的尸体，在另外四名面具奴仆的尸体上寻找到了其余的灰色珍藏，在那曾经狂暴的重剑士身上，则寻获了一把亮银色的珍藏，她冷静的想了一想先使用灰色珍藏来打开箱子，获得的物品分别如下是：</p>
<p>短剑一把，普通装备，品质标准，攻击13，不能携带出本世界，可以兑换30积分。</p>
<p>银饰一件，品质标准，贵重物，可以兑换60积分。</p>
<p>蔬菜沙拉一份，品质纯正，食物，在60秒内恢复20点体力值，必须在非战斗状态下食用，不能携带。</p>
<p>值得一提的是，出现了一个空箱子。刘意由此推想到，既然箱子可能出现空的，那么今后很可能要面对有着陷阱的陷阱，如此看来，应当有专业的甄别的技能才对。</p>
<p>这番忙完后，刘意的血条已经由本来的五分之一，缓慢恢复到了大半的位置，而身上的伤势也明显好转，只有左手在运动中还显得颇为窒涩。看来运动功能一旦受到创伤，愈合起来就有些缓慢，很难凭借这等食物来快速治疗了。</p>
<p>接下来要做的事情，自然是打开那亮银珍藏所对应的箱子了。随着珍藏的徐徐转动，箱盖里有一道银光射了出来，赫然是先前那重剑士肩头背着的大剑。其详细资料是：</p>
<p>“斯温的双手重剑：稀有装备，品质纯正，攻击56，附带灼热伤害22，不能携带出本世界，需要力量18，体力8，可以用来兑换300积分。”</p>
<p>刘意估算了一下，自己撑死也拿不起这大家伙，不过好在此时母体烙印提供了帮助，能将其收入了另外一个负重有限的储物空间中。她却又在银色箱子的底部发现了一张破旧的羊皮纸，手指刚刚触碰到，耳边便自动生出了母体烙印的提示：</p>
<p>“E级技能切割术卷轴，本技能为圆桌武士世界特有，需要力量3，敏捷3，体力4，精神10才能学习。技能发动需要消耗一点精神力。切割术LV1效果：可以对所获取的战利品进行加工分割，有1%的机会加工出高级未知宝物，有48%的机会增加战利品的价值，有51%的可能使战利品损坏消失，可以携带出本世界，也可兑换为50积分，请问是否学习。注：在加工高级装备时，失败率将成倍增加。(切割范围仅限于装备，食物，与部分贵重物品。)</p>
<p>(注：切割术的原形为是圆桌武士里的独创功能，将那些大宝箱，大药斩开。</p>
<p>①本书中的技能分为：SSS，SS，S，A，B，C，D，E六个档次，档次越低的技能，学习要求越简单。</p>
<p>②本书中的物品等级参照暗黑破坏神2与DOTA2，稀有度：普通-罕见-稀有-神话-不朽-传说，所代表的颜色白色-浅蓝-蓝色-亮金-暗金-紫色，另外还有套装型装备“至宝”绿色。具有唯一性的剧情装备，如孙大圣的如意金箍棒，吕奉先的真·方天画戟等装备具有唯一性故名为剧情装备。有时会用颜色来表述装备稀有度。 每个层次有不同品质，常用的低中高三等为：标准-纯正-完美。独特的物品会出现其他的独特品质。</p>
<p>我知道有人可能看不懂，但是没关系，不用懂，不影响阅读。另：图片仅供参考，商品以实物为准。)</p>
<p>刘意皱了皱眉，这技能实在鸡肋无比，不过她想了一想，抱着聊胜于无的态度，才点下了确定，谁知道母体烙印紧随着传来的一连串而来的提示，立即令她有一种想要破口大骂的冲动：</p>
<p>“你已经学习了一个技能：目前剩余技能栏为：2个。”</p>
<p>“此技能为E级技能，若要遗忘，须取得三途之水。”</p>
<p>刘意的眉头抽搐着，这提示给她透露了许多信息，首先便是应该可以学习到各种强化自身的技能，并且这些技能也按照效果，分出了等级显然E这个等级绝对谈不上什么高端。其次便是每个人学习技能的总量是有限度的，自己的总额是三个，现在则是两个了。最后则是技能应该可以遗忘，然而遗忘它的条件应该是很苛刻。如果刘意的推断没有错的话，评价越高的技能，遗忘的代价越低。</p>
<p>她深吸了一口气，摇了摇头，将心中的懊恼赶出了脑海中，于刘意的观念里，后悔是一件很无用的事情，它除了能消磨自身的斗志以外，便没有任何的作用。从这个点附近的布置来看，这里应该是一处监视镇子的哨卡，她换上了那把刚刚获得的短剑，重新寻了身面具奴仆的衣服换上，略一思考，便顺着河流向上行去。</p>
]]></description><pubDate>Sat Oct 31 2015 23:44:44 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/matrix-chapter-4</link><guid isPermaLink="true">https://blog.wxsm.space/p/matrix-chapter-4</guid></item><item><title>第三章</title><description><![CDATA[<p>当刘意睁开眼睛的时候，发觉自己处身于一间破旧，低矮的屋子里，四下里破烂的板墙向周围漏着风，而身上盖着的被子布料粗糙坚韧，还打了许多补丁，刘意的手指抚过其表面时候，脑海里所存储的信息立即判断出，这是一种非常劣质的亚麻布。</p>
<p>透过千创百孔的屋顶，可以依稀看到外面乃是黑夜，繁星点点，空气里有一种冷冽的清新。而随意丢弃在屋子里的几个破烂酒桶和箍桶板旁边，有一个带木框的马鞍，门背后靠着的，是一具轮犁。</p>
<p>刘意并没有急着起床，闭上眼后，缓缓的在脑海里将所有的事情串联起来梳理了一下，亚麻布轻微霉烂的味道从鼻腔反馈到了她的感觉中枢里。她忽然睁开了眼，解开了身上穿着的衬衫，低头向肩膀看去。</p>
<p>在右肩肩头上，一个诡秘邪恶的鬼脸刺青赫然多了出来，与那刘剑胸口的刺青相比，刘意注意到，自己胸口这个双眼的图案特别的明显。刺青上有着11615这个数字。刘意的心中一凛，这数字不是那刘剑的编号吗？换而言之，一旦编号人死亡，连他的代号也要被别人顶用？</p>
<p>这残酷的现实令刘意心中一寒，她的目光忽然落在了旁边粗笨低矮的木头桌子上，那里有一卷羊皮纸正在微微的发着亮。</p>
<p>“进入圆桌武士世界：第一幕战火之村</p>
<p>罗马帝国灭亡之后，混乱的黑暗时代降临，随着帝国的结束，整个欧洲呈现出另一番截然不同的文化风貌。大公加里波第用邪恶强大的力量统治着国家，他麾下的可怕势力中，有剑与魔法，斗气与机械，还有从东瀛舶来的神秘忍术。这时候，三位勇者在贤者（梅林）的引领下为了解放无辜的民众，对邪恶大公加里波第的势力发动了全面的进攻……”</p>
<p>“任务一，杀死七名面具奴仆，两名重剑士，累计积分300以上。”</p>
<p>“任务二，阻止编号第820小队杀死惩戒骑士斯科恩。”</p>
<p>“任务三，令编号第820小队中至少死去4名成员。”</p>
<p>“无法完成任务的后果：抹去。”</p>
<p>这是……“无限恐怖”?</p>
<p>她不由想起了自己曾在书上看过的这样一个世界。猛然睁大眼睛深吸了一口气，不仅没有恐惧，心中还有一种十分病态畸形的兴奋，在这样离奇的遭遇中，那苦苦折磨她数年之久的神经性疼痛终于不药而愈！</p>
<p>在她看完后，那羊皮纸便轰的化作一团火焰被焚烧而尽，但是其中的内容，刘意却可以感受到自己可以从肩上的那个刺青即母体烙印中随时调阅，并且心中的疑问，也可以随时寻求它的解答。</p>
<p>刘意仔细的想了一想，觉得目前最重要的，是要确认一件事，在心中默默道：</p>
<p>“显示编号第820小队进入圆桌武士的时间。”</p>
<p>在她的眼前，忽然出现了一个急速跳动的红色数字，72小时。距离进入圆桌武士世界，还有七分三十一秒。并且数字的下方还有一系列的菜单，刘意的意念所及之处，立即弹了出来：</p>
<p>“场景：圆桌武士1幕，难度：容易(D级)。痛觉削弱度70%，个人近战能力强化度100%。(820小队个人能力强化度为10%)。本场景为和平场景：杀死来自母体的人物不会掉落任何物品。数字化人物信息模式是否开启？”</p>
<p>刘意缓缓的思索了一会儿，将此时得来的信息归纳，总结了一下：首先自己还有三天的时间来熟悉这个全然陌生的世界，其次，那纸卷上给出的任务中的第一条，显然就是对这个目的的具体化。</p>
<p>接着她又启动了数字化人物信息的按键，立即有一栏东西跳了出来：</p>
<p>“编号11615号信息：力量3(5)，敏捷4(6)，体力4(6)，精神13(5)。括号内为三十岁健康成年男子的平均数值。精神低于2点后，人物即进入昏迷，体力低于1点，则无法行动。力量决定了肌体强度，敏捷则是人的行动速度和反应能力，体力决定了对异常状态的抗性以及承受伤害的能力，精神则是意志力体现。”</p>
<p>刘意比照了一下，自己除了精神远远高出常人以外，其余的均不占据优势，尤其是与搏斗伤害相关的力量与敏捷，是低于正常值许多的，而在提示的下方，还有一行鲜红色的长槽，想必这就是表示她所能承受多少伤害的血槽了。血槽为体力数值乘10。</p>
<p>时间宝贵，她提起了床边斜靠着的一把破烂短剑，穿戴上墙上挂着的陈旧皮胄，将门推了开来，却得到了提示：进入圆桌武士世界还有二分十七秒。</p>
<p>于是安静的站在原地等候着，时间一到后，随着门的推开，刘意的身上猛然涌出一股热流，瞬间涌遍了她的全身，本来拿在手里觉得颇为沉重的短剑也骤然变轻。她略一思索，调出个人菜单一看，发觉力量，敏捷，体力，三项决定肉搏近战的属性变成了6点，8点，8点，果然已经加倍。</p>
<p>外面是宽阔的原野，就着星光，可以发觉农民们的耕地根本得不到很好的照料，牧场也长满各种灌木丛，独立的农场几乎没有。北面的大路上有个地方还闪着灯光，应该是一处颇大的镇子，刘意在旁边的溪水里打了一盆水，在洗漱的同时，她发觉自己身上还多了一瓶喷雾剂模样的东西，在母体烙印的提示下，她向脸上喷了些，发觉外貌很快就被换成了一个欧洲男人的模样，束起的黑色长发也变成了凌乱的金发，看起来沉稳而阴翳，这比她本来的样子要好看一些，她想了想便向着镇子里行去。</p>
<p>镇子的建筑往往都散布在一条街道的两侧，或者是围着一片绿地这种建筑风格最早可能是为了防止养殖的牛群遭到强盗和狼群的袭击而设计的。</p>
<p>居民们的卧室是和自己饲养的家畜公用的他们的房子总共也就只有一个房间，没有烟囱，屋顶是未加修整的茅草，墙壁是涂过泥的编条或者木头。刘意从路上的车辙发觉，这个小小的城镇仍然算是一个附近的贸易中心，但是在市镇上进行的贸易量到底有多少，实在值得怀疑不过几乎可以肯定是很小的。应该一般只是交易一些生活必需品，例如盐、鱼和谷物之类。但是积累下来，蕴藏着的财富应该也是颇为可观。</p>
<p>这也是这个风光秀丽的镇子即将遭受战火波及的直接原因。</p>
<p>刘意走进镇上那个破烂非常的酒吧，试探的向着吧台上抛出了一个银币。然后点了一杯麦酒，旁边的已经有个大汉大声叫道：</p>
<p>“罗伦你发财了？怎么不请我也喝上一杯？”</p>
<p>刘意知道自己新身份的名字就叫做罗伦，望了望这个大汉，他的头发是淡黄色，头颅浑圆，眼睛大而有神，脖子粗而短，留着一大把大山羊胡，看起来十分粗壮，笑了笑道：</p>
<p>“行，巴拉森。”</p>
<p>巴拉森欢呼一声，将旁边的人撞得东倒西歪，要了满满的一大杯子苹果酒如风似的掠了回来，拍着刘意的肩膀大笑道：</p>
<p>“罗伦你果然够意思。”</p>
<p>他喝了几口，惬意的呼出一口气道：</p>
<p>“你是不是遇上了什么事？看起来愁眉苦脸的？”</p>
<p>刘意心中一动，立即试探着叹了一口气道：</p>
<p>“我听到了一个很不好的消息，我们镇子有大麻烦了。”</p>
<p>巴拉森又大喝了一口苹果酒，重重拍着面前结实的橡木桌子，大声自负的道：</p>
<p>“有巴拉森的斧头解决不了的麻烦吗？”</p>
<p>“可能……有的。”刘意故意拖长了声音沉着脸道。</p>
<p>……</p>
<p>事实上，刘意在前往镇子的路上就已经分析了出来，自己这几日要面对的这个世界上，应该有三种势力：一，惩戒骑士斯科恩及其麾下的势力，应该就在三日后入侵这个风光秀丽的镇子，第二势力，代表了正义与反抗的英雄820小队，第三势力，则是这个被侵略小镇中的居民，而自己，显然就被划分到了这个阵营中。</p>
<p>从那死掉的刘剑仅仅是找到了自己，便能获得向此处提出一个要求的情况来看，自己能看到他身上的母体烙印，应该是一件颇不寻常的事情，而自己的存在，也应该是对这里颇有价值，所以，初次进入后的首个分支任务难度，必然不会很大，应当仅仅是属于基本了解熟悉此处的生存方式的过程。</p>
<p>所以，杀死七名面具奴仆，两名重剑士，累计积分300以上的这个过程，应当就是可以依靠外力的帮手的。而后两个任务，则是具有着很明显的针对性估计应当就是自己过高的精神惹的祸。要知道，用脑子杀人比用力量杀人要简单方便得多。</p>
<p>听了刘意的回答以后，巴拉森已经怒气冲冲的站了起来：</p>
<p>“你是在侮辱巴拉森的力量吗？”</p>
<p>“不。”刘意淡淡的道：“是我们镇子即将被邪恶大公加利波迪的军队所侮辱。”</p>
<p>这句说得并不大声的话一出，嘈杂的酒吧立即安静了下来，巴拉森粗壮而生满绒毛的巨大手臂微微的颤抖着，不是因为恐惧，而是愤怒，看得出来，刘意的话语，勾起了他对往事的一些不好的回忆。</p>
<p>巴拉森微微的喘息着，将杯子里的苹果酒一口喝了下去，然后将杯子重重的砸在了桌面上，他哽着声音粗涩的道：</p>
<p>“你是从哪里听到的消息？”</p>
<p>刘意盯住他道：</p>
<p>“这消息从哪里来的并不重要，重要的是，你敢不敢和我一起去确认一下它的真实性？”</p>
<p>巴拉森一惊道：</p>
<p>“他们已经来了？”</p>
<p>“很可能。”刘意沉声道：“但应该没来多少人，还在等待为首的惩戒骑士斯科恩的到来。”</p>
<p>听到惩戒骑士四个字，巴拉森的脸肌又抽搐了一下，大声怒喝道：</p>
<p>“没有确切的消息，你这有前科的家伙又想要胡说八道？”</p>
<p>这时候酒馆中才开始议论纷纷，一种恐慌的气氛在牛脂蜡烛昏暗的光芒下散布开来。刘意微微皱眉，似乎觉察到了什么很重要的东西，她面对怒目而视的巴拉森，正想说话，忽然听得吧台中的一个叫做玛莉亚年轻姑娘轻声唤道：</p>
<p>“巴拉森。”</p>
<p>焦躁得好似一座火山的巴拉森立即垂头丧气的坐了下来，将粗大的手肘在桌子上重重一顿！似乎连房梁也在颤抖。玛莉亚却走到刘意的身前，温和的说道：</p>
<p>“罗伦，邪恶大公的军队可不能拿来开玩笑，你有确实的证据吗？我明天会去城里进些货物，若是你的消息有误，那么现在给大家道歉还来得及。”</p>
<p>刘意点点头，心中已经有了些明悟，也不再说话，微微一笑便提着手上的那把破旧的短剑行了出去。时间很珍贵，她已经得到了想要的提示，自然就应该进行下一步的事情了。</p>
<p>中世纪欧洲的空气很清新，刘意体会着这个世界带给自己双倍属性加成的快感，在一路的奔行中开始适应这这种全新的而强大的体验单单试想一下，一个本来能跳半米高的人，忽然就能很轻松的蹦到一米，这种体验当然是崭新深刻的了。对于精于算计的刘意来说，自己身体目前的基本数据是一定要了然于胸的，比如一步能跳多远，一剑挥下去，能斩多重，这些在搏斗中最是生死攸关的，可以说是差之毫厘，失之千里。</p>
<p>寻找惩戒骑士的部队其实并不难，尤其是在夜间，通常部队宿营之处，都应该有水源，既便于作饭，也能起到一个屏障的作用，其次是火光，这个混乱的中世纪年代，还不至于晚上的纪律严明到连火也不敢生，最后则是距离了，既然安排给她了这个任务，那么定然不会让自己疲于奔命的四处奔波。</p>
<p>于是很快的，循着小镇附近的唯一一条河流，刘意先向上游走了七八公里，接着又倒回来往下游走了两公里，就已经看到了火光，并且发现了一名前来打水的面具奴仆。</p>
<p>他穿着一件淡蓝泛绿的外套，袖子是淡紫的，本来灰白色的长裤已经脏污得发了黑，脚上的棕黄色的草靴深深的陷入了河边的软泥中。大概是奴仆的缘故，这人的护具就只有头上戴着的遮脸的铁盔和腰间悬着的短剑，他正吃力的提着木桶在河中舀着水。</p>
<p>刘意深吸了一口气，悄悄的从他背后的芦苇丛的遮掩下摸了上去不要忘记，刘意虽然只是一个少女，她另外一个身份，却还是在现实世界里被全国通缉的连环杀人犯！</p>
<p>当这名面具奴仆刚刚打好水直起身来的时候，后脑上立即中了重重的一击，这连着剑柄的直中要害立即令他当场昏死了过去。在割开这个家伙的脖子之前，刘意已经将其身上的衣着全部除了下来给自己换上。</p>
]]></description><pubDate>Sat Oct 31 2015 21:43:53 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/matrix-chapter-3</link><guid isPermaLink="true">https://blog.wxsm.space/p/matrix-chapter-3</guid></item><item><title>第二章</title><description><![CDATA[<p>说起来剁排骨其实只是一件相当难受的粗脏活计，并且报酬低得可怜，其实刘意之所以一直能够带着享受的感觉来做这份工作，为的就是能够体验灵光一闪时的那种对自身的超越。</p>
<p>姚老板看着刘意慢悠悠的动作，终于忍受不住，打早脸色铁青的就要过来教训这目中无人的小妞，谁知刚上前两步，菜板用力一响，“啪”的一声飞溅了几团碎肉血沫出来，惊得他连忙后退，惟恐身上的报喜鸟被脏污了，好容易见刘意停下刀正要重拾勇气过来教训人，却见这少女抬头，平静的望了他少许，将握刀的那只手伸出来，慢慢的将缠在上面的污迹斑斑的白布解脱，姚老板见了她的动作，不知道怎的，一下子就冷静了下来，退了一步，咽了一口唾沫，勉强维持先前的气势道：</p>
<p>“你……你不做事想干嘛？”</p>
<p>刘意很诚恳的细声道：</p>
<p>“我的能力有限，看来是不能满足您的要求了，这就自己辞职吧，这个月的工资，也就不要了。”</p>
<p>说着便将身上的围裙卷了起来，打算立即闪人，姚老板的心中猛然若被重击，这小丫头若走了，上哪去找这么廉价的苦力去？难得她又手脚勤快，还能当半个清洁工人用，纵然弄得慢了些，但她的手也确实看起来没偷懒，最关键的是！现在去人才市场上去另外找个墩子来，那非得给一千五包吃住不可，人品还难说得很！</p>
<p>人们常常说：当一件东西要失去的时候，才会明白它的可贵这姚老板也是，此时才想起了刘意的好处来，忙结结巴巴的道：</p>
<p>“没有没有，我只是进来看看，顺带催催而已，你干得不错的。继续继续，大家努力，晚上我加餐请客。”</p>
<p>一面说，一面便狼狈无比，点头哈腰的向外走，刘意嘴角微微上牵，干八百块一个月的临时工还能干得似自己这样，牛气烘烘连老板也怕的，想来也算是个奇迹了。</p>
<p>这一晚上，刘意一人当然是忙不过来的，之后老板亲自操刀上阵，陪她一道猛斩肋排，手上虽然被打出了两个大血泡，但这却典型的算得上痛并快乐着，晚上两点多一结帐，姚老板已是眉开眼笑，实在赚得盆满钵满，整整五百斤猪肋排做成干锅，整卖得精光，于是铁公鸡也难得的拔了次毛，每人发了五十块奖金，而晚饭准确的说，是宵夜，名义上是火锅，其实是将客人吃剩下的锅底混合在一起！但忙碌整天，都是饿得慌了，人人都在狼吞虎咽顾不了那么多，只图把肚子填饱再说。</p>
<p>刘意这晚上也着实累得厉害，她虽然忍耐力极强，但是身体上的疼痛可以克制，耗去的劲力却不能平空变将出来，连吃饭的时候，也是使的左手，她虽饭量不大，却讲究细嚼慢咽，所以吃完之时，人大多都散了，连最勤快的邹哥也直接靠在旁边的凳子上就打起了鼾，刘意也就拿了自己的饭盒前去洗刷，刷到一半时候，她的瞳孔遽然缩紧！</p>
<p>那刘剑不知道什么时候，已经无声无息的走到了自己的身后！</p>
<p>刘意能知道此事，并不是因为她有什么危机预感，也不是由于刘剑发出了声音被她觉察，而是她面前的不锈钢水笼头巧妙的将她背后的情景反射了出来！</p>
<p>“什么事？”刘意忽然出声，淡淡的说。她虽然对刘剑身上那个会眨眼的刺青很感兴趣，可是她却知道，你越是在意的东西，越要表现的满不在乎，这样才能用最小的代价来获得最大的收益。</p>
<p>吓了一跳的反而是刘剑，他浑身一凛道：</p>
<p>“你，你怎知道我来了？”</p>
<p>刘意嘴角微微上翘，却不回答他的问题，又补问了一句：</p>
<p>“什么事？”</p>
<p>刘剑对这种完全处于被动方式的对答很是有些不满，额头上青筋一绽，但又强忍了下来道：</p>
<p>“也没什么事，只是听说你学医的，最近胸口有些不舒服，想请你帮我看看。”</p>
<p>刘意心中一动，她的确想仔细观察一下刘剑胸口的那个刺青，只是一直就在计划如何才不能引人起疑的进行此事，谁知此人竟然主动送上门来！她的心中刹那间掠过一丝很不好的预感要知道，天地间的所有东西，都包含了利弊两面，凡是太顺利的事情，往往背后都牵连了些不大寻常的危机。</p>
<p>若是以刘意谨慎的性格，很是想出声将此事推脱开来，但这时候，眼前这个男人忽然一把扯开了胸前的衬衣！扣子“啪啦啪啦”的落了一地！</p>
<p>那个刺青！</p>
<p>那个狞笑着的墨绿色刺青又呈现在了刘意的眼前！</p>
<p>这时候她更是敏锐的留意到，除去了上衣刘剑…很养眼！浑身上下的肌肉轮廓异常清晰，一块一块的突兀了出来，看样子，竟是在长年熬炼气力里度过的！</p>
<p>但说实话，这厨房上下，他是最懒的一个，整天不是揣了手坐着，就是四处闲逛好似个监工，之所以这位苛刻的老板能容忍，那是因为刘剑的妹妹也在店里，并且与何铁公鸡的关系颇为暧昧。</p>
<p>这个刺青……很诡异。</p>
<p>刘意只能用诡异两个字来形容它。</p>
<p>自从那日初见这刺青以后，她便查阅了大量的资料，刺青的方法有两种，一是用鲨鱼牙齿及动物骨刺捆上木棒蘸上墨水，用小锤敲击入肤。第二种是用数第一种是毛利人流传下来的骨针绑在一起捆在木棒上，手工点刺入肤。但是无论哪种方法，都不可能营造出如此栩栩如生，惟妙惟肖的图案！</p>
<p>猛然间，那个狰狞猛恶的刺青，忽然咧开嘴对她笑了一笑！</p>
<p>饶是刘意心理素质极其过硬，可以做到谋杀了人后立即就倒头安睡，但也被此事陡然惊了一跳，四下里一片安静，日光灯的光芒变得惨白，水龙头的水在“滴答”响着，空气里有诡秘的气氛在悄然酝酿，刘剑脸色数变，最后面无表情的道：</p>
<p>“好看吗？”</p>
<p>刘意深吸一口气，她注意到刘剑看似平静，但是食指和拇指已在不住搓捏，眼球也微微外突，并且连手臂上的寒毛都微微张起，这说明他此时正处于一个异常激动的状态中，她脑海里刹那间闪现过无数念头，但双目骤然之间，又对上了那对深邃的鬼眼，竟是不由自主的回答道：</p>
<p>“很……古怪的模样。”</p>
<p>刘剑一下子就窜前过来，一把捏住了刘意的胳膊，双目里红筋清晰可见，激动得声音都剧变了的怪叫道：</p>
<p>“你……你果然看得见这烙印！”</p>
<p>刘意的自制力何其之强，话一出口，立知不妙，想要大声呼喊，猛然间腰上一凉，传来一阵轻微的刺痛，似乎有什么极尖锐的东西刺入了皮肤，在腰间的表面血肉里颤抖着，刘剑的声音变得阴沉诡秘，一字一句的道：</p>
<p>“走。”</p>
<p>刘意已经判断了出来，自己已被一把刀子抵住了腰，她冷静的道：</p>
<p>“去哪里？你小心别伤着我。这里可随时都有人来的。”</p>
<p>刘剑不说话，只是手略动了动，刺入体内半寸的刀尖用锐利痛楚的感觉给刘意指示了行去的方向。</p>
<p>那里是楼梯。</p>
<p>刘意本来以为刘剑要把自己挟持到通常人很少去的楼顶天台，但两人行进的方向却是向下，她很有些不明白，难道这家伙打算就这么押着自己下楼到大堂里去？她就不怕有人报警？就算她不怕，但是自己这个通缉犯却怕啊！</p>
<p>可惜刘意没有选择，只能随着楼梯跟随她向下走。隐约可以见到，刘剑的眼睛半闭着，胸口的那个狰狞鬼首刺青，发着朦胧的微光，在照耀到楼梯的时候，竟是产生了一种不真实的折射感觉！仿佛那坚硬的地面，都出现了水波般的漾动，像是那里有一层障壁，在间隔着另外一个世界！</p>
<p>两人就这么轻轻易易的穿透了过去！</p>
<p>接着走了半层楼梯后，刘意立即就觉察出了不对来！她每日里进出此处，为了大脑不至于空闲下来，当真随时都在寻找数据来记忆。正常的情况下，这半层楼梯一共是九阶，每一阶高十六厘米，然而她发觉，先前下的半层还属正常，转过拐角以后，脚下的楼梯就变作了十二阶，而每一阶的高度，也略有降低！</p>
<p>刘剑因为激动而喘息着，催促刘意快往下走，若按照正常的情况来说，此时他们应该已经走到了火锅城的楼下大堂处，然而刘意眼前出现的，却又是一个光线昏暗的转折，那无穷弯曲而下的楼梯，竟似要直通地底深处！</p>
<p>这一切都不能以现代科学来形容了。四下里一片静谧，甚至还有不停响起的水声和粗重兴奋的呼吸声混合在了一起，刘意感觉自己手臂上似被连上了一道铁箍，根本就是被这刘剑毫不费力的拖着向前走去。</p>
<p>五层，六层，七层……刘意在心中默默数着，留意着向下迈进的梯次，虽然普通人都能做到观察周围环境，但是刘意却可以从中留意到大量的细节，并且将之储存在脑海里，更能借助推理逻辑学，预判出即将会发生的某些事实。</p>
<p>在走到第十四层的时候，已经可以隐约听到喧哗的人声，刘意饶是有着心理准备，但还是生出不由自主的喜悦，在这样阴沉的环境里缓慢行进，实在是令人心理上都产生了一种强烈的压抑，连呼吸都有些不畅了。在走到第十七层的时候，已没有楼梯可下了，脚下传来的质感是且软且腻的感觉，那就仿佛是踩在……内脏上一样。</p>
<p>这时候，刘剑胸前的那个狰狞刺青发出了幽绿的光芒，很是阴冷的将四下照亮了开来，但也仅仅是局限于他们身周数米的地方，就好似是一个惨淡的微绿光球将两人包裹了起来。紧接着，远处陡然有一丝锐利白光闪了一下，刘意见了，立即条件反射般的闭上了眼睛，她只觉得双目一阵刺痛，单单是被这光耀了那么半秒的时候，就有一种身心都被刺伤了的感觉！</p>
<p>而刘剑则立即惨叫了一声，他的双目凸出眼眶几乎一厘米，脖子上的青筋也一根一根暴突了出去，看起来像是浑身上下的血液都在沸腾，整个人似乎会立即炸裂！他的双手在空中狂舞乱抓，喉头里咯咯吱吱的哑声痛苦道：</p>
<p>“等……等下！”</p>
<p>黑暗中传来了一个飘渺冷酷的声音，带了金属般的硬度和质感道：</p>
<p>“你违反了规则，所以应该接受惩罚！”</p>
<p>声音传来的一刹那，刘剑已声嘶力竭的吼了出来：</p>
<p>“我没有！这个人能看到母体烙印！”</p>
<p>他的吼叫声在这虚幻诡秘的空间里传扬了开来，交相叠撞着，远处白光忽的炽亮，又湮息，不过此时的感觉给刘意却是很有些温和，接着渐渐的，那光芒就若水银泄地也似的铺散了过来，就像是一条白茫茫的大道，若地毯般直接延伸到了两人的眼前。</p>
<p>刘剑大喜之下，忙拖着刘意顺着白光奔了过去，随着距离的接近，刘意留意到前方渐渐的出现了一个巨大的轮廓，再走近些才发现，那赫然是一座泛出青铜色泽，上面整齐生出各类长长獠牙的巨大拱门，其高度至少超过了百米，就那么顶天立地的撑持在那里，单单是看着它，心中就不由自主的生出一种莫大敬畏，有想要跪地膜拜的冲动。</p>
<p>门下，坐着一个人。</p>
<p>那人的脸上戴了一副面具，与刘剑胸前的那张刺青鬼脸相似。他仅仅是坐在那里，刘意就感觉到刘剑捏着自己前臂的大手已在颤抖，也不知道是因为害怕，还是由于兴奋。</p>
<p>“就是她？能看到你的母体烙印？”那鬼首面具人说话了。</p>
<p>刘剑急忙道：</p>
<p>“千真万确！”</p>
<p>鬼首面具人转向了刘意，他的目光由上至下的扫视过来，刘意立即觉得浑身上下的汗毛都倒竖而起，就像是被某种电荷迎面穿透过一般。但她依然很平静的站在原地，默默的望着对方。</p>
<p>“恩。”鬼首面具人徐徐的道：“你没有说谎，11615号。她的确能看到你的梦魇烙印。根据世界法则，你可以提出一个符合法则的要求。”</p>
<p>刘剑“咕嘟”一声咽下了一口唾沫，干涩无比的喘息道：</p>
<p>“我……我要求脱离母体空间！重新过回正常的生活！”</p>
<p>鬼首面具人顿了一顿，显然很是觉得有些意外，旋即用那种冷硬的语音道：</p>
<p>“你可知道代价？”</p>
<p>刘剑的脸抽搐了一下，双眼露出疯狂的光芒，这种目光，刘意曾经在那种输红了眼的赌徒身上多次看到过！</p>
<p>“我……知……道！只要能顺利走出你身后的那扇门，就能同这鬼地方一刀两断！刘剑刘老二咬牙切齿的道。“别人能走出去，为什么我不能？”</p>
<p>听到这句话，刘意就在心中叹了口气。这世界上本来就有许多事情，是别人能做而你却做不到的。</p>
<p>鬼首面具人声音平淡得不带任何起伏的道：</p>
<p>“进门吧！”</p>
<p>他的背后，瞬间出现了一扇寻常无比的破旧木门，若一定要说有什么不平常之处，那就是木门的把手上，隐隐约约透出一丝动人心魄的红色光芒！</p>
<p>刘剑的脸肌扭曲着，忽然大吼一声，握住了那个把手扑进了门中，门开关得极快，但是刘意依然可以看到内中透露出来的一丝血红色光芒，房间内猛然响起了连声古怪的响动，既仿佛是一头凶兽在用力咀嚼骨骼，又若是十七八个人在用力拉动锯子伐断木头。然而只是过了一分钟……准确的说，是刘意默数到五十五下的时候，房屋里陡然响起了一声凄厉绝望的惨嘶！</p>
<p>“杀了我！”</p>
<p>这话音刚落，在连声极有力砍肉削骨的闷响过去，有黑色的沫液从那门缝中标洒了出来，将刘意的脸上击得生疼，又缓缓的滑淌而落。刘意却没有伸手去擦上一擦，反而饶有兴致的回味着先前房间中最后传出的声音，并且情不自禁的想道：</p>
<p>“原来，人的骨头被剁碎发出的响声，和猪骨头被剁碎的响声，是一模一样的啊。”</p>
<p>鬼首面具人安静的望了她好一会儿，才淡淡的道：</p>
<p>“过来吧。”</p>
<p>刘意想了一想才道：</p>
<p>“既然我来到了这里，又看见了这许多不可思议的事情，那么若不加入，想必后果很严重了。”</p>
<p>“后果和他一样。”鬼首面具人平静的道，他说话的时候，眼睛是望着刘意脸上的那一条渐渐凝聚的鲜血。</p>
<p>“那么，加入了有什么好处？”刘意笑了笑，这个时候她竟然还笑得出来！“就好像是一个十分苛刻的老板要聘请员工，你总得先把福利待遇亮一亮吧。”</p>
<p>鬼首面具人未想到这少女竟是如此镇定，他楞了一楞才道：</p>
<p>“如果……你能够完成母体交付出来的十个黄金主线任务，母体会满足你一个要求。”</p>
<p>刘意忽然深深吸气，她垂着头，旁人也看不清楚她脸上的表情，只能感觉到这少女有着极其激烈的思想斗争，良久，才很是审慎的用词道：</p>
<p>“那么……这个要求是不是能够完成我做不到……或者是想都想不到的事情？比如……死而复生？”</p>
<p>“能。”鬼首面具人只回答了一个字。显然，他并不是第一次遇到询问这个问题的人了。</p>
<p>而刘意遽然握紧了拳头，这并不是要攻击人的前兆，而是由于过度的激动兴奋全身上下的肌肉都绷紧了开来，嘴唇因此被无意识的咬破，有一股咸涩的腥味儿在口腔里徜徉。</p>
<p>那是血的味道。</p>
<p>“我加入。”刘意很快就恢复了平静道：“要我怎么做？”</p>
<p>“你杀过人？”鬼首面具人忽然问出了一个风马牛不相及的问题。而刘意却知道，她是从自己目睹人惨死后的平静中看出了这一点，于是很技巧的道：</p>
<p>“过去的事情，我不想再提了。”</p>
<p>鬼首面具人深深望了她一眼，忽然弹了弹手指。</p>
<p>只见她身后那一扇接天连地，诡异宏伟的青铜色巨门，忽然发出了微弱的光芒，那光芒的色泽十分诡异恐怖，就仿佛是沉稠的鲜血被刷到了那巨门之上。鬼首面具人吩咐道：</p>
<p>“走过去吧。”</p>
<p>刘意深吸一口气，慢慢的行了过去，在距离巨门还有一米的地方就发觉，那门上竟有无数细微的小钉和诡异的花纹，她正要仔细看清，猛然身体前方传来一股沛莫能御的巨大吸力，紧接着是右肩感到一阵热辣辣的疼，然后便昏迷了过去！</p>
]]></description><pubDate>Fri Oct 30 2015 02:10:42 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/matrix-chapter-2</link><guid isPermaLink="true">https://blog.wxsm.space/p/matrix-chapter-2</guid></item><item><title>第一章</title><description><![CDATA[<p>在处理完整整百余斤排骨和各类火锅配菜后，刘意终于完成了今天的工作，她揉着酸疼的手臂面无表情地向着内间走了进去，拿起自己的塑料饭盒，舀了满满的一盒白饭就着旁边的小菜慢慢吃了起来，而顾客吃剩的火锅汤汁，她也会舀些来泡饭。</p>
<p>一顿简单的晚餐加上九百块钱的月薪，就是刘意这份工作的待遇，同样也是精明的老板肯让这个笨手笨脚的员工留下来的主要原因。这个价钱只是相当于洗盘子工的一半，但是高强度的工作量，却是洗盘子的两倍！</p>
<p>所以，不管刘意平时如何沉默，如何不近人情，如何的笨拙，只要没有犯什么大错，就算是厨房里挑大梁的主厨也不能叫她滚蛋的，当然前提是在没有出现一个比她要价更低的替补以前。</p>
<p>刘意吃完一大盒米饭，三份泡菜，无声的站了起来，走到卫生池边洗着饭盒，负责带她的刘剑刻意的从她的身边撞了过去，将数十个碗盘哗啦啦的叠进了泛着油污泡沫的洗碗池中，然后翻起一双三角眼，骂骂咧咧的道：</p>
<p>“不长眼啊？滚一边去！”</p>
<p>刘意淡淡的将自己的饭盒收了起来，忍不住望了他一看。其实刘意在这些小事，根本是心平气和，以往的她几乎是忍受了整个社会的嘲讽，鄙视，冷漠，与之相比，这个男人的刻意挑衅和捉弄简直连毛毛雨都算不上！</p>
<p>她之所以多看一眼，是因为透过刘剑油污的白色厨师服的领口，隐约出现了一个淡绿色的怪异刺青！那刺青是一个十分狰狞咆哮的鬼脸形状，在刘意的目光投射上去的时候，鬼脸刺青那双凶厉传神的眸子，赫然竟是诡秘的向着她眨了一眨！</p>
<p>两人同时都是一震！刘剑滔滔不绝的污言秽语遽然间像被一把剪子生生中断了似的，嘎然而止，而刘意年轻冰冷坚硬的心中，也陡然的生出了一股铺满后心的冰凉寒意！</p>
<p>然而，当事的双方都不约而同的背过身去分头走开，各忙各的去了，仿佛什么事情也没有发生过。</p>
<p>弄妥店里的这一切后，已是晚上十点多了，刘意费力的穿梭过人头攒动的大堂，等她走到门口的时候，已经将目前店中消费者能给老板提供的利润估算了出来，一共是五千五百至八百左右。她望的第一眼，就已经将所有的消费客人统计了出来，紧接着通过心算核算成本，在短短几分钟内得出了如下数据。这是刘意平日里条件反射的锻炼自己的行为，等走到大街上，她又开始默记行过的车牌号码。事实上，她是在强迫自己善于思考的大脑一刻不停的工作，否则就会难以自禁的想起过去，从她记事起之后的过去。</p>
<p>然后思绪就会被记忆填满，像是洒了一地的豆子似的零零碎碎，但又能清晰地分辨出每一粒都是哪年哪月的事，其中有很多她不愿意想起的事情。</p>
<p>父母去世的消息传到家里那天，在听到这个消息时，素来对父母恨得咬牙切齿的奶奶悉悉索索地哭了，她自己却只是呆了半响。若按正常的解释或许是从小的孤僻令她不擅把握作为人的感情，她当时却是在琢磨小时候父亲说过的一番话，</p>
<p>“人的死本身没有意义，因为死去的人是没有知觉的，只是活着的人赋予了他们知觉和意义，痛苦，悲伤，不甘，绝望。”父母两人本就因为与奶奶不和在外工作多年，感情经历单薄的她不懂该如何赋予那些知觉和意义，她一开始只感觉到一股充满威严的名叫死亡的气息将她的思维压得喘不过气来。直到奶奶哭声越来越重，她才感觉到了那叫做悲伤的情绪从奶奶的呼喊声传到了自己的内心深处，让她也开始哭了起来，她发现随着眼泪的流淌，那股因感知到死亡而变得沉重的内心渐渐舒缓开来。那天她陪着奶奶做了很多“法事”，比如用镰刀割家门口的门框，这是村里很早以前的习俗，有什么意义她也不知道，也想不明白。相较之下，楼下小卖部那个挎着小包目光炯炯的老板娘的行为倒是很容易推敲。</p>
<p>奶奶去世的那一天，她却没有再哭。她的心中却仿佛被一把刀子搅扯般，流淌着温热刺痛的鲜血，那伤口始终没有愈合，血也一直在流淌，她恨自己为何没能觉察到奶奶的求死的念头，她觉得她本应该能做到的。这滚雪球般的自责令她疯狂的杀死了或直接间接逼死父母的那几个人，并且学以致用极尽所能地给那几个死人赋予了些特别的意义与知觉。但是复仇过后日益强大的空虚，令她实在难以承受。甚至心中有个疯狂的念头一直在呐喊着：</p>
<p>“要么毁灭了这世界，要么毁了我！”</p>
<p>两排街灯安静的延伸向前方，组建成了两条平行的光带，汽车或快或缓慢的从街上开过，走在人行道上的刘意却忽然闷哼一声，痛苦的按住了头部。</p>
<p>这是过度用脑的后遗症。</p>
<p>精于推理的她，非常清楚自己不久将来的下场是什么，精神崩溃被强制隔离，或是选择一场轰轰烈烈的毁灭。</p>
<p>一波一波的剧烈神经性痛楚卷袭而来，刘意觉得自己仿佛一叶孤舟沉落在咆哮的苦海里，仿佛随时都会舟覆人亡。她唯一能做的事，就是死死掐住身边的树干，连指甲也倒翻过来，剧痛依稀，但她疲倦的大脑，依然在疯狂飞速的转动，脑海里不自主仍是种种复杂纷乱的回忆，而就在刘意即将崩溃的刹那，她的脑海里猛然闪过了一双眼睛！</p>
<p>一双凶厉传神的眸子！</p>
<p>那个刺青！</p>
<p>刹那间，潮水般的痛楚退去，刘意几乎在眨眼的时间就判断出，已有的科学知识，不能解释一个刺在人胸口皮肤的刺青为何会自动眨眼。那几乎崩溃的精神立即被她半强迫半自愿的全部转移到了这个问题的思考上来。</p>
<p>直到走回了住的地方，刘意也没有能够对此事作出了一个任何符合逻辑科学的解释，她却感到十分庆幸，这关于刺青的问题一天没有解开，或许就代表着她一天不用再受那无限痛楚的煎熬。</p>
<p>刘意所住的地方，是惠山大学的学生宿舍楼，她在家乡策划杀人后，便在一处早已预备好的地方躲了一个月，等到服药与拔牙后的容貌有了颇大的改换之后，便坦然的登上火车，来到了这处三流大学中就读，她当然不是要来读书，只是想藏身，骤然扩招而管理混乱的大学中，有着海量的同龄人，廉价的住宿处，大把空闲的时间，刘意实在想不出来还有什么地方更安全的了。</p>
<p>而不出她所料的是：教务处唯一重视的，就是学生有没有如数交纳学费。至于其他的，均是形式主义。入学新生接待处的老师，显然只重视钞票的真伪，连续丢到验钞机中查证了三次，而刘意按照程序递上的假身份证，却连扫上一眼的闲心都没，甚至连她学生证上的姓名，也写成了刘亦。</p>
<p>她当然不会站出来纠正这个英明的错误。</p>
<p>……</p>
<p>“回来了啊？小七？”同寝室的李丽倚在洗漱间里，满嘴白沫的塞着牙刷出声招呼道。</p>
<p>刘意嘴角扯了扯，点了点头。李丽显然也很习惯她的性格，默默地转过身继续。刘意的话不多，但却很会与人相处，同寝的人都与她关系颇好，虽然背地里有人嘲笑的叫她河马，但当面通常都亲密的叫她小七。</p>
<p>因为学校扩招了部分学生的关系，她们的宿舍很不够用，因此这间小小的斗室中，就整整塞进了八个女生，不过由于女生素来爱净的缘故，这小小的寝室也可以算得上干净明亮了，她推门进去，坐在床边看人上网打了一会儿牌，便洗漱一番爬上床去睡了，只是在梦中浮现得最多的，依然是那双邪恶凶厉的鬼眸！</p>
<p>第二日上完课以后，刘意默默的收拾好书本，平静的行出门去，她眼下给自己定下的目标，那就是一定要低调，尽量显出平凡，就像一滴水只能溶入大海，才能够成功的藏匿起来。</p>
<p>她早早的来到了奇香味的铺面上，这时候中午的繁忙已过，地面桌凳都已打扫干净，四下里静悄悄的没有人，连前门的两个迎宾小姐懒懒的斜靠在内间米黄的沙发上打着瞌睡，刘意行到了厨房中，揭开冷柜一看，却发觉采购还没有将今天的食材买回来，便呆呆的站在了原地一会儿后，寻出磨刀石来仔细的磨着斩骨刀，紧接着又主动将四下里洒上水，扫除干净。</p>
<p>老板出来撞见了，夸奖了几句，但也只是夸奖而已，物质上的奖励是不要痴心妄想的了。</p>
<p>想来是这几日生意特别好的缘故，今儿采购急忙忙的往店里拖了整整两趟，那架老旧的三轮摩托实在已不堪重负，在行驶时都发出了黯哑难当的嘎吱声，让人很怀疑下一秒它就会彻底散架开来。而刘意的工作量便平添了一半还多，经过半年来的磨练，她已学会在拿刀的掌上绑上一层布条，本来早已起了茧子手掌，此时在高强度的工作中，也磨起了血泡，惨不忍睹。</p>
<p>然而即便她从肉菜一运来便不停歇的砍切，外间生意消耗的速度也是越来越快，她加工的速度便已完全跟随不上了。到后来气急败坏的老板目睹好几桌客人失望走掉以后，终于奔入厨房脸色铁青的前来监工。</p>
<p>但是刘意之所以肯前来做这项工作，一是想借劳累的杂务来打发时间，好令自己不去思考太多的事情，二来则完全是出于锻炼自己欠缺的能力。希望尽量能活得能像正常人一些。所以，她完全无视肉痛无比的老板的大声咆哮催促，依旧我行我素的慢丝条理的剁着，竭力的使自己剁出来的排骨小一些，个头均匀一些。何老板见自己亲临竟没有起到任何作用，终于怒发冲冠，将抽到一半的烟屁股一掐！大声骂道：</p>
<p>“老子在这里你还敢偷懒？搞快！”</p>
<p>刘意垂眉闭眼的恍若未闻，依旧慢吞吞的剁着，直到眼前一亮，忽然挥刀狂剁，将手间的那根肋条斩成数十段，这才很是满意的勾起嘴角笑了笑。如果可以仔细用弹簧称来量足等份的话，便能发觉这十来段排骨虽然大小形状各不一样，但是其每一块的重量，都是惊人的相似！这便是刘意剁了半年菜，每日里整整剁足几个小时的收获。</p>
<p>她本就是个绝顶聪明的人，虽然因为基因缺陷的关系，在这等细微小事上的把握有所欠缺，但正所谓熟能生巧，每日里总有那么几次会出现这等灵光一闪的感觉，凭借本能将排骨剁得等重等量就与NBA的那些职业球员在投篮时候，偶然会出现百发百中的情况颇为类似。可以这么说，寻找到这种从容感觉并且享受它，已成了失去人生目标的刘意为数不多的乐趣之一了。</p>
]]></description><pubDate>Fri Oct 30 2015 01:25:27 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/matrix-chapter-1</link><guid isPermaLink="true">https://blog.wxsm.space/p/matrix-chapter-1</guid></item><item><title>楔子</title><description><![CDATA[<p style="text-align: left;">
  刘依。
</p>
<p style="text-align: left;">
  女。
</p>
<p style="text-align: left;">
  汉族。
</p>
<p style="text-align: left;">
  父母双亡。
</p>
<p style="text-align: left;">
  于二零一二年八月十七日晚被发现失踪，半月后其表姑报警，在其家中发现两具高度腐烂的尸体。经DNA验证，分别属于同村的刘大富与钟系花夫妇二人。后经过多方调查，林湖镇近两年来发生的六起本被认定的意外伤亡事故，应当均与此犯罪嫌疑人有关。
</p>
<p style="text-align: left;">
  这是警方手上关于她的唯一资料，并且大部分内容还是从刘依家那间空荡荡的老房子中找到的，而这个连环杀人案留给警方的线索就实在太少了。有价值的东西早已被变卖一空被刘依用来还了安葬祖母而借的外债。只有墙角里的一堆纸钱灰烬，就仿佛象征了这少女的半生：阴涩，死亡，还有被风吹都仿佛要飘散的易碎。
</p>
<p style="text-align: left;">
  作案动机清晰得就好似挂在堂屋正中的镜框玻璃，那是本来已经死去三年的刘依的祖母，正在相片里对着两具死不瞑目的尸体灿烂的笑着。警方已经确认，这两年来或间接，或直接死在刘依手上的人，一共是七个。
</p>
<p style="text-align: left;">
  整整五男二女，一个不多，一个不少。
</p>
<p style="text-align: left;">
  这七个人有亲戚，有夫妇，有儿女，有朋友，加起来的关系就仿佛是一张网，能将一个普通老人活生生逼到绝路上的网！当然或许他们并没有想要这个老人死，只是本能的将自己的快乐建立在他人的痛苦上，亦或是想制造一些娱乐气氛以供消遣而高估了他人的承受能力。
</p>
<p style="text-align: left;">
  于是，悲剧发生了。
</p>
<p style="text-align: left;">
  这个老人正是刘依的祖母，而她的两个亲生儿女，却是刘依那双双早逝的亲生父母！
</p>
<p style="text-align: left;">
  所以，这个惊人的消息被哄传出去以后，很快的，一个本来就已残破不堪的家庭在街坊间的议论和众人打麻将时飞溅的唾沫中岌岌可危。
</p>
<p style="text-align: left;">
  在一个闷热得令人难以透气的夏夜里，不堪压力的老人带着解脱的感觉，煲下一锅放了农药的绿豆粥。
</p>
<p style="text-align: left;">
  在镇上打工的刘依下班回来时，瞳孔都已经放大，心跳呼吸都停止好久了。本来老少相依为命的家，轰然破灭。
</p>
<p style="text-align: left;">
  她却没有哭，也没有闹，苍白着脸，呆滞的在奶奶的尸体旁边整整坐了几天，只是间获的驱赶一下蚊子，苍蝇，才能发觉他还是活着的，最后等到邻居实在忍受不了散发出来的气味，怒气冲冲的前来敲门，刘依才很平静的拨通了殡仪馆的电话。
</p>
<p style="text-align: left;">
  直到这时，被轰传得沸沸扬扬的流言才遽然熄灭，人人都怀了那么一丝半丝的歉疚，不大再好意思提起这事了，村里的几人和老人有过的纠纷也自然没有传扬出去，只是围绕着刘依的话题又逐渐多了起来。
</p>
<p style="text-align: left;">
  “我看这丫头从小就呆，看来果然如此。”
</p>
<p style="text-align: left;">
  “那是，姐弟俩搞那事，生出来的当然是傻子。”
</p>
<p style="text-align: left;">
  “她以前读书时成绩一直就差，咱家大妞说，老师叼得最多的，就是她了。”
</p>
<p style="text-align: left;">
  “十几岁的姑娘，书没读几年，脑袋又笨，只怕将来&#8230;”
</p>
<p style="text-align: left;">
  “……”
</p>
<p style="text-align: left;">
  而这些村民却都只知其然而不知其所以然：
</p>
<p style="text-align: left;">
  每个正常人身上可能携带有几个甚至十几个有害的隐姓等位基因，近亲通婚会使得这些隐姓等位基因有更多的相遇机会，并且产生遗传上的异常。人类的核基因组一半来自父亲，一半来自母亲，在近亲通婚的情况下，两个相同有问题的基因结合到一起的机会远远大于非近亲通婚的人，其后代的死亡率高,并常出现痴呆、畸形儿和遗传病患者。
</p>
<p style="text-align: left;">
  但是，高风险必然就会获得高回报，近亲结婚却还有极小的几率产生出某方面能力极其卓著的人：在一八八五年，德国的一个叫做阿洛伊斯的男人娶了自己的嫡亲外甥女，他们的第一个儿子的名字叫作：阿道夫.希特勒！
</p>
<p>进化论创始人达尔文的祖父母是嫡亲表兄妹，这并没有影响达尔文成为科学巨人。</p>
<p>美国豪门杜邦家族近亲通婚整整百年，族中商业奇才众多！</p>
<p>而最典型的，则是一对犹太人表兄妹，他们生下了一个公认的高智商天才，爱因斯坦！</p>
<p>刘依，亦是这极小概率中的一份子！</p>
<p>她现在仍清晰的记得，第一个动手杀的人，便是楼下小卖部的老板娘！在民警来家里向奶奶传递父母死讯时，这个女人偷听到了父母的秘密后引为奇谈，不遗余力地到处宣扬，若不是她，自己的生活也绝不会似现在这样孤苦伶仃，凄然一生！</p>
<p>四年前的那天凌晨深夜，刘依在寂静的长街上足足等了五小时十一分，终于等到了这肥婆牌瘾过足，悄然尾随其后，偷偷掩至举起手中的铁锤，骤然发力，对准后脑勺狠狠地砸了下去！</p>
<p>……</p>
<p>啪！</p>
<p>血水四溅！</p>
<p>“刘意你这傻逼怎么做事的！做墩子半年了，剁个骨头都搞得到处乱跳！”</p>
<p>这破响锣的声音一起，整个“香香记”厨房里的人，都不用听内容也知道刘剑又在拿这新来的那小姑娘撒气了。说来这事希奇，半年前来应聘的时候，这叫做刘意的小姑娘手法确实生疏，叫她试试手，弄了半天，切出来的肉片能用根来形容，而肉丝……也是用根来形容，最后哭笑不得的主厨让她去削萝卜皮，萝卜倒是削好了，只是两斤重的萝卜整整被她削去了八两。</p>
<p>精明的老板在外间听服务员将此事当成笑话说起以后，却赶到了厨房里，望了望眼前木呐安静的姑娘，直接把她拖到了案板前，丢了一把厚背刀上去，不耐烦的道：</p>
<p>“你能不能吃苦？”</p>
<p>刘依从旁边默默的取下了一条围裙围上，瘦弱的身体被宽大的围裙一裹，更加显得瘦骨伶仃，她接着才简明扼要的道：</p>
<p>“能。”</p>
<p>老板挽起袖子，翘着嘴上叼着的双喜烟，从旁边的冰柜中乒乒乓乓提出了整整十来片猪肋骨，加起来怕有百十斤重，喘着气道：</p>
<p>“今天你要是能把这些排骨给我剁好了，就留下来吧。”</p>
<p>她没有说话，只是无声的握住了横在案板上的厚实刀柄。</p>
<p>其实，大概是因为上天对人是公平的缘故，天才往往还会加上白痴的后缀，在某个方面特别突出，那么往往在另外方面就会显得弱势，就好比陈景润这个数学家对家务事一片茫然，某位钢琴天才生活不能自理，某位物理学家下厨房的后果就是引发火灾，刘意也是如此，她从小就不大会削铅笔，不擅长做这些精细的工作。不过骨子却里有一股狠劲，只要是觉得有必要事，哪怕不擅长也要去训练。</p>
<p>在进门之前，刘意坐在这家名为“香香记”的火锅店对门观察了一个小时，发觉这家店的招牌菜就是排骨火锅，她推断出，这里缺的，很可能就是能够担起剁排骨这种苦差的人手，因此便进来应聘帮厨，以至于人人都没有留意到，在老板发话之前，这姑娘已经预先将厚围裙穿上，避免用力砍排骨的时候血水溅到身上。</p>
<p>于是忍住手臂酸痛的刘意，得到了这份高强度，低回报的工作。或者说，兼职。</p>
<p>现在的她有了三重身份，一重是香香记的帮厨，一重是惠山大学成人大专护理系的学生，最后那重身份，自然是公安部网上通缉的要犯！</p>
<p>只是没有人会将那通缉令上那个略胖，圆脸的娇憨少女，与现今这个削瘦，高颧，冷漠得近乎呆滞的女人联系在一起，哪怕此时刘意的奶奶和父母重新活过来，也未必能认出他们的孩子！ 这也并不是整容。</p>
<p>为了迅速的改换自己的模样，刘依在亲手杀死了复仇名单上的最后那两个人之后，便开始在逃亡路上口服预先备好的特殊药物，接着又用老虎钳连敲带拔硬生生翦去了上颌的左右犬齿！</p>
<p>这是一个恶心而充满了痛苦的过程，因为药物对身体的侵蚀加上节食，体重就开始急速下降，身形也日渐单薄，而拔除了犬齿，则使得面部肌群渐渐开始出现局部的萎缩。用这两个精妙而残忍的办法，刘依成功的令自己的形貌发生了极其迅速的改变！</p>
<p>而通缉令上的照片又是她刻意放在老屋中留给警方的，刘依算准了警方绝对寻不到自己近期的其余照片！于是再没有人会将她与那个杀人凶犯联想到一起！</p>
<p>自此刘依不再是刘依，她给自己起了个谐音的新名字，刘意。</p>
<p> </p>
<blockquote>
<p>本文由loolorl_lar发表此处，请勿转载。</p>
<p>文中一切人名，地名，事件均属杜撰虚构，如有雷同，算你走运。</p>
<p>该小说仅供朋友间消遣，自娱自乐。不作商业以及任何公共形式的传播。如内容违反相关部门相关条例，作者拒不承担任何责任。</p>
</blockquote>
]]></description><pubDate>Thu Oct 29 2015 02:13:44 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/matrix-chapter-0</link><guid isPermaLink="true">https://blog.wxsm.space/p/matrix-chapter-0</guid></item><item><title>毕业后的第一个中秋</title><description><![CDATA[<p>学生渐渐开学，才意识到毕业以来已经过了一个暑假的时间。公司为期三个月的培训终于快结束了，我也终于有空回家休息一段时间。培训结束后，感觉自己的变化除了学到的知识以外，就是多了一些自信，对很多东西的理解不再是处于未知或一知半解的状态。学习使人进步。</p>
<p>挺久没有回过家，上一次应该是在五一的时候，所以比较想念家人。不知道家里现在是怎样的了，应该没有什么变化。前段时间出租屋的椅子坏了，往后靠就会摔倒，想买一把才发现椅子挺贵的，房东不给换，郁闷的时候想到在家里从来没有操心过类似的问题，只要跟爸爸或者妈妈说一句就会有替代品，虽然可能不合己意但却不需要付出任何代价。这些事情可能只有在独立生活后才能发现，饭要自己做，碗要自己洗，衣要自己晾，门要自己锁，下班回来累了一躺就是到半夜，醒来发现灯还亮着，门禁卡还戴着，一看手机早上四点多，这时候就能体会到一些孤独。体会到在家是多么的幸福。感谢爸妈给我的回忆里充满的都是快乐。</p>
<p>马上过完今年的生日，我也要24岁了，人生走到了一个过渡期，从学生到打工者，从学校到到职场，时间过得这么快，觉得有一些不适。生活还没有转变过来，以后的路还那么长，对未知的未来充满了恐惧。</p>
]]></description><pubDate>Wed Sep 23 2015 21:29:36 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/first-mid-autumn-after-graduation</link><guid isPermaLink="true">https://blog.wxsm.space/p/first-mid-autumn-after-graduation</guid></item><item><title>Ext 使用总结</title><description><![CDATA[<p>公司要求会用Ext Js，没办法必须学，下面总结了一些学习与使用过程中的经验。<!--more--></p>
<h2 id="">从一开始就使用英文文档 <a class="header-anchor" href="#" aria-hidden="true">&#128279;</a></h2>
<p>这点是我认为最重要的，有人也许会觉得很奇怪，不是有国人翻译的中文文档吗？而且很全，为什么要强行用原版呢？</p>
<p>两种文档我都参考与使用过，最终还是选择了直接使用原版文档。最重要的原因是Ext本身自定义的名字与行为很多，不去看原版的话很难将两个或多个多个地方出现的同一个词语联系起来，另外这些词语也与代码有最直接的联系，看翻译版的话也许很容易就会出现被翻译误导的情况，翻译能正确地指出一个词的意思，但不能建立像原版那样名词之间的联系。</p>
<p>另一个原因是，英文文档中自带了很多基本与扩展使用的例子，我们在完成一些日常功能的时候都可以去参考文档内的例子而不用自己去根据API文档苦思冥想。</p>
<p>需要大量使用Ext文档的时候我们一般可以把它下载回来到本机搭建一个本地文档，这样就可以解决国内访问国外网站延迟较高的问题。需要注意的是文档需要部署在Http服务器（如Tomcat，Apache等）上方可正常访问。</p>
<p>下载文档的链接可以在<a href="http://docs.sencha.com/extjs/6.0/" target="_blank">http://docs.sencha.com/extjs/6.0/</a>找到，如图所示：</p>
<p><img src="https://raw.githubusercontent.com/wxsms/wxsms-img-holder/master/20150919110411.png" alt=""></p>
<h2 id="sencha-architect">关于是否使用Sencha Architect <a class="header-anchor" href="#sencha-architect" aria-hidden="true">&#128279;</a></h2>
<p>Sencha Architect的所有功能都可以无限期试用，基本上就是一款免费软件，它可以帮助Ext Js开发者使用可视化界面快速开发复杂结构与逻辑的页面，以及添加自定义插件，缺点就是做出来的页面在build之前体积非常大（一个页面大概100至200 MB），build以后也经常会出现问题。用不用它是一个很纠结的问题。</p>
<p>公司开发部门的老师们看起来都不太喜欢这款工具，主要原因大概是使用工具会妨碍自己对代码的理解，担心在脱离工具以后不能很好地掌控代码的行为（准确地说应该是不如从一开始手打代码掌控得好）。但我觉得这对于一个有一定经验的Ext开发者应该完全不成问题，不知道为什么老师们不喜欢这款工具。手撸Ext界面是一件再痛苦不过的事，一个复杂的Ext页面动辄成千上万个括号，根本不是普通代码的形式，可阅读性与可修改性都非常差。而且Ext号称完全兼容IE，但这是基于我们的代码不出错的情况，IE浏览器相比于其它浏览器最常见的问题是Js数组最后面的元素多了一个逗号后导致报错，很不幸Ext简直就是这种情况的代言人，更致命的是一个逗号就能够导致整个页面崩溃而且IE调试工具根本找不到这个错误所在，于是才出现了神奇的“二分调试法”。</p>
<p>我个人的建议是，Ext Js的初学者与有经验的开发者都可以尝试使用Sencha Architect去搭建View页面，但最好仅限于View页面，搭建完最初始的结构后就可以将代码Copy到自己的项目中去，然后转为自己编码控制。毕竟Ext的工具性这么强，也不在乎再强一点，Ext的Layout学到飞起来又怎样，对其它形式的Web开发没有任何帮助，然并卵。</p>
<h2 id="config-property-methodevent">Config, Property, Method与Event <a class="header-anchor" href="#config-property-methodevent" aria-hidden="true">&#128279;</a></h2>
<p>Ext的所有类一开始对于这几个概念的理解比较模糊，尤其是Config与Property之间的关系，后来用多了才慢慢开始感觉到其中的区别。</p>
<p>Config是在创建一个Ext类的时候给予的参数，相当于Java中Constructor的参数，有些时候某些config是必要的，有时候又有默认值，每个类所需要以及能配置的config都不太一样，所以在我习惯在使用之前查看一遍文档，顺便吐槽一下，个人觉得在Ext的世界里只有文档和源码是可靠的，经验往往不可靠。Config在配置以后不能通过直接的方式修改，修改必须重新配置该类，使用 <code>Ext.apply</code> 或者 <code>Ext.applyIf</code>，最后再说一遍，不要直接去修改config中的变量，这样往往会导致预想之外的结果。</p>
<p>Property很容易就能联想到成员变量，这里的值在类创建后就会存在，可以被修改（与config的区别），不过在Method中一般能找到与其对应的Getter和Setter方法，所以一般情况下也不会直接去修改Property的值。</p>
<p>Method自然而然就是一个类中的成员方法了，一般是在controller里面使用。Ext的文档中会列举所有该类本身以及继承的方法，在使用任何方法之前都强烈建议先查看文档，可以找到方法接受的参数，行为以及返回类型，在Ext的世界里面游戏规则最重要，一切按部就班才不会出问题。</p>
<p>Event是该类可以触发的事件，并不是所有类都能触发所有类型的事件，比如panel并不能触发Ext的Click事件，所以，在绑定事件之前也有必要查看文档，文档会介绍事件的触发条件以及返回参数，十分有用，千万不要自己去想像。当然这里可以有些许的变通，我们知道Js本身可以对任何DOM节点绑定任何事件，所以当我们需要做一些Ext不打算帮我们做好的事情的时候也并不是没有办法。</p>
<h2 id="html-element-elementcomponent">HTML Element, Element与Component <a class="header-anchor" href="#html-element-elementcomponent" aria-hidden="true">&#128279;</a></h2>
<h3 id="html-element">HTML Element <a class="header-anchor" href="#html-element" aria-hidden="true">&#128279;</a></h3>
<p>HTML Element就是Ext对HTML世界中最普通的DOM节点的称呼，后两位是Ext自己创造的东西，也是其精华所在（精华与糟粕并存）。不过，就算Ext没有了Element与Component，它依然是一个出色的MVC框架。</p>
<h3 id="element">Element <a class="header-anchor" href="#element" aria-hidden="true">&#128279;</a></h3>
<blockquote>
<p>Encapsulates a DOM element, adding simple DOM manipulation facilities, normalizing for browser differences.</p>
</blockquote>
<p>正如其文档所言，Element是Ext对DOM节点进行了一次封装以后产生的对象。该对象的主要目的是为其添加一些简单的DOM操作，以及标准化浏览器之间的差异。构造这个对象的目的与jQuery对DOM封装的目的非常相似，不过对Ext来说，它主要的目的应该还是为更上层的建筑服务。</p>
<h3 id="component">Component <a class="header-anchor" href="#component" aria-hidden="true">&#128279;</a></h3>
<p>Ext的精华与糟粕所在地，吐槽重灾区。</p>
<p>Ext的Component基本上涵盖了Web开发平常会用到的所有控件与功能，极大地简化了Web开发的流程，我们只需要在用的时候创建一个相应的component，Ext就会为我们完成所有事情，其中Grid（表格）控件更是登峰造极，让人不得不服，基本上一个人一般情况下能想到的所有功能都能被一一满足。同时，Ext所创建的十数种Layout类型更是为这些Component提供了强大的定位支持，再也不用担心做不出像样的页面。同时，Ext考虑到开发者可能不一定能在任何情况下满足，也提供了插件与自定义控件的开发方式，至此，component已经超神了。</p>
<p>但是这些强大且丰富的component也带来了或多或少的问题。</p>
<p>表面上看起来强大的东西，它背后一定更强大，所以，Ext真的非常强大，2 MB走起的Js库文件，远远超出了前端所能容忍的极限。搭一个本机环境跑一个debug库，页面刷新一次居然要超过两秒，复杂的页面更是四五秒，可见一斑。所以这东西注定只适合在内网用。</p>
<p>Ext 4.0开始，构建一个component所用到的HTML元素变得非常臃肿，一个普通的panel创建出来少说要七八层结构，这些都是为了高度可定制性做出的妥协，而且我们为了一些布局的需要常常会大量使用容器类 component，其后果就是浏览器不堪重负，渲染效率大打折扣。结合上一点来看更是惨不忍睹。</p>
<p>Ext的component虽说可以自定义，但是实际上一些复杂度高的需求自定义起来会比较困难。首先它必须继承某一个component，因为我们生产中不可能从头开始写，所以需要熟悉原来的component有哪些东西。然后我们在自定义的过程中也不能脱离Ext世界的游戏规则，否则这个新的东西很可能就会与其他已有的component脱节。一种常见的情况就是在操作component的一个element或者HTML element的时候一定要使用Ext提供的方法，否则就会产生预料之外的结果。</p>
<h2 id="-2">版本更替与版权问题 <a class="header-anchor" href="#-2" aria-hidden="true">&#128279;</a></h2>
<p>Ext不是免费工具，商业使用需要购买，即使是个人使用也只能将项目开源才能享有免费版的Ext Js，虽然Js代码都是想用就能用，但是作为公司的话还是要考虑一下这个问题。这个原因也导致了Ext的网络资源非常缺乏，系统的教程非常少，基本上遇到了问题都只能在文档里面打滚。</p>
<p>Ext大版本之间基本不兼容，改动代价也非常高，所以我目前见过的都是选择了一个版本就只能一个版本用到死的情况，另外再补一刀，就算购买了低版本的使用权，再想购买升级版依然需要付费。</p>
<h2 id="-3">总结 <a class="header-anchor" href="#-3" aria-hidden="true">&#128279;</a></h2>
<p>个人不太喜欢使用Ext作为前端框架，虽然是作为非常适合搭建内网系统的技术存在，抛开千遍一律的UI不谈，用过Ext的人应该都有一种被包养的感觉。Ext帮我们做好了所有事情，久而久之我们就会忘记事情原本应该是怎样的，从而走上一条不归路。</p>
]]></description><pubDate>Sat Sep 19 2015 15:36:18 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/ext-usage-summary</link><guid isPermaLink="true">https://blog.wxsm.space/p/ext-usage-summary</guid></item><item><title>博客迁移</title><description><![CDATA[<p>原来的博客太简陋了（虽然现在依然很简陋），一直想改都没有时间，最近在公司培训了三个月的Java也发现自己差不多忘了怎么写C#代码，曾经觉得很顺手的IDE用起来也不习惯了，反正就是改不下去了。鉴于工作以后空闲时间变得捉襟见肘，最终还是放弃了自己动手的想法，直接用了模板博客。虽然没有了一切如己所愿的快感，但毕竟是开源软件，想怎么玩都可以，感觉还是不错的选择。</p>
]]></description><pubDate>Fri Sep 18 2015 21:20:51 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/blog-migration</link><guid isPermaLink="true">https://blog.wxsm.space/p/blog-migration</guid></item><item><title>毕业</title><description><![CDATA[<p>在家上中学的时候并不知道每天可以有家可归是一种怎样的幸福，直到后来再也没有这样的机会。如今人生已走过三分之一，想到以后都不会有机会在自己熟悉的地方长住，心里很不是滋味。有时候会想，如果目前还是自己一个人在生活的话，我就可以回到家这边来找一份不痛不痒的工作，先做个一两年。然而，看到以往的玩伴也渐渐走上正轨，供车供房，同学纷纷开始工作，读研留学，自己也会有些迷惘。尤其羡慕留学的朋友，从此以往告别这片神奇的土地。后悔大学没有好好学习，不然可以争取一些保研的机会，就不用这么早和自己的学生生涯说再（可以再打两年dota）。</p>
<p>三分之一已经过去了，学生时代的一些人和一些事也都应该告一段落了，该奋斗的奋斗，该拼爹的拼爹，都要上路了，也没什么闲暇来和老同学扯淡。一些当年觉得很好的朋友，如今看来也不过如此，以后估计也难再有交集。虽然不知道自己以后还能走多远，但是想到人生过了这么长，没有留下多少美好的记忆，也没有交到很多很好的朋友，满房间的物件，却并没有承载很多过去，觉得自己虚度了很多光阴，却也无法弥补，就总是会觉得很伤感。小学时候的课本笔记等早已不知所踪，只留下一两张泛黄的照片，初中的记忆本该满满却没有珍惜，高中不谈，大学更差，就是dota的一千个日与夜。我以后再也不想通宵玩游戏了，每次看到天亮都十分不安。如果我以后有了小孩，一定会帮她（他）把成长过程中的物件都收拾整理好，待到长大，将会是珍贵的回忆。</p>
<p>说到小孩，如今父母也会开始谈及小孩了，真是措手不及，我不还是个孩子吗，怎么就说到我的孩子了。你们一定是在逗我。</p>
<p>感谢毕业照那天来看我的同学朋友们，当日一别，更不知道何时再见。</p>
<p>大四最后一个学期都是在外居住，并不知道学校里的冷暖。周末回校，也只是洗洗衣服，打打游戏，完全感受不到自己还是一个在校学生。有一次在工作日请假回了学校，中午过了饭点仍自信下楼，才猛然想起原来大家还是要上课的，这会刚下课呢。这几年来我也算是有惊无险的体验了，挂了不少课，还好重修能过，马哲顺利，不然极有可能自信心受到打击从而陷入无尽轮回（需要感谢一下窦庆萍老师）。在知道自己大四上没有挂科，毋须延迟毕业后，心里面真的是很轻松，那么我也算是走过来了。</p>
<p>大学的同学里，我并没有与很多人熟识，也没有交到许多朋友，有几位可能甚至四年来都没有说过一句话，不过也不能完全怪我，我们的专业选得好，完全不用与人交流。谢师宴过后，很多人我仍然是只知道名字，其它一无所知，可能再也不会有机会相见了，然而我并不在乎，因为本来就跟不认识一样。对事不对人，自己的大学生活失败，与同学无关。</p>
<p>工作的地方在唐家湾的软件园，近期也可能会一直住在这一片，在珠海的同学朋友没事可以来找我玩，有活动也可以带上我，有麻烦如果能帮上忙也请找我。从学校到工作地点的一路上都是海岸，大概有二十多公里，每次经过都觉得很舒服，然而不知道台风会不会封路。</p>
<p>有一个正经的女朋友会给自己带来压力与动力，同时也会非常大程度地限制自己的自由，不能想去哪里就去哪里，不能想做什么就做什么，这点让我非常不自在。也许现在到了一个我需要照顾别人的时候，但是我还没有完全准备好。并没有想到大学最后一年能找到女朋友，我也没有准备好。要出外工作，住两三年出租屋，同样没有准备好。 我本来只是一个呆在宿舍每天打dota的大学生，现在生活需要做出这么大的转变，有点不知所措。独生儿习惯了被照顾，现在要开始学会自己打理一切，总有些转不过来。说到底，我就是想呆在家里睡觉。</p>
]]></description><pubDate>Tue Jun 09 2015 01:09:40 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/graduation</link><guid isPermaLink="true">https://blog.wxsm.space/p/graduation</guid></item><item><title>第十一章</title><description><![CDATA[<p>光明历989年六月，时值内森学院新生入学之际，内森学院发生了一起恶性的失窃案，院长室当天被一位窃贼光顾，解封了封存在内的一些机密文件，由于事关重大，光明教会也强势介入了此事，事发当晚经过多方调查，所有的证据都指向了一名新入学的学员，其人当即被教会带走，不久后被处以极刑。</p>
<p>学院派对此事表示沉默，不过学院派高层和光明教会这两个冤家历来都对不上眼也是帝都人尽皆知的事情，此时双方的通力合作也让所有人都大跌眼睛，要知道内森学院历来都是护短的，魔法师是全人类的稀缺资源，他们也有其独特的道德体系，所以纵使是发生了类似的恶劣事件也至多处以流放或是囚禁等处罚。因而此次事件引起了不少相关和不相关人士的关注和谈论。揭开层层面纱，人们惊恐地发现其中夹杂了一个人的名，山德鲁·布拉达卡。</p>
<p>凯瑞一直没有忘记要向梅尔求证一件事，就是在自己第一天来学院到长室报到时，梅尔为什么会在里边。起先他不解的是梅尔既然也是一个新生那为什么会知道他的名字，他发誓自己以前从来不认识这个女孩，而她也跟凯茜没有半点的关系，那时的凯瑞又想当然的把这推到了神奇的魔法上，以梅尔所展现出的魔法水准，要用预言魔法来探测自己的名字那还不是小菜一碟，直到他亲耳听到那个在入学当天被教会带走的新生死去时他才猛然想起了这个更重要的问题，也同样因为那个消息，他又将这个问题埋到了心底，他不敢问，既然种种迹象都表明了梅尔和这次事件脱不了干系，那自己一旦问出来，就算是个傻子也知道后果一定很严重！</p>
<p>但这并不妨碍凯瑞有意地接近梅尔，自从他那天晚上使用了梅尔的那朵怪花，他就别无选择了，自己失去了舌头，不但无法成为法师，甚至连正常人都有的说话能力也没有了，一旦被人发现了这个秘密，这个耻辱更会成为他一生都无法摆脱的梦魇。他明白马修最终决定让自己入学只是为了自己能多一份经历，能不用这么早去面对一些冰冷的现实，为此舅舅付出了很多，他每晚想到舅舅的处境内心总是难以平静。但是，只要有了梅尔那朵花，这一切都会有逆转的可能，随着这些天在学院的学习，他暗暗计划了自己的未来，得到那朵怪花，随后主修药剂学，这一门学科是魔法基础学科中既不需要念咒又能尽可能有所建树的科目，假以时日他即便不能成为一名法师，也至少可以成为一名药剂师。“无论如何我都不能成为一个废人。”这些执念最终都指向了一个人，那朵花的持有者同时是制造者，梅尔。</p>
<p>梅尔是个很神奇的人，透过凯瑞的视角我们可以看到这样一个梅尔，她有着迷人的外表，仅那头漂亮的头发就能吸引很多路人的注意。</p>
<p>她也有着出色的魔法造诣，且不论她的实力有多强，至少她的基础功底连学院的导师都称道过，那是在开学第一周的第九天他们第一次上一门实验课时，任课的导师经过他和梅尔身边时看着梅尔忍不住低声连连赞许，他还知道在那周后梅尔便常被那位导师邀去做实验助手，诚然这归结于梅尔在来到内森之前就有过修习魔法的经历，但学院里的贵族学员众多，又有多少人在入学之前是一张白纸呢？其中一定有凯瑞艾迪森。</p>
<p>凯瑞不知道梅尔是不是贵族，但如果让他猜测的话，那他多半是否定的，梅尔是个博文广识的人，有一天在餐厅他看到梅尔在一个角落对着两位法师学员在说一段异族女剑士的故事，其中还涉及到许多他没听过的大陆历史，故事十分精彩，那个角落很快就聚集起许多人，大家都专注地听着梅尔讲述着，这让凯瑞想起了酒馆里的吟游诗人，那也是擅长讲故事的人，可是梅尔讲的故事却和吟游诗人们的故事完全不同，吟游诗人的故事总是歌颂传奇人物的英勇事迹，每一句话都像诗，而梅尔说的故事就像是军队的战报，或者是像那本厚厚的魔法史。后来那个故事的结尾英勇的异族女剑士最终战败被她的仇家，一位人类领主擒下了，梅尔说如果还想听后面的故事，需要付费，一金币。后来还真的有一位剑士学员付费了。</p>
<p>她没有贵族女性应有的矜持，而且贪财。凯瑞如此想。他想和她成为朋友，为了那朵怪花，甚至凯瑞冥冥感觉到，也许梅尔的神奇还能够帮他重新恢复舌头。只是这段时间以来</p>
<p>“我拒绝。”一张纸条从右手边也就是梅尔的所在传了过来，纸条下方醒目的三个字是梅尔的回复。这张纸条是凯瑞昨天趁着假期没人时放到梅尔桌子下的，虽然一开始因为在入学那天的集会中因为他和梅尔是最后同时离场而被有心的学院导师分到了同一个班的相邻两个桌，但平时他们极少交流，一个是因为性格古怪平时不喜多言，另一个干脆就是个没有舌头的哑巴，有时需要一些自己实在不懂的问题时凯瑞也试过用羽毛笔快速地写在梅尔目力能及的桌面角落随后又用更快的速度擦掉，直到昨天假期。内森魔法部的导师们每个月有三天的统一假期，就是每周的最后一天星期十，跟随导师一起休息的还有他们的学生，但之所以不被认为是学员们的假日是因为在这三天学员们还是不被允许外出，一旦离开学院，按例逐出。那是凯瑞最期待的时刻，他会花一整天的时间去拜访心，和她共进晚餐，然后回到星期一，安静地等待第十日。昨天是他首次碰壁，心的管家告诉他凯茜小姐外出了，并且给他准备了一些点心和书籍。凯瑞在那里呆了一会就悄悄到教室在梅尔的桌子里留下了这张纸条，他在上边委婉地表示希望能和梅尔成为朋友。我拒绝，这是梅尔给他的回复。</p>
<p>他有些气馁，不过也在凯瑞的意料之中，他知道只要附带上那根法杖，结果多半就会不一样。有一天他曾将那根橡木短杖带来了教室让梅尔把玩了一会儿，梅尔很喜欢那根法杖，他甚至能隐约感觉到她心里正谋划着怎么从自己这里把它夺过去，所以之后凯瑞每天都把它锁在柜子里，只有回到宿舍时才会拿出来端详。他也知道自己有很长一段时间，或许是永远都用不上它，但他却不能失去它，决不能。</p>
<p>于是今天的凯瑞还是和平时一样，平时的他每天都认真地听导师的讲解，偶尔一头雾水地将所有的话都记进魔法书中，也会习惯性地偶尔往旁边看一眼，一旁的红发女孩几乎一整天都抱着她自己那本黑色大书在看，倒是从未见她往那本书上写过什么东西，除了开学的那一天在院长室里看到的那一幕，但那对凯瑞来说却是他自己都不想知道的秘密。</p>
<p>平时他会跟着梅尔一起去餐厅用餐。每一个法师都会有一套自己的饮食规律，他们的时间很贵，每天需要花时间冥想，花时间准备法术，更要花时间休息，所以在上第一课时导师就教他们尽快养成适合自己的饮食规律，生活区有一些专为魔法部设立的自助餐厅是整日开放的，除了晚上的一餐，凯瑞白天有两餐都是跟着梅尔一起的，他不知道自己的饮食该如何安排才好，只是相信梅尔的判断。至于晚上，他则会在自己的屋子里呆一整晚。在他的楼上还住着他一会并不太讨厌的舍友，他向凯瑞介绍自己叫做雷恩，这是他们两人的唯一一次对话，当然，雷恩也是一个法师学员。</p>
<p>魔法师这个职业真的和人们所传闻的那样冷漠古怪，凯瑞对此感慨颇深，随着他见到和接触的法师越来越多，他也越发的肯定这点，比如卓林，梅尔，他的舍友雷恩，还有他几魔法基础课的导师，他们都表里如一地让旁人感到古怪和不安，虽然这些人都对他有过或多或少的帮助，但就奇怪在明明他们都对凯瑞有过恩惠，凯瑞仍然很难在短时间内对他们产生好感，在他内心深处更多的是敬畏，凯瑞才渐渐发现他其实并不像当初自己认为地那样喜欢法师，以往他听到关于法师的故事和传闻他总是充满憧憬，即便是那广为流传的恶劣性格他也觉得那是施法者应有的姿态，而今这些他曾认为理所当然的种种都让他吃尽苦头，诚惶诚恐。</p>
<p>或许也归结于魔法师的无常，原本因为纸条被拒绝而一筹莫展的凯瑞却遇到了一个神奇的转折。傍晚时分，他独自从教学室走回宿舍的路上，很意外地看到了梅尔，她此时和凯瑞一样抱着几本厚重的魔法书正站在实验楼的门口，脚边还放着一个盖着黑布的鸟笼子，大概是刚从实验楼出来，遇到了什么麻烦。不管她是不是遇到了麻烦，凯瑞还是很快走了过去。</p>
<p>“能帮我一个忙吗？”梅尔似乎对凯瑞的到来胸有成竹，她站在门边以逸待劳地等到凯瑞走过来后轻飘飘地问了一句。随后将自己的魔法书交到了凯瑞的怀里，自己提起了脚边那个需要两只手才能稳稳提起的笼子。并对凯瑞说了声，“跟我来。”凯瑞对此没有异议，按照梅尔的要求跟着她一路帮忙将魔法书送到了梅尔的宿舍门口。随后他收到了自己的报酬——梅尔邀他共进晚餐。假如这也算报酬的话。</p>
<p>这甚至和白天的两次用餐都没有区别，对凯瑞来讲唯一的区别就是比平时多了那么一餐。他没有什么进食的欲望，只是选了些简单的吃食，一边吃一边等着梅尔对他说些什么。他时不时地会看向梅尔的手，他还记得那朵怪花最后是从她的左手食指上收回去的。只可惜梅尔并不知道凯瑞在想什么，她从头到尾都很安静地在用餐，和平时也为什么不同。</p>
<p>深夜，凯瑞跟着梅尔一前一后走在返回魔法部的路上。从餐厅里出来时他才发现过去了这么久，他心中略微有些失望，餐厅里的人很少，他原以为梅尔这次还会将那朵怪花拿出来给他试试的，自打那次借助那怪花尝试了说话之后，他对于沉默渐渐开始感到厌恶，对表达的欲望也越来越强，只是因为梅尔对心送的那柄短杖的觊觎，他一直都不敢再主动提那朵怪花的事。只能等以后和梅尔混熟之后再旁敲侧击。他努力搜寻着自己除了牺牲那柄法杖还能有什么别的方式对梅尔示好，此时两人差不多走到了生活区和魔法部宿舍的交界处，这是一条如同城墙一样的桥式走廊，走廊下方的整个墙体也正好作为内森的院墙，走廊上没有魔法灯，只有几个早已燃尽的火把，所以到了晚上能见度很低，在走到这里时凯瑞停住思考集中精力看路时忽然发现，原本走在他前面的梅尔不见了。</p>
<p>这让他感到奇怪，虽然一路上他都在想事情，但他也清楚地记得梅尔是一直走在他身前的。他在原地转身四处搜寻了一下，并没有看到一个人影，估摸着梅尔又用了他不知道的法术离开了。他叹了口气转过身朝学院外忘了一眼，从这里老出去正好是费伦城东街，凯瑞前不久还在那里当了十几天铁匠，那里还曾有一个让他十分牵挂的人，如果不是这个人，他也许这辈子都会只是一个铁匠。铁匠凯瑞以后就是药师凯瑞了，凯瑞如此想着又下意识向前几步走到了墙边。突然间黑夜中就有东西从墙外朝他飞了过来，凯瑞完全来不及反映就感到自己的脖子被一根绳子套住了，并且一股巨力传来将他强行从走廊拉出了墙外直飞到了离墙面不远的一棵树上，这阵巨变让他十分惊慌，他张嘴几乎就要叫出来，无奈脖子上的绳子迅速收紧将他的叫声扼回了咽喉，脖子被勒紧的窒息感和被拉扯过后的剧痛令他几乎要昏过去。直到几息之后他才借着外边的月光看到了面前站着脸色冰冷的梅尔，此刻她正双手抓着那条绳子用力的拧动着。</p>
<p>“你是在泡我吗？欧格里信徒!”梅尔低声狠厉地问向他。</p>
]]></description><pubDate>Sat Mar 14 2015 19:50:41 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/paladitch-chapter-11</link><guid isPermaLink="true">https://blog.wxsm.space/p/paladitch-chapter-11</guid></item><item><title>第十章 · 绕指魔花</title><description><![CDATA[<p>她为什么可以说话呢？难道她解除了沃昆院长的法术？又或者是院长的法术对她完全没有影响？凯瑞想到这里心跳猛然加速，感到很不可思议，因为他接下来的念头是，这个红发的假冒学姐也许在奥术上的造诣已经超过了院长……因为即使是魔法菜鸟也知道，一位施法者能够凭空免疫另一位法师对其使用的法术，那足以说明两者之间存在着巨大的实力差距，而如果梅尔是在已经受到法术影响之后自行解除法术效果的，那更不可思议，众所周知，法师几乎所有的施法行为都离不开念咒，凯瑞更是对此深信不疑，如果一个法师能够不用念咒文就能施法，那简直就是神话。</p>
<p>“这次是真的直了”梅尔轻笑着说，“你一定在想，我为什么没有受到台上那个老鬼的法术影响，对吗？”</p>
<p>凯瑞重重地点了点头。却发现梅尔说完这句话脸色却变了，只见红发女孩笑意全无，转过头去一脸凝重地望着台上正洋洋洒脱的老人，“我也一样被这个术控制了，这是一个复合法术，防护学派的终极奥义同时也是沃昆先生的招牌绝学，魔邓肯裂解术……以及”说到这里又转过头来看着凯瑞“一个小把戏，我能说出话，你能听到我说话，你可以当作这个小把戏对我们没有用。”</p>
<p>凯瑞若有所思，就在今天他已经听过了梅尔所说的各个魔法学派的介绍，有很多内容其实他已经印象模糊了，但有一些细节却仍记得，其中一个就是防护学派的这个终极法术，魔邓肯裂解术，解除一个目标区域的一切魔法效果。想到这里他看向了梅尔头上的羽毛笔，想必刚才就是因为裂解术的效果才让梅尔显形的，他记得在那之前梅尔一直通过某种方式将自己隐藏了起来。</p>
<p>“你试试这个”梅尔忽然从她的袍子口袋里拿出了一朵向花一样的东西，不过那花有着长长的根茎，仿佛一条尾巴一样，梅尔将那朵怪花递到了凯瑞的手边还未等凯瑞有所反映，花的根茎就仿佛蛇一样迅速缠上了凯瑞的手腕。</p>
<p>这阵突发的变故让凯瑞心里一惊，他缩了一下被花藤缠绕的右手，“你干什么？”一阵声音忽的发出来。听到这个声音，凯瑞更加震惊，仿佛是这十几天以来的所有被压抑的心跳都在这一刻恢复了，他瞪大了双眼看着梅尔，一句语气十分惊讶的话也正好从他手边传来，“你怎么做到的？”</p>
<p>梅尔似乎也没有料到凯瑞反映会这么激烈，她耸耸肩笑道：“怎么这么严肃呢？只是个小把戏而已，这不算破了欧格里的戒律。”她自然还记得凯瑞是智慧之神的信徒。</p>
<p>“这个是什么？”凯瑞左手指着右手上缠着的怪花问道。</p>
<p>“这个，应该算是魔芋的变种植物吧，经过了一些……特别的处理。”梅尔淡淡回答，“这种植物的根茎对动物的神经十分敏感，花朵里有一个装置，可以将从根部感应到的信息中的语言筛选出来，然后说出来。它是一种刑具。”说到这梅尔又笑了笑。</p>
<p>“刑具？”</p>
<p>“是，只要灵敏度再高一点，被缠住的人内心的想法它都会捕捉到，不过那个人也很快会变成白痴。”梅尔吃吃地笑了。</p>
<p>“它……能够用来念咒吗？”凯瑞仍死死地注视着右手上的怪花。</p>
<p>“施法媒介吗？不能。”梅尔隐去笑意否定了，她对于凯瑞丝毫没把她刚才那句话放在心里感到很诧异，这个少年虽然看似有点愣，但也绝不傻……</p>
<p>“那……它是用魔法制作的吧？”凯瑞终于移开了视线，看向梅尔问道。</p>
<p>“对。”</p>
<p>“噢？但是，你刚才说过，我们都受到了魔邓肯裂解术的影响，那么除了魔法效果，这些魔法物品也应该会被解除效果的吧？”</p>
<p>听到凯瑞的话，梅尔低下头莞尔一笑，“不愧是欧格里的信徒，你果真是很有魔法天赋啊。你的箱子里装的什么？”她忽的避开话题转而指着凯瑞抱着的古朴木盒问道。</p>
<p>“是一根短杖，是……”说到一半凯瑞忽然愣住了，如果按照刚才自己说的，魔邓肯裂解术会同时破坏他们的魔法物品，那这根橡木法杖岂非也被破坏了？又或者，沃昆院长使用的裂解术并不会破坏他们的魔法物品。他顿时了然，梅尔是想以此来说明这件事。</p>
<p>“是一根法杖。这个可以给我吗？……我是说，我向你买它。”凯瑞犹豫了一会儿向梅尔问道。</p>
<p>“你喜欢？”梅尔笑着问他。</p>
<p>“是，我很喜欢。”我很需要！凯瑞心里默念着。</p>
<p>“我不卖。”梅尔笑过之后淡淡地回答。“做这个东西花了我不少精力，我宁可换些有用的东西，如果你真的这么喜欢的话……”说到一半她眼睛瞄向了那个装着法杖的盒子，意思不言而喻。</p>
<p>凯瑞也注意到了这点，他抱紧了盒子想也没想就否决了。</p>
<p>梅尔继续说道：“你尽管考虑，虽然只是个小把戏，但是它材料珍贵，工艺也是秘传，我想在内森学院即便是有第二个人能够做出来，也不会这么便宜给你了。”</p>
<p>“你精通炼金术？”凯瑞忍不住问道。</p>
<p>“不，只是略懂，每个女人都有修习变化学派的天赋。我只是学了一点皮毛。</p>
<p>“法杖我不能给你……”他欲言又止“很抱歉。”</p>
<p>“前面是怎么回事？”凯瑞似乎急着转移自己的注意力，不经意间往前看发现有几个新生抱着魔法书正起身向前台走去，他这才发现自己方才一直都没有注意到院长在说什么。</p>
<p>“有人也发现了这个把戏。”红发女子淡淡地说，“看看你的魔法书吧，你应该还没看过对吗？”</p>
<p>“额……是的”凯瑞点点头拿出了垫在盒子下边的一本魔法书，书本很厚，纯黑色的封面，封面上凸出了几个字依稀可见魔法书三个字。翻来第一页却发现一片空白，随即又翻到了第二页第三页……仍旧一个字也没有。</p>
<p>“这本书……”凯瑞看向梅尔希望能够解惑。</p>
<p>“你还记得你是什么时候拿到这本书的吗？”</p>
<p>凯瑞想了想，“……不记得”他发现自己真的不记得了，努力去回忆脑海里也只有一片空白。</p>
<p>“那你还记得你是什么时候来到这里的吗？”梅尔又问道。</p>
<p>“我不记得！”这次凯瑞很快就想到，他看着梅尔，神色已经渐渐不安。</p>
<p>梅尔对他的反应早有预料，“这就是沃昆的把戏，其实他根本就没有施放领域静默，从一开始我们就已经被施法了，那是一个幻术，叫梦境缠绕。所以你才根本就没有去想过你从何处来，因为做梦的人根本不会知道自己的梦境是什么时候从哪里开始的。”</p>
<p>“你是说，我们现在是在做梦？”</p>
<p>“既可以说是，也可以说不是，我们并不在自己的梦境里，而是被缠绕在施法者用法术制造的梦境里。也就是这个会场。按照那位叫沃昆的院长所说，我想这个梦境会持续到午夜，但总有一些人会提前发现并去揭发，或许会因此得到一笔奖励呢。”</p>
<p>“既然这样，为什么你没有去呢？我想你一定是最早发现真相的那个人吧？”凯瑞看着红发女子由衷问道。</p>
<p>“我不是。”梅尔沉下脸来，“有人比我先发现了真相，虽然我不知道是谁。我不去是因为魔邓肯裂解术，我们虽然在梦境里，但这个术却是货真价实的，老实说，这并不是个善意的法术，对于任何法师来说都代表了至高的敌意和威胁，我现在几乎没有任何力量，如果走上前台，等待我的也许不会是奖励。”</p>
<p>凯瑞听到此处微微张开了嘴，“那你现在是打算一直呆在这儿？”说着他又看了看台上，那几个新生在沃昆院长的示意下通过一个小门离开了会场。</p>
<p>“没错，所以如果你现在打算对我做些什么的话”红发女子转过头来看着他，嘴角微微勾起一抹笑容“那你就要赶快了。”</p>
<p>“我不会的”凯瑞望了她一眼后低下头去，“谢谢你告诉我这些。”</p>
<p>“不客气，再有一会儿这些消息就免费了。”言罢梅尔左手食指轻轻搭在了缠在凯瑞右手的怪花上，那花仿佛受到某种吸引，尾巴渐渐地从凯瑞的手腕上脱离，慢慢地缠向了梅尔的食指。</p>
<p>不过凯瑞并没有再听到花朵发出声音，他心里充满了不舍，这久违的，说话的感觉。他一定要想个办法得到那朵怪花，但是他也不愿意失去心送给他的东西，他不愿意，他更不敢，这是心今天刚刚送给他的法杖，他若立刻就拿去和别人换东西……他不由想起了今天那个叫做安莉萨的女孩看他的眼神，那种感觉，真是难受地可怕。可是自己该怎么办？</p>
]]></description><pubDate>Wed Mar 11 2015 19:49:10 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/paladitch-chapter-10</link><guid isPermaLink="true">https://blog.wxsm.space/p/paladitch-chapter-10</guid></item><item><title>2014-11-11</title><description><![CDATA[<div>
  之前写过一篇很长的关于异形的东西，不知道为什么发不出来。可能有关键字被和谐了，但我又找不到，后来草稿不知道为什么也没有了，明明保存了的。没有了我也不想再重新写一遍了。 说一下最近看过的一些有点意思的电影。
</div>
<div>
   
</div>
<div>
  先说印象比较深的，Atonement（中文名《赎罪》），其实这电影发展过程一般吧，主要的亮点是在结局，当然我也不能说太多，否则剧透了就很没意思了。当时我是很惊讶的，一部电影成功真的很靠原著小说以及剧本。这是一个悲剧，西方，二战时期，题材为爱情。另外一个亮点在于打字机的使用，作为配音是很独特的存在，当时也刚好ios有一个打字机应用（好像是靠汤姆汉克斯宣传的），所以印象比较深刻。
</div>
<div>
   
</div>
<div>
  然后是李安的《色戒》，这部电影出了那么久一直没有看， 可能主要是被大多数人对它的关注点误导了，觉得看这种电影还不如去看爱情动作片。后来发现其实色戒是一部非常优秀的电影吧，只能说非常优秀。也是悲剧，中国，抗战时期，题材为爱情，谍战。其实我推荐家里人看这部电影的，比如爸妈，因为好像大家都比较喜欢看谍战剧，然而关于谍战的电影很少，也少有优秀的作品。色戒的背景内容庞大，但整部电影的视角一直限制得很小，剧情紧凑，毫不拖沓，主题突出，以小窥大，得益于李安深厚的功力。
</div>
<div>
   
</div>
<div>
  后来有一段时间比较无聊，看完了《异形》系列。由于刚才说的原因，我都没兴趣多写了。反正我感触还是很深的，但电影其实拍的一般般，可能是年代的原因现在看来没什么触动。它的题材很好，期待普罗米修斯的续集。
</div>
<div>
   
</div>
<div>
  说到科幻片，最近也看过一些科幻片，主要是因为之前看了阿汤哥的《明日边缘》，对科幻片的热情又高涨了。明日边缘真的是一部非常，非常，非常优秀的科幻片，我甚至觉得是我看过的最优秀的科幻片，可能有些夸张了，但就像当年看完盗梦空间以后难以抑制自己激动的心情，一定要给这部电影打满分的感觉，明日边缘也是这样的一部电影。相比于其它的外星人入侵地球的电影，明日边缘对于外星人的设想非常有意思，以至于电影也陷入了一种很特别的节奏。如果仔细想想的话，它的看似狗血的结局也是非常值得推敲的。这部电影的题材是科幻，外星人，四维空间，拯救地球。美国，未来。
</div>
<div>
   
</div>
<div>
  然后还看了邓肯琼斯导演的《月球》，这部电影相比明日边缘就比较文艺了，但同样有比较特别的剧情，看似科幻片，我觉得其实是一个关于人类道德的电影。另外比较特别的一点是，这是一部独角戏（参考《我是传奇》），一般来说这种电影逼格都比较高，这部电影也是如此啦。然后它除了剧情设定以外并没有其它的比较大的亮点，所以总体感觉一般吧。美国，未来，题材为科幻，克隆。
</div>
<div>
   
</div>
<div>
  另外看了《机器纪元》 以后，觉得最近的科幻片都比较探讨人性啊，都不是在往科幻片应有的路子在走。这部片子说的东西还是挺有意思的，不过剧本感觉缺少冲击力，就是没什么能让人感到眼前一亮的东西，比较平淡的电影。之前上人工智能课的时候听周密说，“人类需要完成的最后一个发明就是智能机器人”，这部电影说的就是这个啦！为了让智能机器人不成为人类的最后一个发明，人类为其设定了两个原则，一是机器人不能伤害任何生物，二是机器人不能维修自己。但是智能机器人明明比人类要智能得多，又有什么技术制定的原则能限制得了智能机器人呢。美国，未来，题材为科幻，机器人。
</div>
]]></description><pubDate>Tue Nov 11 2014 20:44:32 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/2014-11-11</link><guid isPermaLink="true">https://blog.wxsm.space/p/2014-11-11</guid></item><item><title>临近端午</title><description><![CDATA[<p>很久没有回过家，也没有关心过家里的情况了。今天和妈妈说了几句话，得知最近有发烧生病，虽然说已经好了，但还是觉得不知道怎么的。五十多岁了，一个人在广州上班，没亲没戚的，生了病也没哪个照顾，也不跟我说。婆婆去世以后我就应该要照顾我妈了，去年在赣州大姨也跟我说过，可惜还没有毕业，分身乏术。唉，真是忧伤。真希望你退休了吧，别干了。</p>
<p>天气变得很热很闷，情绪也变得特别容易坏，很可能因为一些琐碎事情发脾气，像今天早上，本来不应该发生这样的事的，我应该更关心你一些，而不是独自生闷气。现在想来确实后悔，不过微信是真的没有必要了。</p>
<p>这学期过的很快，感觉是大学这么久以来最快的了吧，已经快十四周了，又要结束了。过得快的原因大概有几方面，一直很忙，基本没停过，到现在也是很多事情在做，都接近尾声但又没有结束，所以有时候会觉得很多事情要做但又不知道要做什么。遗憾的是还没有找到实习，暑假仍没有着落。这学期和web有关的东西做的比较多，不过我不太希望这是最终的方向。</p>
<p>找了一个女朋友，很喜欢，希望可以有多远走多远。</p>
]]></description><pubDate>Thu May 29 2014 20:46:52 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/nearing-the-duan-wu</link><guid isPermaLink="true">https://blog.wxsm.space/p/nearing-the-duan-wu</guid></item><item><title>第九章 · 集会</title><description><![CDATA[<p>夜晚降临时，整个内森都是灰蒙蒙的，纵使校道两旁有林立的魔法灯散发着荧光也只是让这个地方看起来更加阴森。此时校道上没有多少行人，学院中央的大礼堂内，这一届魔法部的新生正在进行首次集会。</p>
<p>法师的存在在整个大陆的历史上已经十分久远，然时至今日，人们还是对施法者的诸多怪癖行径感到难以理解。诸如此类总是在夜晚举行重大会议、活动的习惯，即便是已经成为学员的贵族们也难免有所非议，而当学院副院长沃昆开门见山地宣告这次集会将持续到午夜时，纵使是受过最正统贵族礼仪培养的学员也不禁发出了哀嚎。沃昆院长看起来是个很羞涩的老人，相比起学员其他导师们包括一开始向新生们致辞的贝利院长那千篇一律的严肃死板的表情，这位老人显得十分生动。在宣布了那条令人发指的消息后，他那张布满皱纹的老脸很不好意思般地窃笑不已。</p>
<p>凯瑞觉得这位老院长着实有趣。不同于其他的新生，他对于这场要持续到深夜的集会并没有什么感觉，他不像那些贵族们有着对光明偏执的信仰情结，也并不像其他学员那样从进入学院起就为各种各样的手续忙东忙西的。他来到内森时时间久已经很晚了，原本需要自己去处理的诸多事项凯茜都帮忙一一解决了。想到这里凯瑞就没来由的感到高兴，手里一遍一遍地摩挲着怀里装着法杖的木盒子，审视着四周喧闹的学员们心里暗暗想道，他们应该还没来得及吃晚餐。不过像这样闹下去，会不会出什么麻烦？沃昆院长会不会一气之下施放一个威力巨大的魔法把在座的人都轰成渣渣？当然这样的担忧只是一瞬而逝。不论如何，和别人穿着一样的袍子融入到这个喧哗的群体中让凯瑞十分安心，十分享受，他还感受到了一股久违的愉悦感。</p>
<p>这个礼堂的规模非常大，乍看之下仿佛来多少人都容纳得下。不过让人奇怪的是，新生的人数也并不多，只有两百多人，却好像刚好把这里给塞满了似的。魔法！凯瑞脑子里是这么想的，在他心里，魔法便是所有奇迹与玄妙的集合。</p>
<p>学员及部分导师所坐的观众席呈扇形排开，从里到外是由低到高分布，而他们面向的中心则是主席台，那是让人仰望的地方，一张演讲桌神奇地悬浮在空中，那位羞涩的沃昆院长此刻就站在上面审视着自己的学生，看起来台下的动静并没有让他如何的不愉快。但随后的事情表明，老院长对于年轻人的喧闹还是有所不满，他或许一直在无声地抗议，然后就是，整个礼堂忽然瞬间变得无声了。</p>
<p>绝大部分学员都是一副茫然的样子，他们长大了嘴，也瞪大了眼睛，他们发现自己说不出话来了，亦或是都听不到任何声音了。凯瑞一开始也并没从贵族们的反应看出什么状况，但是他却是在第一时间察觉到了沃昆院长的施法动作。在经历了那次盗贼事件之后，他对于法师的施法动作就有了深入骨髓的敏感。那个羞涩的老者在环视了一眼下面的学员后就缓缓伸出了右手，嘴里也同时念动着咒文，凯瑞就看到一圈难以察觉的透明波纹从他手里展开，并迅速扩散开来。然后，场上的喧哗便戛然而止，一个又一个学员纷纷瞠目结舌，相互望着周围的人惊惶不已。</p>
<p>就目前来看，这个结果凯瑞还是可以接受的，好歹自己也并没有和众人一起被老院长轰成渣渣。但他还是感到有些不舒服，原本他隐藏在嘈杂的人群中享受着寂寞，那些只顾着谈论和抗议的人是绝不会把目光投向他的，这是多么享受的感觉。而现在礼堂忽然被变成了无声地世界，一道道目光就开始在四处交错，每一次发现自己被人注视，他都觉得后心空荡荡的有股凉意。很是令人讨厌！不过同样感到不舒服的也不止他一个，偌大的环境中当然也有着和凯瑞一样藏在人群里享受寂寞的人。</p>
<p>那是在沃昆院长施法后凯瑞才忽然发现了此人，几乎就坐在自己身旁，两人之间也就隔了一条小小的过道。之前他审视过四周，在看向那里时只看到一个普普通通的裹着宽大的法袍还带着兜帽的人，在这个两百多个法师或者说准法师齐聚的场所，这样的人基本是让人看一眼过后就忘了，并且不会再想着去看第二眼，凯瑞当然是看了一眼后就忘掉了。然后在老院长施法过后，这人才如一个原本隐形的幽灵一样渐渐显现在他身边。一个有着一头醒目红发的女孩，梅尔。</p>
<p>或许是察觉到了凯瑞的目光，梅尔也转过头来正好与凯瑞对视。这位少女比之刚才那副笼罩在袍子里的印象完全不同了，原本将她遮的严严实实的灰袍就好像突然消失了，这时的她身着合身且稍显紧致的魔法袍，将她的身材体现的淋漓尽致，纤细、娇小而又不失圆润，一头美丽的红发色泽艳丽动人，上面还别着一支黑色羽毛，这应该是她原本用法术藏在头发里的鹅毛笔，现在因为某种原因显现了出来，那又恰好成了一件独特而精美的头饰。在头发下那张漂亮的脸则不同于那些油画里的典雅美人，她的面容有着类似精灵或海妖一样的异域气质，精致而又充满了灵性，细长的双眸也如新月般大而明亮。她的忽然出现自然是吸引了周围不少目光。</p>
<p>凯瑞却看到美丽少女的脸色有些阴沉，看起来她和自己一样对别人的注视有些反感。但是梅尔却没有要立即终止这次对视的意思，凯瑞也没有，相比起其他陌生人的注视，凯瑞到觉得红发少女的眼光不会让自己感到异样，毕竟在不久前这个女子还从自己这儿喝去了一金币的龙舌兰。虽然一开始那件事让凯瑞尴尬得想死，但他心里还是不由地对这位学姐有几分敬重之心，纯熟的技艺，渊博的知识以及对奥术的深刻理解，当然还有美丽而迷人的外表，这可称得上是学姐的典范。好吧！现在发现了她其实和自己一样是一个新生。“妈的！”凯瑞在心里狠狠地骂了一句，他很讨厌被人骗，想到自己一开始被这个女子哄得跟呆子似的心里是十分忿恨，原本的好印象自然是瞬间归零，看向她的眼神也有些不善。</p>
<p>对于凯瑞的表现梅尔却仿佛没有放在心上，她看到凯瑞时神色也很平淡，应该早已知晓他在这里。对视不到片刻却露出了羞涩的笑容，其实这和主席台上那位老人隐隐相似，就像是面对着一个在她手上吃了闷亏而又赌气的小孩子，当然这要相当有心机的人才能察觉到。那些凯瑞都看不到，但是心里仍是有着难以自制的忿恨和不快。好在这样的气氛也没有维持多久，老院长观察了一下学员们的反映之后就又开始讲话了。本来有气无力的声音在主席台的扩音设施和学员们的沉默这双重助力下竟也显得十分洪亮。</p>
<p>“女士们，先生们。请不要惊慌，这只是这次集会游戏一个小小的环节而已。我在其中加入了一点有趣的成分，一个小小的法术。”</p>
<p>老人说着又开始了羞涩的窃笑。</p>
<p>“领域静默，你们中想必有些家学渊源的人会对这个法术有所了解，正如你们现在所感受的，你们说不出话，也听不到其他的声音。我相信等诸位到了我这个年纪，一定会喜欢这个法术的。”</p>
<p>“十分惭愧需要用这样的方式来进行这次对话。我想我一定能取得大家的谅解，嘿嘿，若是你们没有受到法术的限制，一定会在下边咒骂我这个老头子。那是你们不明白，其实魔法和其他所有领域都是一样，老人欺负新人是理所应当的事情。新人，新生，这个词是多么富有生命力，就像在座的各位。虽然我用了如此恶作剧的方式和你们开了一个玩笑，但也无法掩盖我对你们的热情与喜爱，因为你们是如此的有朝气！你们都有着无限的可能。诸位，欢迎来到魔法的世界！”话音一落，台下众人都下意识地鼓起掌来，不过在拍了第一下手发现仍是没有声音后便纷纷作罢，继续专注地听着沃昆院长的致辞，先前的不快大多已抛之脑后。</p>
<p>而主席台上，一直观察着众人变化的老人则是经历了一个起伏的表情变化，对比先前的热情与高兴，在看到学员们的神情时却有了一闪而逝的不满。</p>
<p>“我很担忧，各位同学们，我希望我的法术不要使你们变得循规蹈矩。或许你们对于魔法仍怀着敬仰，就像对神灵的敬仰，但魔法不是神明的力量。我希望你们富有活力，将你们内心深处的想法寓于你们对法术的认识当中。正如在你们从来只念诵优雅诗文的口里吐出脏话，一个小小的变化，但却是多奇妙的变化。”说到此处，台下的学员们纷纷不约而同地窃笑起来。</p>
<p>老院长最后说道“魔法就是从无数种变化开始的，请牢记这些话，还有我对各位的期望。我个人希望你们在经过一段时间后不要变得像老贝利那样顽固死板，没有生气。”最后那句自然也是对所有人说的，老贝利便是内森的主院长，在沃昆之前也向新生们做过简单的致辞，那位神情严肃、脸色惨白的老人环视一眼众人后只说了两句话就离开了。“遵守内森的规矩。你们很快就知道是哪些了。”新生们都从贝利院长的这番话里感受到了浓浓的威胁，那真是一个让人看了就心生惧意的老人。是以对沃昆院长的最后一句话都深表认同。并且包括凯瑞在内的学员们都对这位老人充满了好感，他是一个如此慈爱而热情的老者，循循善诱，诲人不倦，还有这样在公众场合非议自己上司的行为，那是多么让人喜闻乐见的事。于是众人都怀着愉快的心情听着沃昆院长接下来的话，他得先为他的老伙计善后，也就是向大家阐述内森学院的校规。</p>
<p>凯瑞一直都认真听着，期间他也时不时会轻轻转过头去悄悄看上一眼，在结束那次对视后，梅尔便没再关注他，只是自顾坐在那儿抱着学院派发的魔法书低头沉思。他也注意到不止自己一个人在偷偷窥视这个女孩。诚然，梅尔是一个漂亮的女孩，尤其是那让人惊艳的红发总让人不由自主地想要多看几眼。但自己只是对她充满了好奇，凯瑞是这么想的。他本来还对这个红发女孩有些讨厌，就是在刚刚的对视时，那种区别于那些对他不怀好意的陌生人的讨厌，他无法单独形容。后来却在听到沃昆院长说的“老人欺负新人是理所应当的事”时，他心里便有些茫然，若有所思，也若有所失。或许原本那点谈不上恶感的讨厌也在悄然转变。</p>
<p>但这一切梅尔可会知晓？就在凯瑞又偷偷望向梅尔，看着她对院长的讲话不屑一顾的样子而心生感慨时，红发女孩却忽然幽幽地转过头来正好和他对视。凯瑞心里吓了一跳，毕竟偷偷看人家被抓了个现行，而他心里也对这个女孩有了些改观，他再没有上次与梅尔对视那样的底气，一时间只觉得尴尬不已，就要转过身去。梅尔这次却没有作罢的意思，看着凯瑞的窘迫她嘴角露出了一抹动人的浅笑，带着揶揄的语气戏谑地说道：“眼睛都直了呀。”</p>
<p>然后，凯瑞眼睛真的就直了，他满脸震惊，脑袋机械地又转向了梅尔，陷入呆滞。她说话了。。。她竟然能够说话！</p>
]]></description><pubDate>Mon Mar 03 2014 19:47:32 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/paladitch-chapter-9</link><guid isPermaLink="true">https://blog.wxsm.space/p/paladitch-chapter-9</guid></item><item><title>第八章 · 相逢</title><description><![CDATA[<p>出门买东西或者是吃东西之类，完事后发现自己没带够钱，这样的事情放到现在的内森已并不常见，早在内森里的生活区建立之时，内森学院就已经为学院里的成员推出了用于便捷付费的魔晶秘钥，仿各大商会流通的魔晶卡开发而成。持有者只要事先在办事处充入足够数额的金钱，就能把它当钱袋使，在生活区内的所有消费都只要用它轻轻一插，便一笔勾销。其做工也比魔晶卡更小巧便捷，深受那些贵族学员们的喜爱。不过这东西凯瑞却没有，不是因为他不是贵族，而是他不愿意为之支付20银币的制卡费。虽然那已经是打过折的学院内部价。</p>
<p>先前那位老店长在察觉到凯瑞有难处后便向他表示可以先将魔钥用来抵押，等回去取了钱来付账便是。但面对这份好意凯瑞也只是一直沉默这没有任何表示，一来他根本就没有魔晶秘钥，二来即便是有了，那又要到哪儿去取那一金币的钱呐？他唯一能想到的就是舅舅马修·埃迪森那儿，但是他做不到。他好不容易才下定决心从铁匠铺出来，他害怕自己只要再回去就没有出来的勇气了。这十分不妥。</p>
<p>更为不妥的是，这一切凯瑞都无法用语言说出来。他只是这样干站着发呆，老店长见他这幅模样也是哭笑不得，但老人仍是十分友善。</p>
<p>“如果你还没有魔钥的话，那就先将你的学员凭证留在这儿吧！这样也可以。不过你毕竟是个新面孔，时不时得用到你的凭证。如果被发现落在了我这儿，你一定会有麻烦。”言罢便一直望着凯瑞，满脸无奈。</p>
<p>“凯瑞！”</p>
<p>门外忽然进来两个女子。一个是穿着和凯瑞同样法袍身材娇小的金发女孩，而另一人则身材修长高挑，笔挺如剑，穿着一身素白劲装，黑发如缎的女武士，赫然就是那被叫做心小姐的女人凯茜。</p>
<p>仿佛是找了很久似的，凯茜的声音有些惊喜，远远在屋外她就发现了凯瑞在这里，只是在进来之后屋内的气氛和老店长的话却让两人都一怔。显然从那金发少女怪异的神色就说明屋内的情况她已知道的八九不离十了。与她相比，凯茜则很淡然，仿佛对屋内的事并不知情。两步走到了老店长的身前略表歉意地说道“拉布先手，他是我的弟弟。今天才入学。原谅我刚才有些忙，还没安顿好他，给您添麻烦了。”</p>
<p>言罢她又从衣服口袋里掏出了两枚亮银色的小钥匙。</p>
<p>“凯瑞的魔钥还放在我这儿呢，因为刚刚领到，所以还没有认证。他刚才在这儿喝的东西由我先代他结账吧！”说着她已将其中一把魔钥递给了老店长拉布，而另一把则是轻轻地塞到了满脸呆滞的凯瑞手里。</p>
<p>从小酒馆出来的时候，凯瑞心里百感交集。此时一行三人走在校道上，凯茜拉着凯瑞的手一马当先地走在前面，身后那金发女孩则是默默尾随在旁。方才已经由凯茜做了介绍，那个女孩叫做安丽萨，和凯瑞一样是这一届的内森魔法部的新生。举止端庄有礼，应该是贵族出身，不过或许是恰逢如此场面，安丽萨一路审视凯瑞的眼神总是或多或少有点鄙夷。</p>
<p>凯瑞能感觉得到，这和路上那些行人投过来的神色相似，尤其是看到凯茜和他牵着手时。那些眼神里荡漾的深意就像火一样烧得凯瑞满脸不自在。他几次三番想将手从凯茜的手里挣脱出来，但是手心一直被心的拇指按着一点力气都是不出来。</p>
<p>凯茜对此仿佛毫无察觉似的，一边拉着凯瑞走着，一边简单向他介绍这学院的情况，一旁的安丽萨有时也会忍不住问一些。凯瑞只是默默听着，沿途的大部分内容早在刚才红发少女就已经向他介绍过了。即使是凯瑞也不得不承认那个仿佛靠嘴皮子吃饭的女人说起同样的事真的比凯茜所说的好了不止一倍。听过了梅尔的介绍后再听着凯茜的介绍会觉得索然无味。但是好在凯茜的介绍吸引了安丽萨的注意力，或者说是分散了凯瑞的注意力，不论如何凯瑞感觉没那么难受了。</p>
<p>就这么走完一段令人眼花缭乱、晕头转向的路程之后终于抵达了目的地。那已经算是学院范围外了，位于内森后山山道边的一套较小的庭院，里边是一座二层的橡木小楼，这就是心的住处。小楼位置极佳，当然这仅是对于少数人来说，比如凯茜。整套院子背靠着内森后山，院子里种着几棵高大的橡树。即使是晴天这里也显得有些幽静、阴森。院门前一位衣着朴素貌似管家的老妇人也适时迎了出来，对三人都各自行了一礼。</p>
<p>走进院内凯茜才终于将凯瑞的手松开了，这让凯瑞心里感到一松，不过也有点莫名的不舍。女主人吩咐了那位管家让他带着凯瑞去洗漱一下到餐厅等她，而她则叫着安丽萨一起去了客厅。回到了住处的凯茜似乎脸色没有刚才路上那般平易近人，两个法师都小心而默默地服从着她的安排。</p>
<p>在女管家的带领下凯瑞很快就到了餐厅，他也不是第一次和凯茜一起进餐了。餐厅里一张不大的餐桌上也早已摆好了一份丰盛的晚宴，烤鸡胸、三文鱼排、埃尔维斯干酪、蜜果宴…简单端视了一下，凯茜就到了。此时的凯茜已经换上了一套纯白色的露肩长裙，原本束在脑后的秀发也已披散开来，包裹着一张沉鱼落雁的面容，一身优雅的雪白礼服更是突出了她绝美的身姿，使屋内的一切都显得黯然失色。凯瑞看得呆了，但凯茜却很快捧着一个木盒子坐到了他身旁，这让他不得不赶紧收回了目光，端坐起来。旋即又张望了一下门外，他一进来就注意到了餐桌上摆着三副餐具。</p>
<p>“我让安丽萨回去了。”放好木盒的凯茜见状便若有所思的说道。“我不知道她为什么不喜欢你…原谅我，凯瑞。”</p>
<p>“唔？”凯瑞感到疑惑，望向凯茜用目光询问着。</p>
<p>“最近一直没有机会去看你。”说着凯茜一边还给凯瑞系餐巾。</p>
<p>“听你舅舅说你这次受了很大惊吓，变得不爱说话了。”说到此事时凯茜的眼神也忽的一黯，“不过这件事已经过去了，你以后都不会再见到那些盗贼了。见到你平安，我很高兴，凯瑞。”</p>
<p>凯瑞无法说话，只是默默低下头做了个餐前祷告，但凡是有光明信仰的贵族餐前都有这一例行的小仪式，算是一项小小的礼节。凯茜是记得以往这个男孩是十分毛躁的，对于这些细微礼节总是十分讨厌。而今看到他如此沉默，不由感到心疼。这一次的晚餐，十分压抑。给凯瑞分着菜，凯茜如是想。“我没有准备酒，我知道你一定还没吃饭，等吃完晚饭我再陪你慢慢喝。”凯瑞听后愣了愣，旋即点了点头。</p>
<p>“今天一直在等你，不过中途去安顿了一下安丽萨。回到接待处就听说那里的导师也正在找你，我就跟着找到了拉布先生的酒馆那儿。听人说你是跟着一个新生走的，而且是个漂亮的女孩子。”</p>
<p>凯瑞听了也仍旧只是点了点头，嘴里嚼着东西，没有说话。</p>
<p>“入学的那些事我已经替你办好了的，待会吃完晚餐你可以直接去魔法部报道，不要忘记了去认证你的魔晶秘钥。另外，我还给你准备了一份礼物。这是我一位同样是法师的同伴帮我替你挑选的，你应该会喜欢。”言罢凯茜放下餐具，轻轻打开了放在餐桌上的古朴盒子，里面放着的是一根顶头乳白色的橡木法杖。</p>
<p>凯瑞闻言也看了过来，那个装法杖的盒子在上一次东街上就看到凯茜抱着的，那么凯茜所说的那位法师同伴想必就是那个身着华丽衣裳相貌俊美的法师吧。不知为何，想到了那天的情景，凯瑞的心里忽然有些沉。</p>
]]></description><pubDate>Thu Feb 27 2014 19:45:48 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/paladitch-chapter-8</link><guid isPermaLink="true">https://blog.wxsm.space/p/paladitch-chapter-8</guid></item><item><title>第七章 · 梅尔</title><description><![CDATA[<div>
</div>
<div>
  <blockquote>
    <p>
      每当提到迪亚帝都费伦，人们总是容易忽略内森学院。这听起来或许让你觉得不可思议。然而事实如此，内森学院并不是一个隐晦的地方，相反的它比帝都费伦乃至迪亚帝国的历史更悠久，作为大奥术师的摇篮它也比费伦的名更加吸引世人，是以人们总是不会将之纳入费伦里，人们会说，内森学院和帝都，一如每当人们谈论到迪亚帝国总是会说迪亚波罗和他的帝国！
    </p>
<pre><code>&lt;p&gt;
  &lt;cite&gt;《奥术学院》&lt;/cite&gt;
&lt;/p&gt;
</code></pre>
  </blockquote>
  <blockquote>
    <p>
      这个世界上，人类那区区几十上百年的寿命仅仅只是个短生种，是以对于绝大部分普通人来将，内森的历史已太遥远，远的让他们感到毫无意义。而与少部分人来说，他们知道内森悠久的历史与通天威能，但他们也能感受到，内森的衰老。是的，施法者不会老，但是内森却老了&#8230;
    </p>
<pre><code>&lt;p&gt;
  &lt;cite&gt;《山德鲁手札》&lt;/cite&gt;
&lt;/p&gt;
</code></pre>
  </blockquote>
  <blockquote>
    <p>
      人们都知道施法者不会老，时间并不是施法者的毒药，时间的流逝不会让他们脆弱，衰老。白发苍颜，行将就木的法师远比以为正值壮年的法师更让人觉得信服可靠。大奥术师塔拉夏说过“生命在时间中生存，在空间中运动。而施法者在魔网中生存，在时间和空间中运动”
    </p>
<pre><code>&lt;p&gt;
  这座学院从很久很久以前就坐落在现今费伦以北的那片山脚下，背靠着一座高山，山的那边就是北部荒原。费伦建立以后，内森学院也理所应当的成为了费伦最坚实的北城门，学院开设了八大魔法学派及其子学派，而在迪亚崛起后，作为对开国大帝迪亚波罗的妥协，学院又开设了武技军略等学派，使得一个又一个迪亚王朝的军官进驻到学院之中，尔后王庭行恩，使得越来越多的贵族乃至平民子弟凭借着小小的一封推荐信成为了内森的学员。这让学院的原驻法师们感到危机，直到冷月之年一位传奇院长的上任。
&lt;/p&gt;

&lt;p&gt;
  山德鲁·布拉达卡，请记住这个名字。这位大奥术师通过无数努力得到了光明神的友谊，并与光明教会缔盟，从而使数个获得神力晋升成为法神的法师代表内森跃然于大陆的舞台上。冷月之年大陆战火连天，山德鲁法师又提出了战争魔法的概念，开发出了众多涵盖塑能、咒法、预言甚至是亡灵学派的战争魔法，使得迪亚的军队所向披靡，同时亡灵魔法的广泛使用也使得整个人类国度变得腥风血雨，常年笼罩在黑暗恐怖的阴影之下。或许也因此事，现今人们总是传诵这个邪恶、凶残兼之阴险狡诈的始作俑者已被其盟友至高光明神的仆从所格杀。他也成为了内森最后一任亡灵学派的主持者，亡灵学派自山德鲁后成为了内森的历史&amp;#8230;
&lt;/p&gt;

&lt;p&gt;
  &lt;cite&gt;《大奥术师山德鲁传》&lt;/cite&gt;
&lt;/p&gt;
</code></pre>
  </blockquote>
  <p>
    一个少年，一个有着黑色短发，身材消瘦的少年走进屋内，少年穿着崭新却仍是朴素合身的黑色法袍。这少年其实就是凯瑞。屋内仍是和他进来前那般安静，只是少了悉悉索索的写字声。
  </p>
  <p>
    他在来到这里之前并未被告知这儿还有个人在等他，不过来到这个陌生的环境，加之自己有着不可告人的秘密，让凯瑞从一开始就感到心惊和疲惫，整个人也十分憔悴。
  </p>
  <p>
    小铁匠是在马修几天的考虑之后最终被送到了内森的，或许是几天前发生在东街酒馆的那件事让两人都感受到了巨大的触动，马修在摁着凯瑞阻止他扑出去时内心也是无比沉痛的，那股沉痛让他下定决心，即使付出任何代价也要将自己的外甥送进内森学院，哪怕是得不到什么回报。对此，凯瑞万分感激，在激动和害怕的情绪下于内森入学的最后时刻到达了学院。接待处的导师对他做了简单的安顿，并在看了他出示的介绍信后让他到弗洛院长室等候，而他稍后会通知院长此事，临行前只是分外提醒他不要随便碰院长室里的东西，尤其是书籍。
  </p>
  <p>
    然后他就看到了眼前这样一幕，一个年纪比自己稍大，穿着差不多款式灰袍的红发女子，坐在办公室桌后，低头沉思，右手握着一只黑色羽毛笔，似乎刚抄着什么东西，在发现自己进来以后便停顿了下来。
  </p>
  <p>
    凯瑞并没有想到太多有深意的东西，他先是从少女望向自己的眼神中感到了冰冷与危险的淡漠，随后才慢慢舒缓开来变得平淡，他便意识到，自己让她不高兴了。作为年轻人，他自然地感到了紧张、局促和淡淡的不安。他开始低下头看着自己的脚，浑然没注意到红发少女的表情露出了淡淡的惊讶与疑惑，随后又变得玩味起来。
  </p>
  <p>
    “杂工？”少女说话了，声音很好听。
  </p>
  <p>
    凯瑞摇了摇头，表示否定。
  </p>
  <p>
    “新生？”少女又问了，同时手上也继续抄写起来。
  </p>
  <p>
    凯瑞点了点头。
  </p>
  <p>
    红发少女见状“嗯”了一声暂无动静，手上还是继续着自己的工作。
  </p>
  <p>
    直到过去有一会儿了，她才停笔，将桌上的几本书收好放回了她身后的立式书柜，手中的羽毛笔轻轻插进了自己的头发里再顺手向后掠了一把顺长的红色直发那笔就不见了踪迹。这让凯瑞心里不由一动，简单一个动作不但展现了少女对法术的娴熟技艺，也让着个美丽女子更多出了一股从容淡然的动人气质。只见她将最后一本黑色封面的厚重书籍捧在胸前站起身来越过办公桌款款走到了凯瑞身前。
  </p>
  <p>
    “你的名字”她向凯瑞问道。
  </p>
  <p>
    凯瑞没有回答，无法回答，只是默默保持沉默，想着那张份唯一可用的推荐信已不在手上了，他只好更加专注地盯着自己的脚。看到凯瑞这幅样子红发少女一怔，随后翻了翻手上摊开的大书。
  </p>
  <p>
    “很好，沉默是一个智者应有的美德”说着她在看向凯瑞时嘴角已有了笑意。“那么我该如何称呼你，凯瑞？”
  </p>
  <p>
    听到对方说出了自己的名字，凯瑞悬着的心方才落下，轻轻地点了点头。
  </p>
  <p>
    “如此甚好！欢迎你的到来，凯瑞先生。不过在我自我介绍之前，我首先要告诉你，施法者的人生是复杂的，魔法所谓的玄妙也只在于不为普通人所了解，选择了这条路也就意味着你将踏上一条与众不同且不为人所理解的道路。祝你好运！我是你的学姐，”说到这里少女顿了顿，“我叫梅尔。”
  </p>
  <p>
    凯瑞又点了点头，作为对学姐赠言的回应，他这次唔了一声。
  </p>
  <p>
    梅尔没有对此不满，不过也没有满意。径直走向了门外，并说道：“跟我来吧！我带你认识一下内森，除此之外的事你应该在来到这里之前就有人帮你安顿好了吧！”说着便已走出了院长室。凯瑞也立刻跟了上去。
  </p>
  <p>
    “每当提到迪亚帝都费伦，人们总是容易忽略内森学院。这听起来或许让你觉得不可思议。然而事实如此，内森学院并不是一个隐晦的地方，相反的它比帝都费伦乃至迪亚帝国的历史更悠久，作为大奥术师的摇篮它也比费伦的名更加吸引世人&#8230;.”行走在哥德式建筑的学院小道上红发少女在如同背书一般地向凯瑞详细介绍着内森学院的历史与现状。院长室所在的大楼就是导师们平时所带的地方，故而最靠近内森的大门，后边环绕分布的则是教学楼等建筑，到最里面才是魔法布学生的住处，一共六动样式不一的大楼整齐排列在城北的山脚下。
  </p>
  <p>
    “那边是魔法布的图书馆”梅尔指着远处坐落在教学区与住宿聚集了不少人流的高大建筑淡淡说道“不过，你也许用不了多久就会发现比起里面那些骗小孩子的东西还是某个导师的实验室或者办公室里的藏书更让你感兴趣。不过那并不是什么人都可以乱碰的。”
  </p>
  <p>
    “最后就是生活区了，就是吃饭之类的乱七八糟的东西，你可能会在这里看到一些奇怪的人，他们都是生活区另一边的骑士学院的人。”说着梅尔转向那边走了过去，路上果然如其所说有一些身着劲装或是皮甲之类的战士学员，值得一提的是大部分男士都对凯瑞身前的梅尔频频注目，眼神亮丽。或许因为这样，梅尔也没有说话了，直到她领着凯瑞走进一间类似酒吧的小店里，在靠近门口的地方坐了下来。
  </p>
  <p>
    里面地方很小，装修却别有一番格调，整个店靠外白了六章做工精良的小圆桌，而摆放的椅子也略矮，带有扶手和靠背，可以让人很轻松的躺在上面。除了长柜台还是和寻常酒馆一样罗列着一排高脚凳。店主是个络腮胡子的老人，一头白发达理的十分精神，或许此事正视无人光顾的时候，他本坐在柜台后，手里鼓捣着什么东西。见到有顾客上门也就走出了柜台，热情的问两位需要喝点什么，梅尔点了一杯龙舌兰，而凯瑞则是伸出拇指食指比了一个V，表示一杯威士忌，短短的几天他已学会了不少用来代替语言的手势。
  </p>
  <p>
    老店主很快把两杯酒松了上来，梅尔小缀一口在看了会儿握着辈子沉思的凯瑞后，才又开始说道：“你是一个很有法师天赋的人，凯瑞。看起来，你是是欧格里的信徒？”
  </p>
  <p>
    凯瑞没有说话，在听到智慧之神的名讳后点了点头。智慧之神的某些信徒便是十分沉默，轻易不说一句话。
  </p>
  <p>
    梅尔又喝了一口龙舌兰酒复而说道：“这样很好，我所信奉的是莎儿，对于夜女士的信徒来说，和欧格利的信徒交谈是件愉快的事，下面我给你简单介绍一下你所要面临的学派选择。”
  </p>
  <p>
    “首先是防护系。有些法术可以制造出火焰或寒冰摧毁你的敌人，当然你也可以用来摧毁你的朋友。但是我们学法术不光是为了摧毁。这一系别包含了抵抗火冰酸电等元素伤害的法术，你要是修行足够，还可以掌握干脆防止所有生物靠近的反生物结界。更高级的防护系法术心智屏障更是一切心智影响效果都可以阻断。
  </p>
  <p>
    其实防护的本意不是保护，是戒绝，放弃。防护系法术的原理也不是为了保护某种东西，而恰恰相反，是为了放弃某种东西。这就不难解释为什么高级防护系法术里有禁锢术这样可怕的法术，可以把一个个体完全隔绝起来，放到一个没有任何人能够找到他的地方。
  </p>
  <p>
    而最后，放弃的最高境界是放弃自身。任何施法者都忌惮的解除魔法术就出自防护系。防护系的最高成就之一就是一个以研发者姓名为名的法术——魔邓肯裂解术，这个法术能解除一切魔法效果，甚至连“反魔法力场”这种用来阻断魔法的效果都能消除。
  </p>
  <p>
    这正是魔法哲学的一条：魔法本身具有什么性质和效果，不代表人们会怎么样看待它。作为一个施法者，你一定要清楚魔法本身的结构和运作方式，至于它的效果和人们的观点，永远在其次。”
  </p>
  <p>
    “然后是咒法系，我不知道你清不清楚，除了我们生存的地方，这个无垠的宇宙里还存在着数不尽的空间和世界，你们以前叫他们“平行宇宙”还是“异次元空间”都好，在魔法的概念里，我们叫他们“异位面”。相对的，我们所在的地点叫“主物质位面”。若是丝毫不通法术的平庸者，自然不用在意那些地方，他们一生中能与其他位面的事物发生交集的可能性基本上是零。但是身为广闻博识的法师，如果不能和异位面有所交流，这个法师就不合格。
  </p>
  <p>
    咒法系的法术就是为此而创立，低级法术里就有通过异位面作为传输通道，突然制造出大量藤蔓和蜘蛛网来牵制敌人的法术，随着法师能力的增加，逐渐能开始召唤出各种生物，甚至能打开通往异位面的大门，让那些因为自身能力超出这个位面上限的天界生物和炼狱生物们踏入主位面。不光是单向的召唤，法师们还可以利用这一系的法术往来于异位面和主位面。我想你们一定听说过虫洞这种东西，实际上，咒法系的次元门法术有着同样的效果。
  </p>
  <p>
    你或许奇怪为什么这样的法术要叫做咒法系，我有个法师曾经告诉我说，每次他在那些对魔法无知的人们面前施展这些法术，他们都会兴奋地大喊“魔法，是魔法呀！”，于是他就明白这一系为什么叫咒法系了。不过我认为这明显是个冷笑话。”
  </p>
  <p>
    “下一个是预言系，这个学派的内容和他的名字并不是那么一致。能够知道未来的事情，从来就是法师们追求的极致，但是经过有志于探究未知世界的成千上万个最聪明的法师成千上万年的积累，我们现在能做到的，只有以下一些事情：看到某个远方现在正在发生的事情；看到某个人现在的所在之处；用魔法形成的眼睛替自己在冒险的前方探路。听起来和预知未来都没有什么关系对不对？我不是说完全无法预知未来，有某些高级的预言系法术可以让你直接和神灵沟通，直接询问他们几个问题，但是经过法师们前仆后继的尝试，发现神灵们只会回答少数领域的一些问题，而且还有一定的几率得到错误答案。最高级的九级法术预知术，能大致告诉你正在和你战斗的敌人下一剑会从哪个角度挥过来，这已经是目前我们能掌握的最可靠和准确的预言术了。
  </p>
  <p>
    但是我要告诉你们，这并不表示这一系的法术不重要！你需要知道的不是所有地方在所有时候发生的所有事情，而常常只要知道某个地点某个时刻发生的某个事情，就足以扭转整个局面。这也是我要告诉你们的另一条魔法哲学：关键不在于一个法术有多强大，在于你如何恰到好处地使用它。用一句法师们常说的话来解释就是：没有低级的法术，只有低级的法师。”
  </p>
  <p>
    “下一个，附魔系。任何一个傻瓜都知道用武力来保护自己，但是你试过用纯粹的意志力来保护自己么？一个真正的法师不会屑于和敌人厮打成一团，而是会用最纯粹精妙的奥术力量来扭转不利的形势，甚至把敌人变为忠心耿耿的盟友，这就是强大的附魔系法术。
  </p>
  <p>
    一开始你或许费尽全身的精力也只能让敌人晕眩几秒钟，但是随着进一步的研习，你逐渐就能慢慢达到影响他人态度的境界，能让他人不知不觉接受某种暗示，能让各种非人生物接受某种暗示。最后，可以命令他人直接伤害自身。
  </p>
  <p>
    你们有些人也许会为这一类法术而着迷，然而有些人肯定在想能不能不要这些搭建得很细致的法术，想要直接轰杀敌人。我正要向你们介绍的下一派别的法术就是这样的。
  </p>
  <p>
    也就是塑能系，魔法飞弹！火球！闪电束！冰风暴！这就是所谓“最豪快的轰杀法术派别”，事实上这也是现今帝国的法师们最热衷的法术派别。醉心于塑能系的法师们坚称，真实的自然是由物质的表相下的基本能量所构成的。
  </p>
  <p>
    这一系的法术放弃了那些精致的设计，而是回归到了能量的本源，操纵元素的力量，甚至是魔法本身的力量，这也几乎是最强大的力量。事实上，我希望你们记住这一个法则：简单的原理往往可以造成最大的破坏，因为越是简单，就越少顾忌到其他的因素。所以如果一个法术相对于他强大的效果来说相当容易施展，那么他一定有你还没有意识到的副作用。
  </p>
  <p>
    塑能系的魔法受到了为数不少的法师们的欢迎，也确实有相当的实用价值。毕竟，要让敌人心甘情愿的自我毁灭，不如直接毁灭敌人来得容易。
  </p>
  <p>
    经历了简单而本质的塑能系法术，回到精致构建的法术系统，这就是和附魔系并称为两大精神攻击法术派系的幻术系。虽然两者并称，但是两者的原理并不相同。附魔系是让敌人的意志发生改变，以为你是他们的同伴，而幻术系却是给敌人制造出一系列幻觉，让他们经过自己的意志真的相信你是他们的同伴。所以，幻术系的法师们有时候会认为他们才是真正的利用他人的意志。幻术师们最初只是制造出虚幻的声音，后来逐渐可以制造出幻影，然后是可以发出声音，气味的幻影，甚至是可以直接吓死一个勇敢战士的恐怖影像。对了，有一件事情你最好知道，这个世界上，每一个侏儒都是天生的幻术师。”
  </p>
  <p>
    “再然后是亡灵系，我之前说过了，常人如何看待一种法术，不代表这种法术真的是那样的。这种旁人态度和法术本身的冲突最明显的在死灵系这个派别凸现出来。曾经有一段时间，那么多的人都充满着对死灵法师们的恐惧和憎恨。诚然，死灵系是可以造成让人筋疲力尽，丧失斗志，甚至直接死亡的效果，但是这和直接把人烧成焦炭来说，到底哪一种更邪恶？
  </p>
  <p>
    死亡的力量是公平的，就像生命的力量一样，它不会对任何人有偏袒。实际上我相信，没有任何人能像一个死灵师一样以完全客观的视角看待死亡。他们认为生命不过是永恒的死亡过程中的一部分。对于这些探究长久黑暗的人们来说，生命是可以随时可以抛弃的无关紧要之事，于是，那些真正登峰造极的死灵大师们最后都会把自己改造成不死生物。注意！他们不是像常人们那样认为的，为了不死而长生，他们一是为了亲自体验死灵系最高级的奥秘，二是为了有更多可以支配的时间来投入法术的研究。我不反对你将来也踏上这样执著的追求道路，但是有一点你必须先明白，这么做会让常人们嫉妒你，不理解你，无尽的生涯里只会有同行和不死生物们与你相伴。等你做好这样的心理准备再学习死灵法术也许更好。”
  </p>
  <p>
    “最后是变化系，这是我要向你介绍的最后一个派系。”说到这里，梅尔将自己酒杯里的龙舌兰酒倒了一点在桌面上，随后那一滴酒竟慢慢地蠕动起来，变成了一只酒红色的毛虫朝凯瑞的方向蠕动起来。这让凯瑞叹为观止，他没有动，任由那毛虫爬到自己手肘的袖子上又化为了酒水融进法袍的布料里。听着梅尔继续说道“之前我已经说了几种法师们的哲学，这些理论有一个共同点，就是认为法术本身是世界本质客观而确实的体现，不以人们的意志而改变。而变化系的法术哲学与众不同的一点是：一切都会发生变化，只有“改变”本身是不变的。
  </p>
  <p>
    这一派系的法术忠实地再现了这种哲学，你可以通过变化系的法术来改变物体，改变自己，或者来改变敌人。没有什么是万能的法术无法影响的，坚硬的石头可以变成软泥，脆弱的肉体可以变为金属，高级的变化师们可以做到让某个区域里的天气都发生变化，或是让巨大的钢铁魔像变成一只兔子。变化系的巅峰成就更是足以踏入传奇法术殿堂的时间静止术，其实这个法术的原理很简单，是通过法术激化你自身的潜能，在一瞬间做出几个动作，此时其他人相对于你就是静止的。这个法术是法师们在面对敌人时的必杀技，真正的法术大师们都会这一招。
  </p>
  <p>
    如果你决定学习变化系的法术，你还需要记住另一个原则：大部分的法术只能在部分时间改变部分物体的性质，法术使用的时机和这个法术能造成的效果同样重要，千万不要在用飞行术或者水下呼吸术的时候忘了计算时间，摔死和闷死的法师可是同行们的好笑料。”
  </p>
  <p>
    “呼，很漫长对吧，你已经明白了八种法术学派的性质和他们各自的哲学，除了亡灵系外，你可以选择自己喜欢的一种专门学习，当然也可以博采众家之长，学习所有的法术当然是每一个法师的梦想，但是以我个人的经验，很多法师到了一定阶段都会发现某一派系才是真正让自己着迷的。最后，菜鸟，祝你好运。”
  </p>
  <p>
    在终于介绍完所有的内容后，梅尔放下了手中的酒杯起身离开。而凯瑞则沉浸在她的话语或许还有自己的幻想中，意犹未尽。直到那位慈眉善目的老店长站到了他身旁笑道“还需要什么吗？先生。”
  </p>
  <p>
    凯瑞惊醒过来，他摇了摇头。站起身来伸手松开了腰间的钱袋表示结账。
  </p>
  <p>
    “一个金币，先生。你的威士忌我已经免了，那位小姐点的龙舌兰酒是本店的招牌，一枚金币。”老店长十分友善，笑着解释道。
  </p>
  <p>
    而他话音刚落，凯瑞脸上的表情已经惊呆了。
  </p>
  <p>
    “其实你不必感到心疼，先生。如此精妙而引人入胜的介绍词辞已经十分精彩了。现在的年轻法师们满脑子想的都是如何制造更大的火球和飞弹，然而魔法的本质并不在此。能够让你自发地认识到这一点，那对你的好处可不是小小的一杯龙舌兰可以相比的。”说着老店长回头看了看柜台上方的一副裱装的星辰图画，陷入了沉思。“也只有在很多年前，老一代的导师才能说出这番话。不过如今也大多封存在那些老头子的魔法书里了吧！”
  </p>
  <p>
    对于老店长的话凯瑞则是一点都听不进去，他自古地沉默着，内心十分惊慌，不知如何是好。事实上他口袋里也就十几枚价值不一的银币和几块铜板，全部加起来也肯定凑不齐一个金币的。因为那是昨天才从金币打散开来的钱。如今让刚才那个红发女孩点了一杯龙舌兰酒用掉了一金币，眼见梅尔已没影了，他真不知该如何是好！如何是好?如何是好！
  </p>
</div>
]]></description><pubDate>Mon Feb 10 2014 19:41:17 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/paladitch-chapter-7</link><guid isPermaLink="true">https://blog.wxsm.space/p/paladitch-chapter-7</guid></item><item><title>第六章 · 早起的虫儿</title><description><![CDATA[<p>摩尔出来的时候，夜已经很深了。这个时候，绝大多数的人都正熟睡，哪怕是一些精神格外亢奋的年轻男女，此时也差不多强行支付了最后一波精力。</p>
<p>正直此时，确实摩尔经历最充沛的时刻，因为摩尔是一个怪人。他不循规蹈矩，不论是在工作要事上还是生活上还是在个人生活上，他的诸多习惯、想法都可称得上是天马行空，羚羊挂角。“早起的鸟儿有虫吃”这句谚语一直为人们所津津乐道，一方面赞扬勤奋劳动的平民，另一方面是推崇先发制人的战术思维，古往今来无人对此有何异议。而摩尔却对此嗤之以鼻，他不早起，无论有无需求，他都不喜欢早起。法师的身体太孱弱，起早贪黑的生活习惯肯定会把他累坏的，而他这样的小人物，生命渺小得如海中浮萍，若凡事都抢在人先，那肯定是很容易死的。</p>
<p>早起的鸟儿有虫吃不假，但早起的虫儿呢？自然是被鸟吃了。摩尔对此有很深的体会。</p>
<p>午夜的钟声早已敲过，帝都大街小巷的人流也早已散去。尽管帝都不同于迪亚边境的一些要塞城市，没有严格的宵禁制度，然而长期保持光明信仰的人们还是对黑夜有着难以磨灭的厌恶感。除了某些身份卑贱，地位低下诸如伙头、马夫、铁匠乃至妓女之类的角色，没有人愿意在深夜工作。长此以往，最深受迫害的则莫过于城市的黑哨，也就是负责夜间城防的士兵。</p>
<p>长久的和平使得黑哨的士兵们几乎遇不见什么让人热血沸腾的大事，仅有的一些小事也总是一些让他们哭笑不得的鸡鸣狗盗，捉奸在床，再不就是些让他们感到肮脏卑贱的活儿，比如尸体之类的黑夜中的禁忌字眼。</p>
<p>摩尔正式冲着当日傍晚那具尸体去的。是一具，死在华衣少年脸下的那具。</p>
<p>早在当时摩尔就已看出，那个被称作心小姐的女人并没有下死手，经她之手飞出去那个冒险者虽然当时也停止了呼吸，但只是受力过重厥了过去。没意外的话事后不久就会在光明神的保佑下重新活过来，既然他们都是佣兵，那么应对这样的情况应该会有经验。所以只要不是他的同伴们别有用心要玩几手高端计谋，那么摩尔今晚的目标也就只有那具被法师脸撞死的领头者了。</p>
<p>依旧裹着那身宽大的袍子，在夜色掩护下，摩尔轻车熟路地穿过几条巷道来到了位于城市东南部的一个小角落，面对着一堵黑森森的高大院墙，他开始感到心脏咚咚直跳。“已经不是第一次了呐！菜鸟，要镇定。”心里暗暗给自己打了打气，右手从袍子里掏出一串手指粗的麻绳扔到了地上，随后双手交替结了几个简单的手印对着地上的绳子一指，那串绳突的动了动，仿佛活物一样直立起来笔直的朝墙顶伸去，然后也不知怎的牢牢地固定在了墙顶。借助这跟会动的绳子，摩尔很轻松就翻过了这面两人高的院墙进入到院子内部，收回了绳子望了望院门口的动静并在院子的角落藏匿了一会儿就悄悄进入了停尸间。</p>
<p>房间很空旷，只有一架床位十分醒目地摆在中央。摩尔看着眼前的床位心里就仿佛是老鼠偷了密一样甜，一具新鲜的尸体！</p>
<p>尸体总有它的价值，你只需要想想那是吃了多少年的粮食才能长出来的东西你就不难理解它的价值。然而很多人都不知道，亦或者假装不知道，更多的人对它是避之不及。那是不对的。</p>
<p>轻轻揭开了盖在上面的破麻布，摩尔观察了一下，依稀可见死者生前长得浓眉大眼，胡茬满布，身材也挺健壮，“可惜没什么脑子”摩尔是这么想的。他很惊讶于那华衣少年的一撞之威，竟硬生生将这个强壮战士的脸部撞的稀烂。很明显是施了几种魔法，但具体是哪几种摩尔也无法确定。想着他已取出了一些小工具着手收集他想要的材料，首先是割开了死者的动脉取了一瓶子的血液，以后在处理这些材料时这瓶血可以省去他不少的功夫，当然完事后他也不忘小心地用特殊的药物处理一下尸体的伤口。接下来收集的是让他大感兴趣的牙齿，主要是对于那华衣少年的好奇，而眼球和牙齿是最能直观反映那一撞之威的部位。他掏出两把镊子熟练地用一块木楔子撑开了死者的口腔，简单观察了一下，尔后打算从不显眼的地方取走几颗牙齿。</p>
<p>就在这时，门外忽然传来一声动静。这让他猛地一惊，他定了定神，随即开始收拾东西，动作轻微而迅速，门外再度传来几声轻响，他可以肯定，门外有人，也一定是活人！所以他很快就收拾好将床位回复了原样。不过在环视了空旷的四周后他开始犯难，万一有人过来，自己该藏哪儿？如果周围还有其他床位他一定二话不说就躺上去，而眼前的这个床位嘛，虽然他对死人的好感不比对活人的差，但他却多少是个有点洁癖的人，要让他这样挤进这个小床位，那简直比杀了他还让他难受。摩尔只好祈祷门外的人只是例巡的看守士兵，不会进来，否则…</p>
<p>然而还没来得及祷告，门就轻轻地开了，摩尔心里一沉，望着门后那个清晰的人影慢慢走进来，深吸了一口气，略微紧了紧裹着的袍子，眼睛也渐渐眯了起来。不过随后听到这人说的话却让摩尔差点把肺里的气全喷了出来。</p>
<p>“别动手！是自己人！”仿佛悄悄话一般轻轻地说出来，那进来后便站立在门口，体形瘦弱，个子比摩尔稍高，他右手正举在耳边，左手也竖立在嘴前以示噤声。</p>
<p>摩尔没有异动，稍微后退了两步仍是面向着此人保持戒备。见此人轻悄悄的走到了床位旁，十分熟捻地拉开了床位上的麻布就在尸体身上摸索起来，脑袋还贼兮兮地时不时望向摩尔。见此状摩尔便明白了，原来这家伙是来摸粽子的，也就是搜刮尸体身上的财物的。</p>
<p>在大陆各国都有个不成文的规定，但凡冒险者客死他乡，尸体都是先由当地官方收放，并作简单的身份认证和死亡通告，在处理完死者生前生后的相关纠纷后再交由相关人认领，如若无人认领则是火化或薄葬了事。而在其中一个环节却引来了一些梁上君子的觊觎，也就是尸体被收敛后身上的遗物通常都是不动的，这常常引得一些大胆的小蟊贼来摸粽子。</p>
<p>这么说起来，眼前这个人倒还真是个自己人，摩尔想。不过自己虽然也是摸粽子，但可比他们要有技术含量得多。淡淡审视了一下眼前这个衣着普通的小贼，摩尔估摸着应该是帝都一个普通的刁民，想来即使是在富饶的费伦城，也不乏贫民，以至于还有摸粽子的贼。想到此处他不由感慨，活着不难，想清清白白地活着却是难得要命。</p>
<p>摸粽子那人手脚也是十分灵便，不一会儿功夫就差不多将这具尸体身上能藏东西的地儿翻了个遍，翻出几件杂物，借着门窗照进来的月光可以看到是一些小东西，除了一串看起来平平无奇的兽齿项链，便是一些诸如小刀、打火石之类的野外装备，最后还有一个巴掌大的小皮包，想来便是钱袋无疑。</p>
<p>那人放下了手里的其他东西，掂了掂手里的小皮包，轻微的几声金属撞击声便响起。他看着摩尔轻轻说道“最近的不少外来者都挺有钱的啊，前几天也是在这里摸到了一个大粽子，让我大发了一笔。看来这行真是有前途。”摩尔没有动，也没有接他的话，只是静静地看着他。</p>
<p>事实上这人说的不错，几天前那个粽子摩尔也摸过，据说是深水城来的一个探亲的士兵，不知是得罪了什么人，来费伦的当天就死在了一家窑子里，摩尔也不知道那次他来得比这人早还是晚，因为他一般是不摸尸体身上你的财物的，不过此时他什么都不打算告诉眼前的这个人。只是静静地在等他的回应，摩尔能感觉到眼前这人十分犹豫。</p>
<p>从常理上也正该如此。自己先他一步来到这里，却被他半路杀出来把东西都摸了去。这样是不妥的，要知道摸粽子的人虽然不似强盗那般穷凶恶级，可也不是什么好相与的人，眼睁睁看着自己的猎物被别人抢了去，换谁都不会轻易善罢甘休。</p>
<p>果然，那人轻轻打开了钱袋，并对摩尔说道：“老兄你比我先来一步，但怎么说我也干了这么多活儿，咱们就一人分一半如何？”摩尔紧了紧自己的袍子，嘴角微微翘起，这样的变故倒在他预料之中，于是说了声“好”便伸过手去接过了那人分来的钱。淡淡看了一眼手上的钱，他诧异的发现除了几块银币铜板外竟然还有一枚金币，看来还真如那人所说的一样，这行确实是蛮有钱途的。他也未细数，很快就将钱轻轻放入了自己的口袋，不禁暗暗感到好笑。</p>
<p>回过头来那人也已收好了属于他那份的钱，看样子似乎没有要走的意思，而是装模作样地研究着剩下的那几件小东西，脑袋依旧贼兮兮的，时不时盯着自己。大概他还有什么东西不愿和自己分享。摩尔莞尔一笑，想了想今晚的事已经无法继续了，便不再搭理那个人径直朝门外走了。那人也一直顾着手上的事，自然是没有要留摩尔下来一起研究的意思。</p>
<p>按照来时的方式，摩尔十分轻松地回到大街上，一路上也未见有什么异常。心里盘算着今晚这个意外到也算是有惊无险，至于被那个摸粽子的小贼坏了自己的好事，他则没有过多纠结，摩尔并不是一个患得患失的人。他本来有的是方法处理刚才那个意外的，就最直接的用暴力拿下这样的小贼也不过小菜一碟，问题是无论哪种方法都会带来不少变数，也容易招惹麻烦。眼看内森学院入学在即，此时招惹麻烦那是不好的，何况摩尔本来就很讨厌麻烦。不过就在他快要回到自己的小屋时，他忽然想到自己刚才忽略了一件事，出于思维惯性他刚才没有考虑到那人只是个普通刁民，也不见携带了什么特殊工具，他究竟是怎么凭空混进那看守森严如铁桶般的院子的呢？想到这里摩尔不由感到一寒，不自觉地裹紧了袍子。</p>
<p>麻烦，貌似已经来了！</p>
]]></description><pubDate>Tue Feb 04 2014 19:32:35 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/paladitch-chapter-6</link><guid isPermaLink="true">https://blog.wxsm.space/p/paladitch-chapter-6</guid></item><item><title>第五章 · 趣事（下）</title><description><![CDATA[<p>“如果我们有什么冒犯了的地方，我希望能够得到你们的原谅。”</p>
<p>白衣女子这句话说出后，领头的那个冒险者已隐隐感到沉重。衣着光鲜，相貌不凡，仅此两点就已经让普通人望而却步，而这个女人无论是气质还是举止都是普通小贵族们所达不到的高度。</p>
<p>众所周知，但凡贵族都注重涵养与风度，高贵与优雅一直是贵族们的形象标杆，越是显贵的贵族越是重视这些。不过这并不代表这个群体无害，尤其面前这年轻女人貌似在武技上也有不小的造诣，绝不是能任人拿捏的善男信女。</p>
<p>虽然自筹凭借着多年在刀口上生活的本事即便是真与这个女人起了冲突也不会落于下风，但那绝不是他希望发生的结果。首先，六个佣兵当街围攻一个年轻貌美的女人，传出去了无疑会落了自己当家老大的面皮，这是丢人；其次这几个佣兵个个都是好勇斗狠之辈，一旦打伤了这个女人，势必会惹上不小的麻烦，这是惹祸。他不想丢人，更不想惹祸。</p>
<p>直到旁边的那个华衣的华衣少年站了出来。他仿佛是不耐烦一般，两手抱在胸口慢慢地，一步一步地走到了领头者的身前，动作慵懒，脑袋低垂，嘴角带着浅浅的微笑，很是不把面前等人放在眼里。</p>
<p>之后气氛瞬间轻松下来，不论是冒险者一行人还是周围围观的有心人都感到莫名地松了口气。只有极少数人才发现随着这少年往这里一站，刚刚由他身后的白衣女子所散发出的气势便被完全阻挡了。</p>
<p>同样感到松了口气的领头者心里大呼这是一个不错的机会，面前这个跟软蛋似的少年比起他身后的白衣女人无论是看起来还是感觉上都相差了太远。他自信此时此刻自己可以随意拿捏这个年轻人，而如果只是羞辱了这个软蛋也算是达到了目的又不会使那个女人为此大动干戈，于是他迫不及待的带着一脸戏谑的笑容调笑道：“小子，你是想替你的漂亮阿姨出头么？”此番话一出身边几位同伴都爆发出一阵哄笑，连那白衣女子也眯了眯眼似是对这句话十分不满。</p>
<p>然而那华衣少年却是丝毫不为之所动，仍旧面带笑意，低头竖目地盯着眼前人看，那仿佛，仿佛是在看着一个傻子。而与他面对面的领头者也反过来觉得面前这个少年似乎是吓傻了，他瞅着这人身形懒散，浑身破绽，尤其可笑的是他身上那件做工精良的袍子还向自己昭示着他是一个魔法师。多年的佣兵经历告诉他，在这样的距离下一般法师面对敌人几乎是毫无还手之力，想必这个年轻的家伙还是一个刚出道什么都不懂的菜鸟。</p>
<p>想到此处，领头者不禁玩兴大起，左脚一挑勾起了地上的一块魔法灯碎片稳稳地接在了左手上，右手指伸到了碎片上沾了一点黑漆一把抹在了华衣少年的鼻头上。“小子，看你这模样，一定会很讨你阿姨喜欢的。”说话间又引出几声笑声。</p>
<p>而少年就仿佛雕像般静立不动，任其在自己鼻头上抹了浓浓的一抹黑漆，这让他身后的白衣女子也不由一怔，却也仍是静立着没有其他动作。也只是过了眨眼的功夫，华衣少年才默默伸起右手抹了抹鼻子凑到眼前定睛看了看，随后在众人惊诧的目光中一把涂在了自己的右脸上，随后又再度将手指伸到领头者手里的碎片上沾了沾，脑袋前伸将脸凑到了领头者眼前开始涂抹自己的左脸，然后又是额头。</p>
<p>面对他如此怪异的举动，围观的人都惊呆了，霎时间四周人变得鸦雀无声，呆立不动。只有这少年仿佛表演一般自顾自地涂抹着自己的脸。</p>
<p>惊异！周围的人此时都是同一个想法，纷纷看着少年如同傻子般的行为却无一点笑意，都是感到莫名地惊诧与诡异。只有他们身后那间酒馆门口内的一个人，一个裹在灰色袍子里的人，在看到快一半时露出的玩味的笑容。</p>
<p>华衣少年涂抹完了，那是在他脸上已经布满密密麻麻的黑漆时，他才作罢，还沾着黑漆的手面前那人的衣服上擦了擦。此举也惊醒了面前的男人，只见领头者怒哼一声猛地将左手的碎片摔倒地上，右手飞快地伸出抓住了华衣少年的肩膀。</p>
<p>然而，他却忽然发现自己的脑袋不受控制地向前撞了过去，与此同时少年的头也以同样的方式撞了过来，满是黑漆的脸上绽开着已看不出是惊喜还是狰狞的笑容。两人的脸就这么撞在了一起，发出了一声嘎的脆响，在众人更加惊异的目光中，领头者仰面倒了下去，脸上可见的只剩下一片模糊的血肉，眼看是快要去见光明神了。而反观华衣少年则是摇摇晃晃地站着，脸上也仍旧是那般乌黑狼藉的模样，除了看似有些头晕目眩之外，丝毫没受到任何伤害。</p>
<p>直到此刻，一股强烈的恶寒才悄然升起在众人的心间。这个家伙，这个法师，实在是太凶残了！太暴力了！而余下五个冒险者在目睹了同伴的惨剧之后纷纷取出了别在轻甲上的各种武器，惊惶不已。</p>
<p>一个持着手弩的冒险者用难以置信的语气质问着少年：“你杀了他？”后者仍是低头扶额淡淡地反问道：“他的人头赏金是多少？”</p>
<p>短短一句话，众人的心头的寒意更甚！几个害怕被殃及的围观者已经开始下意识地走开，但也终究抵不过好奇心作祟，不住地回头看。</p>
<p>“没有赏金，先生！我们是佣兵，即使是在帝都我们也有对攻击我们的人进行反击！而且，你还杀了我们一个同伴！”其中一名佣兵用手中的长剑指着华衣少年说，“你知道我们的团长是谁吗？”说罢也不待少年回答便将手中的剑一横，飞冲着劈砍过来。</p>
<p>“我管你们是谁。”一声突兀的女声响起，伴随着话音，一只纤长的玉手猛地出现如同钢鞭一般朝着挥剑者劈砍的反方向扫过，可怜这个佣兵剑还未砍出，整个人已被那手抽得旋转着倒飞出去，如同一口破麻袋一样摔在了几步远的地面上，再无动静。而他的那把剑也在这一瞬间被那只手反手握住了，正是那名白衣女子。</p>
<p>这番变故让剩下的四个佣兵原本就十分沉重的心再次跌到了谷底，纷纷目光呆滞地望着眼前这位左手抱着木盒，右手反握长剑肃立在华衣少年身前的女人，再不敢有任何动作。面对如此的实力差距，他们深知自己只能是任人宰割的羔羊。</p>
<p>白衣女子并没有继续为难他们的想法，在审视了剩下的四人后，丢下了右手的长剑。也未回头，只是淡淡地对身后的少年说声：“回去吧！”少年还是用手捂着额头，瞟了面前几人一眼，用戏谑的语气笑道：“我觉得这两个人加起来至少值十个金，你怎么看，心小姐？”</p>
<p>被称作心小姐的的女子一言不发，垂下眼睑眯着眼睛看了看那个仰躺在地上已停止呼吸的男人一眼，皱了皱眉头，便自顾动身向东街的出口走去，几步之后又停了下来回头看到仍站在原地抚弄额头的华衣少年，又折返回来扶住了他另一只手臂，两人便这样朝着外边离去了。剩余的四个佣兵则是呆立在原地，仿佛木偶一样毫无动静。围观的人见此好戏结束也是唏嘘不已，仍有望着那对男女离去的方向目光复杂。</p>
<p>而站在酒馆门边，那个几乎全身都裹在袍子里的摩尔也是久久立在原地，若有所思。他想了很多，那名华衣少年和他脸上的图案，那名白色劲装被称作心小姐的女子和她的那次出手，还有不经意间注意到的，被叫做凯瑞的小铁匠，就是在刚刚被大铁匠马修半是搂半是拽地带进了酒馆里。在那之前，小铁匠的目光一直盯着那位心小姐，不同于其他人那些敬畏、艳羡、嫉恨乃至或多或少带有一点禁忌色彩的目光，小铁匠的目光中是十分的殷切，十分的凄然，余下几分落寞与不甘。</p>
<p>好毒！摩尔心里是这么评价那双眼睛的。眼睛都这么毒，心里一定有很多苦。摩尔如是想到。</p>
]]></description><pubDate>Sat Feb 01 2014 19:28:23 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/paladitch-chapter-5</link><guid isPermaLink="true">https://blog.wxsm.space/p/paladitch-chapter-5</guid></item><item><title>第四章 · 趣事（上）</title><description><![CDATA[<p>雨后的费伦即使是傍晚也显得十分清澈。这片位于帝国中部镶嵌着北部荒原与东部玛雅山脉的土地，已经有近百年的时间没有遇到过战争了。百年的时间，足够让一片贫瘠的土地变得无比富饶。</p>
<p>平静赋予费伦富饶与祥和，也抹去了费伦的血性与荣耀。对于崇尚武力与战争的迪亚帝国而言，如今的帝都已经成为了帝国板块上最奇特的一块了。帝国的史书上有这么一句话，是来自遥远东方的一句谚语。“养兵千日，用兵一时”这句话下面还有迪亚开国大帝迪亚波罗的解说“每过两年又270天，军队就应该动用一次。”</p>
<p>而今的费伦是迪亚帝国最耀眼的明珠，这里汇聚了帝国中部百分之八十以上的贵族、富商，无数的月桂香料、玛雅水晶、绒毛地毯等大量上流贵族的奢侈品被日以继夜地运往此处，也汇聚了大量的冒险者，数不尽的魔法器具、奇珍异宝和稀有奴仆一并充斥着费伦的繁华街道，玲琅满目，车水马龙。“帝都的泥土都带着奶酪的香味”这句流传甚广的谚语，很彻底地形容了费伦的富饶。</p>
<p>财富可以给人们丰富的物质生活，却总无法填满人内心的空虚。费伦的贵族是富足的，他们过着悠闲而安逸的生活，费伦的贵族也是蛋疼的，因为远离战争让他们很多时候变得无事可做。他们生活中最大的调剂无非是讨论西街新上市的各式珍玩、女奴又或是某个伯爵府传出来的花边绯闻。比如墨菲斯伯爵的长子非常博爱，甚至与杰克斯男爵的关系不清不楚，又比如墨菲斯伯爵的次子，以俊美闻名于整个帝都的卓林·墨菲斯正大张旗鼓地追求着北疆蛮王胡夫将军的千金凯茜-胡夫。</p>
<p>然而于无关者而言，这样的调剂也只能是调剂。无关者有两种，一种是事不关己然而却热衷于打听此事，另一种则是无暇关注，在听过之后默默记下。摩尔即是在听过之后默默走出西街，一路走到了东街。</p>
<p>当他来到东街时，感觉就像回到了边境的要塞。</p>
<p>这是一个非常糟糕的比喻，但可惜现实就是如此。街道两旁非常的拥挤，只在大路的中间留出一个马车的位置，大量的冒险者将自己收获的物品摆放在路边，刀剑兵器，戒指指环，法杖枯木，石头宝石，奇形怪状杂七杂八的东西看的摩尔一阵头晕。</p>
<p>事实上东街的前半段就类似于一个淘宝基地，这里摆地摊卖的都是各地冒险者从某个遗迹或者是某个废墟里面找到的东西，当然也可能是某个地沟又或者是垃圾堆，摆地摊的冒险者走两个极端化，一部分如街道小贩般叫卖着招揽生意，而另一部分则摆出各种例如沉思、静坐、冥想等姿势，一副你爱买不买的表情，远远看着就感觉一股高手气势扑面而来！</p>
<p>其实摩尔刚看到时确实被那群高手们震惊了！尤其是一位怀抱着一把和他差不多高的维京重剑的高大战士，那感觉好似一位绝世剑客傲立于巅峰不堪寂寞的样子。他的摊位上就几件东西，一把锈迹斑驳的匕首，两个指环，一根烧焦的木头看起来像是法杖的东西。摊位下用天马行空般的狂草写着价格，分别是五百枚，一千五百枚和一千八百枚！那价格看得摩尔是心惊肉跳。随后定了定神看了看那几件东西后，又裹紧了身上灰色袍子继续向前走去。之前他还以为这位高手气质浓厚的家伙会摆上什么了不得的东西，原来全是西贝货。</p>
<p>在东街卖东西，是不存在什么上当受骗的，在这里拼的就是眼力。许多传说级的法杖与兵器就是出自费伦东街的地摊。不过总的来说，东街摆放的大部分都是无用的垃圾。经过那个摊位后，意兴阑珊的摩尔不再关注路边的摊位，陷入了沉思。</p>
<p>在这个大陆上，思考一向是聪明人的专长。智者千虑必有一失，愚者千虑或有一得。这句话说的就是面对同样的问题，聪明人思考一千次以后得到的可能至少会少一种，而不聪明的人思考一千次以后往往会多出几种。摩尔自认为是一个还算聪明的人，他总是愿意为了减少一种可能而将一个问题反复思量多次，他也总是不乏遇到值得思考的问题。</p>
<p>直到他走进了后半街的一家酒馆，源源不绝的趣事还是在时刻撩拨着他的脑筋。比如酒馆里那个正被一伙类似马夫的邋耷汉子调笑嘲讽的壮汉，这个被称为马修的男人身体壮实，散乱的头发和胡须遮盖不住那张如炭火般发红的脸，诚然此时的马修十分恼怒，但摩尔也知道并不是因为这样才让他脸红如炭。结合他那双裸露在外的粗壮手臂，摩尔不但看出马修常年面对火炉做着打铁之类的活计，还有过那么点武技的底子，他甚至可以想象如果没有什么束缚，这个男人不过几口气的功夫就能把那几个马夫揍得死去活来。不过常年的铁匠生涯已经把这个男人的血性与脾气消磨殆尽，此时此刻面对别人的侮辱，他也只是咬着牙默默喝着廉价的威士忌。同样的还有他身旁的一个短发少年，握着一杯酒目光黯淡、毫无生气，这个年轻人若是投身军伍也许可以成长为一个优秀的士兵乃至更高，却莫名其妙地做了一个铁匠学徒，可以预见，不久的将来他也一样会获得如同马修那样的红脸和粗壮的手臂，同样的和那懦弱的性格。</p>
<p>想罢摩尔已走到了柜台，向酒保比划了一个简单的手势。在支付了一枚银币后他握着一杯色泽晶红的葡萄酒坐在一旁听着酒保向他诉说着最近的趣闻，何时何地，谁与谁因一些莫名其妙的原因发生了莫名其妙的事，有些事很无趣，他会趁这个时候默默地喝点酒，而有些事则很暴力，或许他会默默记下。</p>
<p>时间过去一会儿，就在酒保正为他续杯时酒馆外忽的传来一声轰响，这让酒保也突的一惊，手中的葡萄酒也洒出两滴。这阵变故引得酒馆内的人纷纷往门口处望了过去，摩尔也是转过身看了看，似乎是酒馆对面的店铺发生了什么好事。回过身来，酒保正啜吸着食指，那是沾了柜台桌面上那两滴洒落的葡萄酒，他朝摩尔笑了笑说道“外面好像发生了什么事，在这里闹事，现在很少见了。”说着自顾封着手上的酒瓶。摩尔那笼罩在兜帽下的嘴角也露出了浅笑，随即放下一枚银币端着酒杯往门口走去。已有不少好事的人聚集到门外了，刚才那一大一小两个铁匠也正站在门边，令他惊异的是原本死气沉沉的小铁匠此时却精神异常，眼睛发亮直直地盯着门外，顺着望去正好看到一个女人，让人一眼看过去就会不自觉地将目光集中到她身上去的女人。</p>
<p>她身材笔直而修长，黑亮的长发被简单束好垂在背后，身着一身淡白色劲装，隽秀的面容充满英气却目光淡然宛若雕像，乍看是一个清丽脱俗的女武士，左手还抱着一个不大不小的红木盒子，古朴而典雅。待到一切都已尽收眼底细细打量过后，你才会发现她身旁还站着一个少年，面容俊美，衣着华丽，带着一丝玩味的笑容看着他们身前的几名穿着轻甲的冒险者，地板上还散落着刚被打下来的魔法灯碎片。</p>
<p>看样子是这几个冒险者因为什么事和这对男女起了冲突，摩尔首先想道。他看了看那几个衣着几乎一模一样的男人有些玩味地的揣摩大概是某个大佣兵团的佣兵，看到这个女人一时兴起想要调戏一番，这样的事情换了一般城市是并不少见的，常年混迹在佣兵团的男人都不是善茬，放在其他地方遇上些弱势的女性冒险者调戏了也就调戏了，在没有厉害的男人为之出头的情况下一般也就过去了。但是能够活下来的佣兵一般都不傻，在费伦这样的地方对这两个一看就不一般的人也敢随便招惹，那分明就是在作死啊。不过想到此处他也不由地又看了那个女人几眼，确实也让人感到惊艳。</p>
<p>“如果我们有什么冒犯了的地方，我希望能够得到你们的原谅。”突兀的女声，淡然且带着冰冷，说着她也仿佛不经意间向前迈了一步，似是道歉，却又仿佛说着一件无关紧要的事。</p>
<p>摩尔的瞳孔猛地一收缩，眼眸深处突然迸发出晦暗的色彩，随即，他松了松握着精致水晶杯的手，修长且白皙如玉的手指轻柔地在杯子上打圈，便如同把玩着一绺头发。 作为一个醉心炼金术的法师，他几乎就是一个高明的数学家，对于数字的感应有着超乎寻常的敏锐性。那个女人此时和那几个冒险者的距离不多不少，都是刚好八十公分！而人的手臂加上匕首的长度也正好是八十公分！这个距离被刺客们称为上帝禁区，也就是说，在这个距离之中，你已经得不到上帝的庇护了。一个高明的刺客绝对比一个大法师更危险，当然，也比一个大法师更加稀奇与罕见。这几个人很不幸，他们貌似遇上了一个高明的刺客。</p>
]]></description><pubDate>Fri Jan 31 2014 19:23:53 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/paladitch-chapter-4</link><guid isPermaLink="true">https://blog.wxsm.space/p/paladitch-chapter-4</guid></item><item><title>2014-01-29</title><description><![CDATA[<p>很快就过年了。</p>
<p>回了一次赣州，小姑的生意越做越大了，店面越来越多，小时候第一次去广州好像还是在一个住房里做事，应该十多年了吧，跟着老妈参加了他们的年会，很多比我小的男孩都参加工作了，家里的两个弟弟也都在工作，唯独我还在读书，有种说不出的感觉。郭慧姐应该快生小孩了吧，罗云哥嫂子的小孩也快了，不知道会叫什么名字呢。奶奶身体好像还不错，挺好的。</p>
<p>在大姨家住了几天，大姨做的菜还是很好吃，比婆婆做的都要好吃，但是有些东西还是婆婆做的更熟悉。谢金宏读五年级了，看起来还是小时候那个样子，不过这次没有看到他哭，大概也算长大了一点。后来感冒了，很不舒服。去水东走了一次，姑奶家养了很多狗，有小狗也有老狗，婆婆家的房子还有人住，不过是租给的别人，记忆已模糊得不可辨识。</p>
<p>前天回家，昨天宅掉，今天出去走了一圈，没什么变化。最近发现自己变得犹豫了很多，不喜欢这样，一直觉得自己做起事来都是干净利落的，但这次不知道为什么。真的很抱歉，让你看到一个这么寡断的我。</p>
]]></description><pubDate>Wed Jan 29 2014 00:56:24 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/2014-01-29</link><guid isPermaLink="true">https://blog.wxsm.space/p/2014-01-29</guid></item><item><title>2013 年终总结</title><description><![CDATA[<p>首先感谢郭凯瑞同学百忙中抽出时间接受访问，那么事不宜迟，就开始吧。</p>
<p>Q: 今年最开心的事？</p>
<p>A: 没挂科，有奖励学分。</p>
<p>Q: 这么自信能过马哲？</p>
<p>A: 那是明年的事好吧。</p>
<p>Q: 还有什么值得开心的事吗？</p>
<p>A: 身体健康。 家人朋友都健康。</p>
<p>Q: 那么最伤心的事？</p>
<p>A: 婆婆去世了。</p>
<p>Q: 有多伤心？</p>
<p>A: 很伤心。</p>
<p>Q: 还有其它不开心的事吗？</p>
<p>A: 妈妈变老了，身体毛病多，不过今年做手术治好了肠胃。</p>
<p>Q: 现在在做什么呢？</p>
<p>A: 回答问题。</p>
<p>Q: 好吧，在这之前呢？</p>
<p>A: 准备音乐鉴赏考试。</p>
<p>Q: 会难吗？</p>
<p>A: 小菜一碟，相比马哲。</p>
<p>Q: 今年的大学生涯，过得如何？</p>
<p>A: 无惊无险。</p>
<p>Q: 修了些什么课程？</p>
<p>A: 多数是专业基础课，少量专业选修和公选课。</p>
<p>Q: 感觉掌握了相应知识吗？</p>
<p>A: 我只能说没挂科。</p>
<p>Q: 有认识新的朋友吗？</p>
<p>A: 没有。</p>
<p>Q: 为什么？</p>
<p>A: 太宅了，没办法。</p>
<p>Q: 不改变一下吗？</p>
<p>A: 付诸行动总是很难的，明年再来问这个问题吧。</p>
<p>Q: 有没有坚持运动？</p>
<p>A: 坚持了一段时间，主要是慢跑。说到运动，我想起一件事。</p>
<p>Q: 什么事？</p>
<p>A: 那个体能测试，引体向上我一个也做不了，然后我让计分的同学给我记了八个。</p>
<p>Q: 真的一个也做不了吗？</p>
<p>A: 真的一个也做不了。</p>
<p>Q: 这真是羞耻啊，这么差劲，怎么找女朋友。</p>
<p>A: 我也是这么觉得的。</p>
<p>Q: 你还说谎了。</p>
<p>A: 要是早知道重在参与，这就不会发生。</p>
<p>Q: 回到朋友这个话题上吧，你希望认识多一些朋友吗？</p>
<p>A: 自然希望。</p>
<p>Q: 希望认识什么样的朋友呢？</p>
<p>A: 异性朋友。。。</p>
<p>Q: 你没有异性朋友吗？</p>
<p>A: 有，太少了。</p>
<p>Q: 多少？</p>
<p>A: 我拒绝回答这个问题。</p>
<p>Q: 好吧，那么，再回到学业上，觉得自己的专业知识水平达到了什么地步呢？</p>
<p>A: 中等略偏上吧。</p>
<p>Q: 很快就大四了，能找到工作吗？</p>
<p>A: 现在肯定是不够的，明年要加把劲，继续努力。</p>
<p>Q: 找不到工作怎么办？</p>
<p>A: 找原因吧，肯定是自己还不够好。</p>
<p>Q: 会有紧张感吗？</p>
<p>A: 有一些。</p>
<p>Q: 对今年总结一下？</p>
<p>A: 肯定是悲伤的一年。</p>
<p>Q: 对明年有什么期待？</p>
<p>A: 身体健康，六级能过，不要挂科，学习多一些专业知识，认识多一些朋友。</p>
<p>Q: 好的，时间差不多了，这次的总结就到这里吧。</p>
<p>A: 谢谢。</p>
]]></description><pubDate>Wed Dec 25 2013 23:47:45 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/2013-annual-summary</link><guid isPermaLink="true">https://blog.wxsm.space/p/2013-annual-summary</guid></item><item><title>地心引力</title><description><![CDATA[<ul>
<li>很独特的设定。地球很美丽，宇宙很黑暗。</li>
<li>镜头经常走得很慢，处于宇宙中的各种物体也看似很慢，其实不然，经常在对比建立起来一瞬间就能感觉到可怕的速度。这样的镜头处理也让我觉得很独特。 而且对主角有很多又长又慢的镜头特写，然而影片的节奏并不慢。</li>
<li>片头直入主题，片尾紧凑收官，90分钟全无拖沓，难能可贵。</li>
<li>非常酷炫的3D效果，感觉又是一次突破，太空碎片往荧幕外飞的时候老夫的面部神经抽搐了很多下，从未有过的体验。感觉imax的地心引力会非常精彩！</li>
<li>女主遇到的连续挫折感觉已经超出了人类所能接受的极限，即使在最后一刻，依然存在挑战。</li>
<li>太空垃圾真的不会形成一个地球专属的小行星带吗？</li>
</ul>
]]></description><pubDate>Tue Nov 26 2013 00:55:47 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/review-of-gravity</link><guid isPermaLink="true">https://blog.wxsm.space/p/review-of-gravity</guid></item><item><title>留念</title><description><![CDATA[<p>玩了那么多年，经历了大大小小的版本更替，如今已脱胎换骨，与当年小小的一张地图相比已经面目全非，不得不说这也是一种软件的生命周期，或者开发模式。陪伴了老夫孤独寂寞的高中时光，消磨了大量宝贵的大学时间，亦由此对它产生了深厚的感情。如今大家各奔东西，在一起的时间越来越少，于是dota也渐渐变得没什么意思，偶尔上线也只是习惯所趋。</p>
<p>我还记得我玩的第一个英雄是胖子，那么第一把自然是坑队友了，然后下一把玩了个传说哥，大家都懂的。不过好在老夫war3功底雄厚，渐渐也有了起色，开始没打算继续下去的，是因为身边的朋友在老夫带领下居然也开始喜欢dota，于是大感欣慰，遂征战至今，主要也是因为当年3C实在前路渺茫。朋友不多不少，刚好足够开一间黑店，可惜连跪几乎已是命中注定的剧本，于是我又要批评一下达Q了，你TM能不能不要裸秘法。徐尘是老夫最喜欢的选手，低调不失华丽，实力与智商兼顾，还会拍马屁。至于贝伦同学尽心尽力辅助了这么多年，只能说辛苦了。椰子同学自从退伍归来后实力大减，简直成为团队毒瘤。。好吧开玩笑的。</p>
<p>从最开始的QQ平台开始，也不知道到底耍了多少把了，印象深刻的也没有多少，只能说记性不好。无数个白昼与通宵，就在这上面一点一点的消逝去了，这里却留下不少回忆，比如小林被他不知道什么亲属拽回家去的那晚，以为是个抢劫的，老夫差点就拍案而起。还有一次和徐尘通宵，第二天一早老夫回学校睡觉，下午睡醒吃饭回到网吧看到他居然还坐在那里继续操作，那个哭笑不得。记得那时候的水饺，炒饭，泡面，汽水，和各式各样的FirstBlood。</p>
<p>如今大势已去，dota虽然还在发展，却已不适合你我，只能当做茶余饭后之娱乐了。不过也好，人总要成长。</p>
]]></description><pubDate>Sun Oct 27 2013 23:30:04 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/some-memory</link><guid isPermaLink="true">https://blog.wxsm.space/p/some-memory</guid></item><item><title>无题</title><description><![CDATA[<p>时间过得真快，转眼就大学三年级了，两年前作为新生的各种场景依然历历在目，像是昨天一样，当年的小软工如今已几乎是大师兄，不得不时时拷问自己两年来到底学到了什么，学到了多少，有什么资格。去年还没有什么感觉，如今比较强烈了。而且也开始想两年后我会在哪里。实在是前路茫茫啊。是工作呢，还是要去读研比较好呢。我个人还是倾向继续读书。唉，不知不觉就大龄青年了。真是岁月催。</p>
<p>大学读下来，从前很多选择也慢慢觉得如果再理性一点的话，或许会有变化。不过人还是脚踏实地的好，往事已去不再追。今年婆婆去世了，即使到现在还是很难接受的事实，不过我也知道时间带走一切，不知哪刻自己也将被带走，能做的只有珍惜。</p>
]]></description><pubDate>Mon Sep 09 2013 22:50:29 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/untitled</link><guid isPermaLink="true">https://blog.wxsm.space/p/untitled</guid></item><item><title>莎莎和凯瑞的故事</title><description><![CDATA[<p>作者：Loolorl_lar@qq.com</p>
<p>角色：莎莎 凯瑞</p>
<p>凯瑞坐在广场的椅子上。嘴上叼着烟，手上点着烟，动作很慢，也很稳。</p>
<p>莎莎坐到了凯瑞旁边，凯瑞没有说话，也没有动作。</p>
<p>莎莎：我可以坐这里吗？</p>
<p>凯瑞：...</p>
<p>莎莎：“能不能借个火，帅哥？”</p>
<p>莎莎从外套的口袋里取出了一支皱巴巴的香烟叼在嘴上，微笑着凑到了凯瑞的身前。</p>
<p>凯瑞把玩着火机，</p>
<p>旁白：凯瑞不是帅哥，至少他认为不是。</p>
<p>莎莎看了凯瑞一眼，眼睛眨巴了几下，继而用手托住烟，脑袋前移，把嘴上的烟凑到了凯瑞的烟头上点烟随后，莎莎深深地吸了一口，然后对着凯瑞吹了一口气。脸上的笑容也顷刻间显得很是妩媚。</p>
<p>莎莎：“我叫莎莎。我喜欢…强壮的男人！”</p>
<p>凯瑞静静地叼着烟，木然望着前方，没有说话。</p>
<p>旁白：凯瑞也不是强壮的男人，众所周知。</p>
<p>莎莎用手指夹着烟说：“我来自未来。”“回到这里呢…是想找个人，问几个问题。”</p>
<p>莎莎转过头去看了一眼凯瑞，凯瑞没有动。</p>
<p>莎莎：“我的工作证…没有带，因为呢…那张工作证是2015年才制出来的。所以呢…我带不过来。”</p>
<p>莎莎又转过头去，看着凯瑞说“我说的话，你相信吗？”</p>
<p>凯瑞摇了摇头，依然注视着前方。</p>
<p>也许是看到他终于有了动静，莎莎仍咧开嘴吃吃地笑了。</p>
<p>莎莎：“在未来，我见过你。”</p>
<p>莎莎吸了一口烟说道：“那时，你比现在要老。穿着咖啡色的T，黑色的牛仔裤，还有…白色的球鞋。”</p>
<p>凯瑞忽然转过头看了莎莎一眼，旋即又低头看了看自己的脚，脚上是个黑色的包，黑色的包完全覆盖了他的脚。</p>
<p>莎莎：“现在，你相信了吗？”脸上带着玩味的笑容。</p>
<p>凯瑞点了点头</p>
<p>旁白：他确实穿着咖啡色的T，黑色的裤子和白色的球鞋。</p>
<p>莎莎“那我们现在就开始吧！具体内容是：我问，你答。OK？”</p>
<p>凯瑞沉思片刻，又点了点头。</p>
<p>莎莎“今天早上你去了哪里？”</p>
<p>凯瑞“饭堂”</p>
<p>莎莎“去做什么？”</p>
<p>凯瑞“吃饭”</p>
<p>莎莎“然后…还去了哪里？”</p>
<p>凯瑞“银行”</p>
<p>莎莎“做什么？”</p>
<p>凯瑞“取钱”</p>
<p>莎莎“取了多少？”</p>
<p>凯瑞“五百。”</p>
<p>莎莎“dollar?”</p>
<p>凯瑞摇了摇头。</p>
<p>莎莎“那是什么？”</p>
<p>凯瑞没说话，陷入了沉思。</p>
<p>莎莎望了他半天，从外套口袋里用两只手指夹出了一只纸叠的爱心，一只火红的爱心，背面印着火红的毛泽东。莎莎把这张爱心凑到了凯瑞的眼前晃了晃。</p>
<p>莎莎“是这个吗？”</p>
<p>凯瑞盯着那只爱心，点了点头。</p>
<p>莎莎：“它叫作人民币。”</p>
<p>莎莎笑了笑。</p>
<p>凯瑞：“哦。”</p>
<p>莎莎：“然后呢？接下来你又去干嘛了？”</p>
<p>说话间莎莎随地扔掉了香烟又从那个口袋里掏出了一个记事簿，上面别着一支钢笔。</p>
<p>凯瑞“充卡”</p>
<p>莎莎“什么卡？”</p>
<p>凯瑞“校园卡”</p>
<p>莎莎“额..什么是校园卡？”莎莎转过头来盯着凯瑞，一脸好奇。</p>
<p>凯瑞“就是在学校必须要有的卡。”</p>
<p>莎莎“为什么必须要有呢？”</p>
<p>凯瑞“因为…学生是人。人都需要吃饭。”</p>
<p>莎莎“哦~呵呵，我懂了，就是用来吃饭的卡？”</p>
<p>凯瑞摇了摇头。</p>
<p>莎莎感到奇怪，皱了皱眉头</p>
<p>莎莎：“用来…在学校里面吃饭的卡？”</p>
<p>凯瑞点头。莎莎不禁莞尔一笑。</p>
<p>莎莎“那…你一天用五百元？”</p>
<p>凯瑞摇了摇头。</p>
<p>莎莎“两天？”</p>
<p>凯瑞，没有了动作，也没有说话，复归沉默。</p>
<p>莎莎“三天？四天？”</p>
<p>凯瑞“一个月。”凯瑞说完，朝莎莎深深看了一眼。</p>
<p>莎莎“哦！”莎莎有些悻然</p>
<p>莎莎“额…一个月五百…够吗？”莎莎向另一边别过头，眉头皱了皱。</p>
<p>凯瑞“够！如果，我不用这笔钱买酒的话…”</p>
<p>莎莎“那…你什么情况下会去买酒喝？”</p>
<p>凯瑞“心情不好的时候。”</p>
<p>莎莎“哦。那…如果，你突然间心情很坏…买很多酒，那点钱岂非不够？”莎莎坏笑。</p>
<p>凯瑞：“不会。”</p>
<p>莎莎：“为什么？买酒不用花钱？”</p>
<p>凯瑞摇了摇头，“心情不好，一定是卡上多出钱了。”</p>
<p>莎莎：“那要是少了呢？”</p>
<p>凯瑞:“那我…高兴得要命！”</p>
<p>莎莎表情一滞，“那…然后怎么办？“</p>
<p>凯瑞:“然后几天几夜，不吃不喝。”</p>
<p>莎莎：“你是不是人？”莎莎又笑了。</p>
<p>凯瑞点了点头。</p>
<p>莎莎：“人是不是要吃饭？”</p>
<p>凯瑞又点了点头。</p>
<p>莎莎：“那…你若是几天几夜不吃不喝，那岂不是很要命？”</p>
<p>凯瑞再次点了点头。</p>
<p>莎莎：“所以，你会开心得要命？”</p>
<p>凯瑞呆了半响，再次点了点头。</p>
<p>莎莎：“呵呵呵…”莎莎咧开嘴，吃吃地笑了。</p>
<p>良久。</p>
<p>凯瑞：“你问了我那么多，你要付报酬。”凯瑞突然转过头，盯紧了莎莎外套上的口袋。</p>
<p>莎莎：“Okay，不过…你得给我开收据！”莎莎迎向凯瑞的目光，面带着微笑。</p>
<p>凯瑞转过头去，再次木然望着前方。</p>
<p>旁白：他开不出收据。</p>
<p>莎莎：“你想要什么报酬啊？”</p>
<p>凯瑞犹豫了很久，然后转过头来，用夹着燃尽的烟头的手点了点自己的嘴唇</p>
<p>凯瑞：“我要你跟我亲嘴。做个DEEPKISS.”</p>
<p>沉默。良久的沉默。</p>
<p>莎莎做了个深呼吸，讪笑着看了看他。</p>
<p>莎莎：“我…还没有问完呢。”</p>
<p>凯瑞：“这是预付金，要么你现在闭嘴，离我远点。”</p>
<p>莎莎：“啊…”莎莎神情一滞。</p>
<p>莎莎：“那好吧！”说着她脸上已露出了微笑，慢慢地着凯瑞靠近，越是靠近，她的笑容就越深。当她的嘴唇和凯瑞的嘴唇完全贴到一起时，那已然是一个深深的富有深意的笑容。</p>
<p>旁白：那一刻，凯瑞无法呼吸。虽然他的嘴被封住了，但他还有鼻子。可是他发现连自己的鼻子也好像已被封住了，他完全窒息了。</p>
<p>旁白：凯瑞不是帅哥，他做不到让女孩子窒息，凯瑞也不是强壮的男人，他无法忍受这样的窒息，哪怕是一秒都无法忍受。他瞬间转开了脸。</p>
<p>此时，莎莎的笑意更浓了。</p>
<p>莎莎：“我们已经亲了嘴咯！做了个DEEP KISS.你可别忘了。”莎莎得意地笑了。</p>
<p>凯瑞点了点头。</p>
<p>莎莎：“好了…我们继续吧！”</p>
<p>凯瑞眨了眨眼。</p>
<p>莎莎：“这是你地初吻吗？”</p>
<p>凯瑞摇了摇头。</p>
<p>莎莎：“不是？噢！我的！”莎莎用手盖住额头，似是有些气恼。</p>
<p>凯瑞：“你的？”</p>
<p>莎莎：“我的…错。省略语，未来很流行的。”莎莎重新敞开脸，勉强笑了笑。</p>
<p>凯瑞：“你的…是什么？”</p>
<p>莎莎：“我以为…你这样的人…你身边的女孩子应该会很怕你的。”莎莎苦笑道。</p>
<p>凯瑞：“怕得要命。”</p>
<p>莎莎：“她们一定不敢跟你说话。”</p>
<p>凯瑞：“一个字都不敢。”</p>
<p>莎莎：“真的？”</p>
<p>凯瑞点了点头。</p>
<p>莎莎：“可是…你竟然已经跟其他女孩子接过吻了！”</p>
<p>凯瑞：“没有。”</p>
<p>莎莎：“没有？那…你跟男孩子接过吻？”莎莎的笑容顷刻间变了，变得十分玩味。</p>
<p>凯瑞：“不是！”</p>
<p>莎莎：“那你的初吻…是给谁啦？”</p>
<p>凯瑞：“一只猫。”凯瑞很平静。</p>
<p>莎莎：“呵呵…”莎莎又吃吃的笑了…</p>
<p>莎莎：“母的？”</p>
<p>凯瑞摇了摇头。</p>
<p>莎莎：“公的？”</p>
<p>凯瑞又摇了摇头。</p>
<p>莎莎：“额…既不是母的…又不是公的？”</p>
<p>凯瑞还是摇了摇头。</p>
<p>莎莎依旧在笑，笑得很甜。</p>
<p>又是良久。</p>
<p>凯瑞：“我们是不是认识？”凯瑞问莎莎。</p>
<p>莎莎：“我们？”</p>
<p>凯瑞：“嗯。我们，未来。”</p>
<p>莎莎：“当然认识！”莎莎看着凯瑞，肯定地回答。</p>
<p>凯瑞：“那…我们。。。有没有…上床…”凯瑞脸色有些发红</p>
<p>旁白：我们是恋人吗？他原本想这样表述，但却发现这句话比脱口而出的那句更难表述。</p>
<p>莎莎：“额…”莎莎表情一僵，怔怔地看了看他。</p>
<p>凯瑞：“也许…有吧…我和很多人都上过了。额…绝大部分都是女人。”莎莎哂笑着。</p>
<p>凯瑞：“我不是女人。”</p>
<p>莎莎：“你当然不是女人。”</p>
<p>凯瑞：“嗯！”凯瑞重重地点了一下头。随即两人都陷入沉默，感到十分尴尬。</p>
<p>过了一会儿，莎莎又转过头看着凯瑞</p>
<p>莎莎：“你想知道未来吗？”</p>
<p>凯瑞木然看着前方，点了点头。</p>
<p>莎莎：“既然你想知道，你可以去探索。”莎莎深深注视着他。</p>
<p>凯瑞：“我…我一无所知。”</p>
<p>莎莎：“其实，那些东西都是有迹可循的，未来都是来自过去，你只要看得到过去，就可以推测未来，很简单！我们来试试！”</p>
<p>莎莎：“比如，你现在看着自己的样子，想象一下你将来会是什么样子。”说着莎莎从外套口袋里掏出了一个化妆镜，打开并凑到了凯瑞地眼前。</p>
<p>莎莎：“看看你现在的样子，你想想…随着时间一点一点地流过，你的脸上会慢慢地…长出胡子，还有你的脸型…会变得…轮廓分明…你的眼眶…会陷下去……然后…想出来了吗？”</p>
<p>凯瑞点了点头，表情仍旧木然。</p>
<p>莎莎：“是什么样？快告诉我。”莎莎看着他，十分期待。</p>
<p>凯瑞：“两个眼睛，两个耳朵，…一个鼻子，一张嘴巴。”呆呆地说。</p>
<p>良久，莎莎做了个深呼吸，浅浅一笑说：“对！就是这样。”</p>
<p>良久。还是良久。</p>
<p>凯瑞：“过去的你…是什么样子？”凯瑞转过头看着莎莎。</p>
<p>莎莎听了笑容瞬间褪去。说：“不知道！”</p>
<p>凯瑞：“嗯？”</p>
<p>莎莎：“我不想去想。我再也不想回到过去，包括我的思想。”莎莎变得神情冷漠，神色决然。</p>
<p>凯瑞心头忽的一颤，尔后又复归沉默。</p>
<p>又是沉默的良久。</p>
<p>凯瑞：“那…现在，现在你是什么样子？”凯瑞低着头，盯着脚下。</p>
<p>莎莎：“现在？就是…这个样子。”她笑着站起身来，张开双手站到了凯瑞的身前，转了一个圈，最后面对他，深深凝望。眉眼如水，双颊如醉。</p>
<p>凯瑞看着莎莎，看的有些痴。他突然发觉好像喝醉了，而且醉的厉害。</p>
<p>凯瑞：“你现在在哪里？”怔怔问道。</p>
<p>莎莎笑得更甜。她沿着石椅坐下，靠在了凯瑞肩膀上，凑到了他的耳旁，像说悄悄话一样说：“我在这里。”</p>
<p>凯瑞呆了。没有说话，也没有动作。</p>
<p>他们就这样相互依偎着，仿佛谁也不愿意离开谁。</p>
<p>凯瑞：“你…未来的丈夫，他是…什么样？”凯瑞的脸很红。心跳得很快。</p>
<p>而莎莎却仿佛睡着了一样，久久没有动静，直到真的过了很久以后，她才懒洋洋地抬起头，一边缓缓地睁开眼睛。说：“你是说…我的未婚夫？”凯瑞打了个冷战“他很开朗、阳光，很强壮、高大，很帅气、很有风度。”</p>
<p>凯瑞依旧沉默，他的脸色已变得苍白，嘴唇也十分干涸。他咂巴一下嘴唇，依旧望着前方。面无表情。莎莎一脸平静，深深地望着他。</p>
<p>莎莎：“你是不是渴了？”</p>
<p>凯瑞点了点头“我想喝酒。”</p>
<p>莎莎：“抱歉…我这里没有酒。”莎莎深感歉意，向后倒靠在椅背上，头也顺势低下。</p>
<p>莎莎：“你今天…心情不好？”</p>
<p>凯瑞默不作声，也没有动作。</p>
<p>莎莎：“是不是…你校园卡上的钱多出来了？”莎莎开了个玩笑。笑得很勉强。</p>
<p>凯瑞摇了摇头。</p>
<p>莎莎：“怎么了？”</p>
<p>良久</p>
<p>凯瑞忽然低下了头，沉默了一会儿。“我以为…将来我会娶你。”</p>
<p>莎莎的眼皮瞬间跳了一下。随即也是沉默良久。</p>
<p>莎莎：“我已经…问完了”莎莎抬起头“我该走了。”</p>
<p>凯瑞：“去哪里？”凯瑞转过头看着她。</p>
<p>莎莎：“去…未来。从哪里来，就回哪里去。”</p>
<p>凯瑞：“你不能走。”凯瑞忽然表现得有些慌乱。</p>
<p>莎莎：“为什么？”</p>
<p>凯瑞：“因为”凯瑞静下来，想了想说：“你还欠我一份报酬。”</p>
<p>莎莎神情一滞，犹豫了一下，笑着说：“那…我再陪你说说话？”</p>
<p>凯瑞摇了摇头。</p>
<p>莎莎：“你不喜欢和我说话？”</p>
<p>凯瑞犹豫了一会儿，再度摇头。</p>
<p>莎莎：“那你想要什么？”</p>
<p>凯瑞沉默了，沉默了好一会儿，他又低下了头，面色绯红，喃喃道“嫁给我。”</p>
<p>“呵呵…”莎莎吃吃地笑了，笑着笑着神色又如变魔术般变得十分窘迫。</p>
<p>莎莎：“可是…人家不方便。”</p>
<p>凯瑞：“为什么？”凯瑞奇怪地看着莎莎。</p>
<p>莎莎：“没有为什么。女孩子就是有几天会不方便。”莎莎莞尔一笑，“等下次好吗？下次，我带你去一个没有人认识我们的地方，然后你做你想做的事，我也可以做我想做的事，这样岂非两全其美？”莎莎望着他，神情中带着些许期盼。</p>
<p>凯瑞：“我现在就要。。嫁给我！”凯瑞深深地看着莎莎，无力地说道。莎莎笑了。</p>
<p>莎莎：“……SORRY! IWILL BE MARRY!”她苦笑着看着凯瑞</p>
<p>凯瑞转过头，深深地吸了口气说：“他是个鸡巴脸！”</p>
<p>莎莎：“不可以当着女孩子的面辱骂她的丈夫哦！”莎莎笑着。</p>
<p>凯瑞：“他就是个鸡巴脸”凯瑞很平静，有气无力。</p>
<p>莎莎：“呵呵…哈……“莎莎捂着嘴哈哈大笑。</p>
<p>凯瑞：“如果，你不喜欢他，我去杀了他。”凯瑞冷冷地说。</p>
<p>莎莎笑声顿时停住，她沉思良久，紧闭双眼，淡淡地说：“我喜欢他”</p>
<p>凯瑞又深深地吸了口气。</p>
<p>莎莎：“我会跟他结婚，成为他的妻子，会和他生一大堆孩子。”</p>
<p>凯瑞再次深深吸了口气，几乎要把他的肺都涨裂了，这使他感到巨大的压力，但他不敢挺，他不敢呼吸，他怕他一停下就会忍不住掉泪。</p>
<p>莎莎：“你愿意参加我的婚礼吗？”莎莎再度微笑“我们既然认识，那我要做新娘了，你就应该来送送我，对吗？”</p>
<p>凯瑞：“认识？”</p>
<p>莎莎：“你不记得了？”</p>
<p>凯瑞先是沉思，随即摇了摇头。</p>
<p>莎莎：“不管你记不记得，那终究是事实。你去吗？”</p>
<p>凯瑞又摇了摇头。</p>
<p>莎莎：“你不肯去？”</p>
<p>凯瑞再次摇了摇头，心中默念：因为我不是他。他没有说出来，此时，他已说不出任何话来。</p>
<p>莎莎：“我知道你很难过。”莎莎看着他，神情有些忧伤。而凯瑞仍是不停地摇头。</p>
<p>莎莎：“将来也许我会开一间酒吧，做一个当垆卖酒的老板娘”莎莎自顾的说道，“那时你若还记得我，你也许也会来我这里大醉一场的。”</p>
<p>凯瑞点了点头。会的。</p>
<p>莎莎：“不过你一定要记得穿咖啡色的T，黑色的牛仔裤，还有白色的球鞋。因为…我怕我会认不出你…”莎莎已经带上了哭腔。</p>
<p>凯瑞又是重重地点了一下头。</p>
<p>独白：会的！</p>
<p>莎莎：“也许在你醉倒之后…我会偷偷没地亲你，一个DEEP KISS !”莎莎已经流泪。</p>
<p>DEEP KISS 。凯瑞的思绪完全沉入其中，回想起刚才的那个吻，那仿佛是个很久很久以前。他恍惚觉得其实刚才他们两个什么都没有发生，一切都发生在很久很久以前，他更愿意认为他和莎莎早已认识，在很久很久以前就已经认识。</p>
<p>而现在，他想象着很久很久以后，他穿着和今天一样的行装，咖啡色的T，黑色的裤子，白色的鞋，醉倒在酒吧，醉倒在她怀里…只是偶尔思绪错乱，脑海中瞬间出现的竟是莎莎身穿白色婚纱翩翩而立的样子。白衣胜雪，胭脂双娥。</p>
<p>良久过后</p>
<p>“莎莎！”当凯瑞缓过来时，天色已暗。</p>
<p>他忽然感到很无力，周身都酸痛不已。但这一切并未使他在意。仅仅是和很久很久以前一样</p>
<p>，继续木然望着前方。</p>
<p>独白：“我去当你的伴郎。”</p>
<p>四周已空无一人，身旁也已空无一人，依稀可见的只有地上黑色的旅行包，旅行包下有被埋没的双脚。两枚燃尽的烟头，散发着暗香。</p>
]]></description><pubDate>Sun Mar 31 2013 21:39:13 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/story-of-shasha-and-kairui</link><guid isPermaLink="true">https://blog.wxsm.space/p/story-of-shasha-and-kairui</guid></item><item><title>意外之旅</title><description><![CDATA[<p>本来也没有抱很大希望，所以算是乐在其中。最让我开心的是看到了熟悉的人和事物，戒指坠地的声音依旧震慑人心。甘道夫虽然说年轻了六十岁但是看起来更老了，另外就是大招的冷却时间明显缩短了。然后剩下的内容，基本可以用“吃饭睡觉打兽人”概括， 而且可以看出六十年前的兽人智商还不太发达。有点像成龙大哥的风格，相比艰辛，更多的还是幽默。</p>
<p>这一次只能说中规中矩，如果想要惊世骇俗吃老本肯定是不行的了，我设想的话，既然都不搞原著了，那么第三部不如来个惊天大逆转，矮人勇者斗巨龙团灭，甘道夫和比尔博灰头土脸踏上归乡之路，这叫道高一尺，魔高一丈！</p>
]]></description><pubDate>Wed Feb 27 2013 01:26:36 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/review-of-an-unexpected-journey</link><guid isPermaLink="true">https://blog.wxsm.space/p/review-of-an-unexpected-journey</guid></item><item><title>仙五感想</title><description><![CDATA[<p>前两天觉得实在无聊，花了50人民币买了个仙5KEY，并且挂一晚上同时下载了5和5前，本来打算都玩玩看的，现在有谁想要玩的吗我给你KEY，不过只有一个哦，而且是5不是最新的5前。不准备购买5前KEY了。</p>
<p>老实说我也还没有耍通关，大概是走了一半多一点的剧情，不过确实没什么耍下去的愿望了，于是就广泛观察了一下广大玩家的意见，基本还是毁誉参半。支持者的观点也基本还是那几句，你不懂仙剑，你不懂感动，你不懂传承。反对的人，提出意见的人和建议改革的人一般都会被喷的很惨，尤其是那些用国外优秀游戏作品和仙剑做比较的，反观这个人群却能够更加理性的和广大支持者辩论。当然从四代开始正版的销量也成为了广大玩家所认可的仙剑成功的标志之一，在我个人看来这是一个很可怕的现象，如果仙剑系列的开发者也认为这是他们作品的一个成功标志的话那么这个游戏就彻底完蛋了。中国人开始买正版仙剑和上海软星的解散有直接关联，仔细想想是能够知道为什么的，这是一种民族情怀，不是因为它成功，而是希望它成功，希望终有一天我们的游戏文化也可以走出国门，而不是占山为王固步自封一万年。仙剑是国产游戏业的第一品牌，谁都希望它能够越做越优秀，这点还是统一的。</p>
<p>那么我也来说一说对5代的感想。</p>
<p>首先仍然是很传统的人设和故事，大大咧咧的男主角，误打误撞认识了一位知书达理的女主角，然后还有一个英俊帅气的男二号，和另外一位蛮横霸道的女主角，一共是四个人。然后就是混杂着各种纠缠不清的关系的剧情发展，到最后男一号自然是打败了为害人间的大魔头，但是却牺牲了其中一名美丽可爱的女主角，于是又引发了各种凄美的爱情故事。恩，至于5代后面的剧情我就是看攻略得来的了，暂时还没有亲身体会。这个主角阵容几乎从它祖宗开始就是这个模样，俊男美女闯六界，所以也没什么好奇怪的，这个剧情嘛也就这个样子，广大人民群众喜闻乐见。然后就是回合制战斗模式加强加强再加强版，仙剑虽然每一代都是回合制，但是又每一代都有新花样，这个新花样也会成为正式发布前的宣传重点之一。至于这一代的亮点，第一，我个人认为是李逍遥的回归，毕竟这一代是姚仙的孩子，给足了逍遥哥戏份，对于一代迷的我来说，很满意，第二，就是它的剧情配音，感情丰富，声调饱满，非常幽默，十分满意，逗笑了我很多次。5前对于角色数量方面似乎有很大创新，可能是基情与百合的发展使得游戏也不得不跟上时代的步伐。</p>
<p>然而这次我想说的重点不在这里。</p>
<p>一代的画面是仙剑系列永远的痛，于是后代仙剑人从来没有放弃过对画面的追求，从一代的数格子，到二代的线条2D，到三代的方块3D，再到4代5代的真3D。5代的画面在我看来已经非常成功了，各种光影，渲染，迷雾，反射，应有尽有，色彩鲜艳，场景宏大，角色的模型也是很有进步，丝毫没有愧对玩家的期待。问题就出在这里，在这如诗如画的梦幻般的游戏过程里，我完全感觉不到游戏制造者的诚意。</p>
<p>就提几点吧。都是些细节。</p>
<p>第一，仙剑奇侠传系列的主角们，从1995年至今，嘴巴从来就没有动过，但是他们却会说话。难道这也是特色传统之一吗？不要跟我说以前还没有这样的技术，李逍遥在1995年不用动嘴巴，到了2013年仍然是不用动嘴巴，这说明他天生就不用动嘴巴。腹语术。</p>
<p>第二，太空步无处不在，真的又好气又好笑，尤其是当角色上下楼梯的时候，已经不能用不自然来形容了，简直是灵异事件。当然，毫不客气的说，这也是传统之一。</p>
<p>第三，这点很重要，游戏角色永远只有屈指可数的动作，然而制作人又想要用这些动作来表达复杂多变的游戏情节，于是后面是怎样的一组情形就不必多言了。这个情况是从仙剑系列踏入3D，也就是第三代开始的，当时由于技术限制，我并没有太大的关注这个问题。可是到了今天游戏制作人仍然没有一丝一毫想要改进的意思，一方面想要让角色尽量生动，一方面又偷工减料不制作实时动作，让我感到非常可笑。一个人进门怎么表现呢？凭空消失呗。一个人给另外一个人一件事物怎么表现呢？手突然平举呗，事物还是腾空的呗。像这样的画面堂而皇之的出现在近距刻画中，在今天我觉得难以接受。</p>
<p>第四，历代都在期盼的角色实时换装系统千呼万唤不出来，再飘逸的服饰装备设计也失去了意义。不要说换了武器能体现，如果连这个都不能体现，我早喊QNMLGB了。</p>
<p>第五，角色进入居民屋可以翻箱倒柜，顺手牵羊，这个是真正的传统，我不知道姚仙在今天对于这个设计是怎么样的一个看法。</p>
<p>还有很多，不列举了，关于这些问题，只希望仙剑开发者有朝一日能发现并解决之，这将是对所有仙剑爱好者极大的鼓舞。这些就是细节，细节就是诚意。</p>
<p>至于我为什么半途就失去了将仙5通关的愿望，并不是因为游戏性，仙剑系列每一代的游戏性都半斤八两，只不过由于画面不断提高，所以才显得它的游戏性愈加飘渺，想要体验游戏性的话膝盖中箭才是最佳选择。我只是对这一代的主角全无好感而已。当然，对四代的主角也全无好感。这两代的人设简直就是同一个妈生的。</p>
]]></description><pubDate>Wed Feb 13 2013 11:25:31 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/review-of-cp5</link><guid isPermaLink="true">https://blog.wxsm.space/p/review-of-cp5</guid></item><item><title>最近状态不好</title><description><![CDATA[<p>开学两周以来身体真的不太好，感觉又和高三后期差不多，不过好在时间没有那么紧，每天可以抽一点两点时间出来锻炼，到现在也感觉有了那么一些好转。霍香正气丸吃了没有用，以后再也不买了。不敢去看医生，实在看不起，重点是看了也白看。</p>
<p>本来平常的话也没什么，坏在上学期挂了两科，明天就要补考去，可惜真的没有精力很认真的看书做题所以它要重修就重修吧，大四上多几节课我也不是很在乎。不过从今往后大概真的别挂科了。毕竟没有班长大人的魄力，我还是图样啊。现在饭堂卖的东西也比以前干净很多了，也有面条和粥，而且还很便宜，所以应该不会像以前那样困难，虽然饭吃了可能还是会有点问题。这两周以来嘴巴都感觉特别特别苦，会想喝汽水，会想吃雪糕，可是肚子又胀胀的，不太敢动那些。忌生冷烟酒辛辣油腻，知道的，奶不能喝，青菜少吃，什么什么的，都还记得，所以妈你不用担心我。我有分寸。你要多注意你自己。每次你跟我说晚上痛得睡不着都让我非常揪心。</p>
<p>晚上经常会小发烧，可能是炎症吧之前真没考虑到。今天好些，没有。所以最近都穿长袖示街。偶尔还是会感到冷和孤独，不过没有高中那么强烈。今天吃了一天宿舍菜，中间还被小吓一跳，那个新买的电磁炉水都没煲开就怒放两炮，然后随着一丝烧焦的味道就哑火了，还好后来又神奇复活以不至于没东西吃。吃完以后十分想念婆婆和大姨，我想吃炸茄子和葱条和腌菜艾米果…</p>
<p>希望可以好起来。</p>
]]></description><pubDate>Sat Sep 15 2012 21:33:11 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/not-feeling-good-recently</link><guid isPermaLink="true">https://blog.wxsm.space/p/not-feeling-good-recently</guid></item><item><title>多年</title><description><![CDATA[<p>作者：Loolorl_lar@qq.com</p>
<blockquote>
<p>最近玩上各种经典网络游戏，走火入魔。琐事缠身，生性懒惰，故停更至军训结束。附赠此篇，作于高三，聊表歉意。</p>
<p><em>loolorlar</em></p>
</blockquote>
<p>系统给我的第一个任务是去偷鸡，尽管我很不情愿一出场就当小偷，但是没有办法，系统说我得去偷。于是我就得去偷。</p>
<p>当我接到第二个任务时我正在吃着自己偷来的鸡，我记得那时候我手持一只大黄鸡叫小二给我做出个一鸡三儿吃。小二是个灿若桃花的姑娘，明眸善睐，朱唇贝齿。她对我莞尔一笑说：&quot;客官是新手吧，我看你这只鸡就知道了。我们这家客店就是为新手杀鸡烹饪的，只是客官来得不巧，这几天的新人甚多，你这只鸡可能要等到三天之后才能吃得上。&quot;那时候我环顾四周，全是和我衣着相同的人，他们对着自己的鸡狼吞虎咽，一时之间我以为是多个自己。</p>
<p>于是我就坐在客店外等，月色若墨，或进或出的人流在我身旁穿行，他们大多和我身着相同的服饰，并人手一只大黄鸡。那时候我是惊奇的，我诧异于王大娘家怎么会有这么多鸡来供人偷取。我忽然想起过去的一个星期里根据任务的提示我是费劲千辛万苦才偷到那只鸡的。我清晰地记得任务栏里说村里有一个姓王的大娘。她家的那只鸡快成妖了，系统需要一个有识之士把她家的鸡偷走。把她家的鸡偷走，从而确保一方平安。</p>
<p>可是王大娘家到底在何方？从我进游戏的第一天起就对这个问题甚是疑惑。为此我认真地察看任务介绍不下百次。我记得那是在第一天的傍晚，那时候天际彩云烧红，我在寂静的巷弄里游荡。那是我第一次见到的新手，他身着与我相同的粗布服饰，那时候他倚倒在墙角吃着任务卷轴。</p>
<p>多年后我想起了那个甚是荒谬的理由。我记得那时候我坐在他身旁与他谈起。他说他是找了王大娘家一个月。那时候天色向晚，他在我身旁苦笑。他说：&quot;你这算什么？我看任务介绍都一千遍了，可是王大娘家在哪儿我还是不知道。&quot;然后他拿着剩下的任务卷轴往嘴里喂，他说：&quot;也许我把它吃完之后系统就会提示了。&quot;他指着我的任务卷轴说：&quot;其实它也不是很倒胃口，你不吃吃看？&quot;</p>
<p>当一个星期后我吃着鸡时也在想着同样的问题，我想要是我当时真的吃了任务卷轴，也许系统还真会提示，毕竟这么多人都偷到了鸡，这里面一定有窍门。</p>
<p>多年后当我想起第二个任务时我正在为国王守城，我清晰地记得那是个风雨潇潇的夜晚，那时候我根据任务的提示在村东三百里以外的僵尸洞蹲守。任务说，村东三百里以外的僵尸洞妖气冲天，洞口的僵尸门三天开一次。系统希望有一位传说中的英雄能前去斩妖除魔。在洞外的那些天我还反复回顾任务的特别提示，提示上说：任务危险！建议组队前行！</p>
<p>那些寒风凛冽的夜晚我和两个新手队友在洞外害怕得瑟瑟发抖，我们以为这是一次九死一生的冒险。</p>
<p>多年后我仍是记得与殷殷的对话。那是我们在蹲守了三天三夜的僵尸洞外，我见得她唇色暗紫，忐忑不安。她说：&quot;我听人说这洞里的僵尸喜欢吃人的心脏，尤其是像我这样心胸宽广的。&quot;她说：&quot;其实我是很害怕的，我还没有成亲，还有王大娘的那只鸡没吃完。&quot;那时候我正闭着眼睛在洞口祈求菩萨保佑，当听到王大娘家那只鸡时我转过头来问她：&quot;王大娘家你找了多久，我足足找了一个星期。&quot;</p>
<p>于是我便回想起王大娘的家，自从那天我看着那新手把任务卷轴吃完后我便决定不再看任务提示。我记得那是在第二天电闪雷鸣大雨倾盆的早晨，那时候我敲开居民家的门，我向开门的小孩询问王大娘家在何处。那时他看着我，他说：&quot;我想吃包子.&quot;</p>
<p>多年后当我看着那个在皇宫一夜未眠的国王时我不免苦笑，我忽然想起那天清晨我来回于包子店和孩子家数十次，最终将一张张悲愁填满了空地。孩子说：&quot;其实我并不是真的想吃包子，只是系统是这么给我设定的，所以我得说想吃包子。&quot;</p>
<p>从那之后我便遇到多个这样的NPC，虽然我只是想问出王大娘家在哪里。可到了第二天后我终于不问了，因为多天来我听得的都是一些答非所问的话语。那时候我跑到县令老爷的人口薄上一一寻觅。</p>
<p>多年来我对那简单的结果一再叹息。我记得那天翻开户口簿时我才发现，这个地方是王家村，每位妇女都是王大娘。</p>
<p>那时候殷殷看着我忽然笑起来，她说：&quot;我就随便偷了一只，任务就这么完成了。&quot;尽管事隔多年我还是铭记，当殷殷说完这句话时我听得从身后传来石块移动的声响，那是一声声恐惧在我们耳旁迂回。</p>
<p>多年前当我们刚刚得知尸洞开启时另一个组员就当场倒地，我和殷殷见得他面色惊恐，明显是被吓破胆而死了。对此我和殷殷都感到愤恨，我们一致以为有恐惧症至少得事先和我们说明。而那之后的事情确实让我们毛骨悚然。</p>
<p>我记得当我们走在洞口走廊时我被一只手抓住了，那时候我和殷殷看着我脚下干瘪的僵尸冷汗直冒，当时我见得殷殷瘫倒在地瑟瑟发抖，我问她说：&quot;是不是我就要死了，是不是我就要死了？&quot;</p>
<p>多年后我想起时扔无比恐惧。那时候脚下的僵尸把我再次抓紧，我看着它空洞的眼神几乎晕厥。在持久的恐惧后只听到他幽幽地重复两个字：&quot;救命，救命。&quot;</p>
<p>多年后当我和殷殷在城门守卫时我又一时想起，我说：&quot;那时候你怎么不救它？&quot;她说：&quot;它是僵尸，系统说该杀，所以我就把它杀了。&quot;</p>
<p>多年前的第二个任务是我们意想不到的，当我们最终完成任务时我们便为那个被吓死在洞外的队友感到惋惜。那时候我们拿着僵尸王掉落的凭证走出洞穴。那时久违的阳光照在我们脸上，我见到殷殷脏乱的脸颊在阳光下笑得灿烂。然后我看着手里的任务凭证黯然神伤。</p>
<p>我记得那个曾在我们眼里凶险万分的僵尸洞里，在我们曾以为壮士一去不复返的任务中，我们走进最终的BOSS殿堂时，视野里超出臆想的场景令我们震撼。照事后殷殷的说法，她以为在BOSS殿堂里至少得有一只杀人如麻、狂性大发的BOSS僵尸。她说：&quot;我还做了随时被秒掉的心理准备。&quot;</p>
<p>事与愿违，多年后我深深为此感叹。</p>
<p>当我们见到BOSS殿堂的场景时我听到殷殷的呓语，她说：&quot;哇靠！&quot;那时候我们见到殿堂里挤满了前来做任务的人，我和殷殷被挡在了不知道多少层的人群外围。多年后我和殷殷仍为此惊奇，那时候一个玩家拍着我的肩膀叫我不要插队，他说：&quot;我刚刚去尿尿了，你应该排在我后面。&quot;</p>
<p>我是记得我们的第三个任务的，当时我和殷殷正想返回那个客店吃剩下的鸡。尽管在BOSS殿堂排队等了三个月，但我们还是觉得那只鸡应该是在客店里等着我们的。我还记得那是一个雷雨将至的傍晚时分，那时候我和殷殷同时接到了系统发来的第三个任务。</p>
<p>多年来我和殷殷一直被那个任务所纠缠，任务栏里说城外有大批妖怪在聚集，蠢蠢欲动。那些妖怪的目的是杀掉皇宫里的国王，然后将整个江山席卷。那时候殷殷在晚霞里看着任务栏对我说终于遇到一个简单的任务了。她说：&quot;不就是向国王借蓝宝石启动魔法吗？&quot;然后她指向在我们身后富丽堂皇的宫殿。</p>
<p>多年后当我穿着冰凉若水的盔甲在城门前守卫时，我问殷殷我们站在这儿都多少年了？我忽然忘记我们是来干什么的了，你还留有那个任务卷轴吗？那时候我透过朦胧的月色见得她也已褶皱的脸颊，她说：&quot;我也不记得了，好像我们就是来守城的。&quot;</p>
<p>多年前的夜晚我和殷殷潜进皇宫向国王借蓝宝石，那时候国王姿势僵硬地站在我们面前。殷殷说：&quot;想借用殿下的蓝宝石一用，我们需要开启魔法来抵御城外的妖魔。&quot;那时候我们从国王的话里得到了一个结论，他说：&quot;前些天我不小心把宝石吞进肚子里了，你们得问我的肚子要。&quot;于是结论便出来了，系统要我们向国王借宝石，但国王却把宝石吃了。那么我们有两个选择：一是把国王的肚子剖开取走宝石。二是这个任务不做了，我们继续回去吃鸡。但我们始终觉得这两种结论都行不通。第一：要是把国王肚子抛开了他也就死了，那国王一死妖怪就不必进城来杀他了，妖怪们大可直接去席卷江山了。第二：要是不做这个任务妖怪们就要进城来把国王杀了，那到时候他们也一样要席卷江山。</p>
<p>在此之后殷殷跟我提出了第三个可能，这些年来我和殷殷目不转睛地盯着国王，我们始终相信他是要上茅房的。那时候她指着城门附近的茅房说：&quot;说不定他哪天会拉出来。我们就去当个守城门的，我就不信取不到宝石。&quot;</p>
<p>于是一站多年，我们始终没见到国王来上茅房。</p>
<p>多年来我和殷殷无数次地谈起我们的第二个任务，那是在夜色若墨的城门前。她说：&quot;你还记不记得。&quot;我说：&quot;我是记得的。&quot;其实我一直以为人是活在回忆中的，而我和殷殷的回忆除了多年来守城门就只有第二个任务了。多年来我们每天都会回想此事。她说：&quot;那时候我们排了一个月才最终见着BOSS的面。&quot;</p>
<p>于是我便回想起当时的场景。多年前我和殷殷在BOSS殿堂里睡了一个月的帐篷，那些天里我们见到不停有新人进来旧人出去。它像是菜市场一般自由随意。一个月后我们终于排到了BOSS僵尸跟前。那时候BOSS僵尸刚刚刷新出来，我见得原本空旷的宝座上多了一只衣着华丽的妖怪。多年后殷殷说要不是她手疾眼快还真叫人抢走了。那天BOSS僵尸看着摩拳擦掌的玩家们眼角溢流出了悲伤，它在瑟瑟发抖，它像是我在洞口遇到的小僵尸般求救。多年后我依稀记得那样的景象，那是玩家们为了争夺BOSS僵尸而打成一团，最终BOSS僵尸在玩家们东一口西一刀地凌迟下含冤而亡。</p>
<p>这便是那个任务。</p>
<p>多年后我和殷殷每天都对此事不住谈论，那时在多个夜色若墨的夜晚。她说：&quot;你还记不记得？&quot;我说：&quot;我还记得。&quot;其实我一直认为人是活在回忆中的，而我和殷殷的回忆除了多年来守城门就只有第二个任务了。多年来我们每天都会回想此事。她说，那时候我们排了三个月才见着BOSS的面。</p>
<p>于是我便回想起当时的场景。多年前我和殷殷在BOSS殿堂里睡了三个月的帐篷，那些天里我见到不停有新人进来旧人出去。它像是菜市场一般随意自由。或是三个多月后我们终于排到BOSS僵尸跟前。那时候BOSS僵尸刚刚刷新出来，我见到原本空旷的宝座上多了一只衣着华丽的妖怪。多年后殷殷说要不是她眼疾手快还真叫人抢走了。那天里BOSS僵尸看着磨拳擦掌的玩家们眼角溢出了悲伤，那时候它在瑟瑟发抖，它像是我在洞口遇到的小僵尸般求救。或是多年后我依稀记得那样的景象，那时玩家们为了争夺BOSS僵尸而打成一团，最终BOSS僵尸在玩家们东一口西一刀的凌迟下含冤而亡。</p>
<p>这便是那个任务。</p>
<p>多年后我和殷殷每天都对此事不住地谈论，在守城的这段日子里我们除了望眼欲穿地等国王上茅房便别无他事。我记得那是在殷殷发现自己长出白丝的那天，那时候她拉着我癫狂地冲进皇宫里，我依稀想起多年前那个曾有一头宛若蝉翼发丝的豆蔻少女，那年里她在我瑟瑟发抖时挥剑斩向小僵尸，眉眼如水，双颊如醉。多年后她抓起国王的衣裳问他到底什么时候才去茅房，她说：&quot;我们都等了三十年了，整整三十年，你知道人有多少个三十年吗？&quot;那时候国王转眼凝望我们，他说：&quot;我是想去茅房的，但是系统说我不用去茅房，所有我就不可能去茅房了。&quot;</p>
<p>就像是多年前的那个孩子说起的话语，他捧着沉若千斤的悲伤说：&quot;我是不想吃包子的，但是系统要我说想吃包子，我就得向人们说我想吃包子。&quot;</p>
<p>似水年华，毅眼万年。</p>
<p>我仿佛记得第一次见得殷殷的时候她问我是不是新人，那时候她着一身白衣说自己是店主的女儿。多年前的那个店小二在转身前对我回眸一笑，她说：&quot;你是要去做任务吗，那我们一起吧！&quot;</p>
<p>白衣胜雪，胭脂双娥。</p>
<p>多年后殷殷扯着国王华丽的锦衣，那时候她的鬓角已经斑白，她在我的记忆里落下一颗颗忧伤，滑过脸颊，最终落成她滚烫的胭脂泪。她说：&quot;那么我的锦绣年华呢，我在城门守了三十年就因为系统说你不用上茅房？&quot;然后她疯狂地摇头任由修长的发丝散乱披肩，她瘫坐在地上凝视国王，她说：&quot;那么我们现在能干什么呢？把你杀了？&quot;</p>
<p>多年之后我和殷殷手持宝石走出皇宫，我们听得城外妖法绽放的声响阵阵荡来。夙夜天际，殷殷问我接下来又干什么，我见得城门敞开，一只只魑魅魍魉奔涌而来。或是我忽然想起了国王苍白的面容，他看着殷殷的手在他身体里探寻，那些鲜红的血液透过身体在他的锦衣上盛开。他说：&quot;我早就想死了，我在这里站着不知道多少年了，只是系统不许，系统说我要永远站下去。&quot;</p>
<p>多年后我看着手中的蓝色宝石，它的妩媚光芒在我的眼里闪烁。我对殷殷说：&quot;那我们去启动魔法吧，任务里说这样可以保护国王不被妖怪杀死。&quot;或是那时我见得修长的冰箭从远处射来，殷殷看着刺入自己身体的妖法，她说：&quot;可是国王已经被我们杀死了。&quot;</p>
<p>我说：&quot;不是的。任务里说杀国王的是妖怪。&quot;</p>
<p>可是国王却真真切切的是被我们杀死的。</p>
<p>多年后我看着高空上滚滚而落的火球，长得奇形异状的妖怪在城池里肆意厮杀。那是一阵阵悲鸣在耳旁震响。我说：&quot;我知道了，国王是被我们杀了，所以我们是妖怪。&quot;</p>
<p>所以我们才是真的妖怪。</p>
]]></description><pubDate>Wed Jun 06 2012 21:42:05 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/long-long-ago</link><guid isPermaLink="true">https://blog.wxsm.space/p/long-long-ago</guid></item><item><title>第三章</title><description><![CDATA[<p>清晨，一个晴朗的清晨。不论马修是一个多么慵懒的人，他的铁匠铺总是会坚持在每天清晨打开，早晨可以做很多事，譬如有许多客人或者是送货的人都会在清晨来访。但不可否认，这样的习惯现在已经让他感到越来越痛苦，虽然打铁是他从小热爱的活，但他发觉自从自己来到费伦后他对这唯一热爱的事业都已渐渐失去兴致。他现在实在累得慌，因为他昨晚刚在窑子里呆了一夜，但是这活还得继续，如果他还想再去窑子的话。朦胧睡眼之际，他已看到不远处一个男人牵着一匹马向自己这里走来。于是他开始将火架上的铁坯打得叮叮作响。</p>
<p>“老板，请问这里就是风暴铁匠铺吧？”牵着马的男人走近了向马修淡淡问道。这人约莫30岁，生得十分健壮，络腮胡子和一身皮革劲装看起来隐隐有些煞气。</p>
<p>“额？不是。”眼见此人有些不善，马修十分迷惑地回答道：“我这儿只是个小铺子，你说的那地方不在这儿，你得到城北去找。”</p>
<p>听了马修的话，男人笑了，他讪讪道：“哦…稍等，稍等。我来自深水城，我叫约克。”</p>
<p>“你好，约克先生。如果你要找风暴…”</p>
<p>“凯瑞。”约克打断了马修的话道。</p>
<p>“你说什么？”马修忽然一惊，瞪着肿胀的双眼道。</p>
<p>“凯瑞…埃迪森。”约克诡笑道。</p>
<p>“凯瑞·埃迪森？”马修喃喃问道。</p>
<p>“是的，凯瑞·埃迪森。”约克肯定的回答，顿了顿又说道：“我们在城外救下了这个小子，他和他原来一行人遇到了个大麻烦，就他一个人活了下来。你知道，这么一个小子孤零零的，我是说，他在这儿就剩下一个亲人了。所以他让我来找他，他叫做…”</p>
<p>“马修！马修埃迪森”马修突然回答道：“就是我，我就是马修埃迪森。他现在人在哪儿？”</p>
<p>“很好！”约克又露出了笑容，接着转过身拍了拍马身上的一个布满破洞的麻布口袋说：“他就在这儿。”</p>
<p>眼见凯瑞被装在这样一个袋子里，马修立马有些火了，他连忙走出店门过去将那马背上的麻布口袋抱了了下来，一边解开一边怒道：“这…我…你居然把他当猪崽一样装在这里…”</p>
<p>与此同时，远处那条约克刚刚走过的巷子里又出现了三个衣着华美的青年，两女一男，容貌气质均是不凡，尤其是当中一个女孩，更是清丽脱俗，远远看去宛如一幅美丽的画像。三人原本正朝着这个铁匠铺走着，远远地看到了马修和约克两人在店门口谈论着什么，当中那丽人便停下来脚步。</p>
<p>“心，怎么了？”身旁一名女孩向她问道。</p>
<p>“不想给他还赌债！”那个被叫做心的女孩小声说道。</p>
<p>而在铁匠铺门前的两人却丝毫没有发现远处三人的踪迹，他们继续地谈论着。</p>
<p>“难道你不认为缩在这口袋里边是件很舒服的事吗？我保证这一路赶来他一步都没走。你看这多安逸，我可是费了很大的劲儿才把这猪崽给捞到这儿来的。”说着约克又笑了起来。</p>
<p>匆忙解开带子的马修闻言没有争论，又赶紧把凯瑞从袋子里面抱了出来。这时，远处的那位叫心的女孩远远看到了凯瑞的容貌，忽然低声惊呼：“是凯瑞!”</p>
<p>“他没什么事吧？”马修探了探凯瑞的呼吸问道，此刻凯瑞正昏迷不醒。</p>
<p>“那是当然”说着约克蹲下了身子拍了拍凯瑞的胸口坏笑着说“除了胯下还少了撮毛，绝对是个完美无缺的漂亮男人啊。哈哈哈…”</p>
<p>“那么…谢谢了。”马修对约克诚恳地说,“进来喝碗水吧！待会他醒了要是没什么问题，我就给你五个银币，拿去喝些酒吧！”说完马修想了想又道,“十个银币。”</p>
<p>“呵呵….”听了马修的话约克表情一变,冷笑道“老板，你不妨翻过他的身子看看，他后背上有什么。”</p>
<p>听了约克的话马修变疑惑地翻过了凯瑞的身子，登时语塞，而后惊出一头冷汗。“这是…”</p>
<p>“你是天天打刀子的，老板。想必你应该能看出来这口子是怎么来的吧？”约克收起了笑容继续说“大马士革弯刀，而且加铸了一尺长的缝纫，这样的刀。你知道那个拿刀的人是什么货吗？”说着约克双眼紧紧地盯着马修。“我们弟兄几个冒着生命危险把他救了出来，并且还出重金请了教会的牧师来为他治疗，你就给我十个银币？”</p>
<p>“哼！十个银币已经够多了”马修怒哼一声说“你要是不想要那就算了，别以为我不知道，你们这些狗屎会花钱请牧师去救一个身无分文的小子？”</p>
<p>“没错！”约克深呼了口气说“我们绝不会出一个铜子儿去救一条死狗。不过…”说着约克从怀里掏出了一份羊皮卷轴一边打开一边说道“这条死狗的身上若是有了这个，那就不一样了。哈哈..看看呐，这条死狗居然还被推荐到艾森学院？呵，狗东西，你怕是没这个福气了！”说着他就要将那份卷轴一把扔进铁匠铺的火炉中。</p>
<p>“不！”眼见如此马修一把将凯瑞放在了地上冲到约克身前捉住了那只正要将卷轴扔进火炉的手喊道“把它给我！”说着竟要从他手里硬生生抢过来，只可惜不知是这铁匠在这几年已经让妓女榨干了身子，还是约克的手劲实在太强，马修使尽双手的力竟难以扳动丝毫。</p>
<p>“你想要？好说。”约克另一只手一把按住了马修的肩膀笑着说“只要咱们先把帐结清了，这东西自然会归还。把这小子救活，加上前前后后的跑路钱，除去零头，你至少得付我十个金币！”</p>
<p>闻言马修双眼猛地瞪得突起，怒冲冲地道：“十个金币？去你妈的！把你家那条老母狗拉倒费伦的妓院从头到尾全卖了也不值一个银！”</p>
<p>“哈哈…..”约克不怒反笑，说“没错！可你要是不给钱，你就算把你家的老母狗连着小母狗一齐卖了也换不回这东西了！”说完他一把推开马修，右手就要将那卷轴扔进火炉里。</p>
<p>突然，身后传来一阵喊声：“哎！你等等，等等….”两人闻言猛地转身才发现，一位少年已不知何时走到了约克身后，只见他一头略显散乱的黑色短发，却无法掩盖他那俊美到近乎妖异程度的面庞，穿着一身质地上乘，在朝阳下隐隐散发着淡淡橘红色荧光的灰色袍子，无疑显示他身份是何等尊贵。眼见这样一个人站在面前无论是约克还是马修心里都有些暗暗发憷。不过这少年到并不像他们想象的那么傲气，反而是一脸亲切和蔼的笑容，见到他们就好像是见到了交情深厚的朋友一般，只见他笑着对约克说：“十个金币？好说好说，这位大哥你来了费伦也不打听打听，能在这块地界立足的哪家哪户没有几块金子？”说着他忽然怪笑起来“也就你这种穷乡僻壤的杂碎会穷得把你家母狗拐到妓院去换钱的吧？哄哄….”</p>
<p>“你……”闻言约克心里猛地一怒，就要发作，但有恃于这少年的背景，他还是忍住了。</p>
<p>不远处的两女听到了少年这话也不由暗皱了皱眉头，旁边那女孩更是忍不住对那位叫心的女孩说道“这家伙真是没有教养，满嘴污秽！”那名叫心的女孩听了也也微微闭了闭双眸。</p>
<p>“额，这位少爷。您是？”马修站起身来对着那名少年恭敬地问道。</p>
<p>“咕咕…”那少年闻言又是一阵怪笑，“你居然不认得我？咕咕…不过这不重要。重要的是，这位…凯瑞，正好是我的朋友，而我身上也正好带着一些金币。”说着他开始掏起了身上的口袋，抓出了一把金币，在阳光下甚是耀眼，“你看这金灿灿的，一枚，两枚，三枚….咕咕…居然多出了这么多。你说，怎么办好？怎么办？”说着这少年捧着这捧金币看向约克笑着问道。</p>
<p>约克见状顿时喜笑颜开，他立即恭敬地对少年笑道：“少爷！我们就来您这位朋友…我们花了很多钱，一共…一共十个，哦不十五个金币！”说着他还伸出了他那双粗糙而泛黄的手摆起起了手势。</p>
<p>“你……”马修闻言一怒。</p>
<p>“哎哎….”眼见马修就要说话却被那少年一手打断了“你怎么能随便打断别人说话呢？这多不礼貌？”看到此处，远处的站在心旁边的那名少女又皱了眉头，哧了一声。而那位叫心的姑娘扔只是静静地看着。</p>
<p>“少爷，他….”马修还想要对少年说什么但又被他一手打断，于是便索性闭上了嘴。</p>
<p>“你是说你们？咕咕…那就还有其他人咯？”说着他竟迅速变脸，开始抽泣起来：“你可知道，盖瑞可是我非常非常亲密的朋友！…我还以为，我就要永远的失去他了…呜呜…我的好朋友…恩…然后…这个…对了！我要感谢你！我要感谢你们！”说完他将金币重新装入了口袋，又从口袋里掏出一张精美的手绢轻轻地擦着眼睛问道：“勇士!还有多少恩人！”</p>
<p>约克闻言有些激动地回答：“少爷，是我！还有我老大…”说着他突然一顿仿佛想起了什么于是突然改口说道“我老大说，让我不要说出来…他是一位虔诚的信徒，这都是我们应该做的！”</p>
<p>“勇士！”少年猛地收起了手绢十分真诚地看着约克道：“我真是太感动了，非常感谢你们对卡瑞施以援手！”说罢他又转头看了看侧卧在地上的凯瑞，只见他嘴唇干枯，脸色苍白并且衣衫褴褛，十分地狼狈。“这…我可怜的卡瑞,悲剧啊…”说罢他又开始抽泣。</p>
<p>“少爷…”约克见状有些忐忑地对锦衣少年说。</p>
<p>闻言锦衣少年转过身笑着对约克说：“勇士！虽然这只是你们分内的事，但我还是不能让你们白受损失，所以…”说罢他又掏出了口袋里那些金币对约克道“请您收下这些钱吧！当做是我对你们的谢意！”眼见如此马修在一旁瞪大了双眼，连呼吸也变得粗重起来。他几次想对那锦衣少年开口说些什么，不过都被他忍住了。</p>
<p>而约克则是笑得嘴都快裂了，他双手接过了那一捧金币，也顾不得数就立刻装进了自己随身的口袋，然后不住地道谢：“谢谢少爷！谢谢少爷！…”而那锦衣少年也未见丝毫不舍，他淡淡地笑着朝约克挥了挥手头道：“勇士！走好不送！”</p>
<p>于是，约克就这么牵着马走了，依然是从他来时的那条巷子。走过去时他见到两为绝色少女迎面走来还不由地多看了几眼，但之后他便转过头，一手紧紧地压着腰间，牵着马走了。</p>
<p>“嗨！卓林少爷！这戏可演的真不错啊！”</p>
<p>“咕咕…”那名被叫做卓林的少年怪笑了几声道“我可没有演戏，这位…坎瑞确实是我的朋友，朋友的朋友就是朋友，你说对吗？心小姐。”说着卓林朝心真诚地微笑着。</p>
<p>看到两名少女过来，马修也站直了身对心说：“小姐，你也来了？”心对他微微点了点头。</p>
<p>“这次谢谢你了，卓林。那笔钱明天我会双倍还给你的。”心对卓林淡淡说道。</p>
<p>“咕咕…..”卓林闻言忽然又是一阵怪笑“心小姐，你的正直归正直，只可惜，那笔钱已用不着你还了，而且，以心小姐目前的财力，恐怕也未必能还得上吧？”</p>
<p>闻言两女面色都有些不善，绿衣少女更是有些微怒，她朝卓林说：“卓林！什么意思！”</p>
<p>“哎哟…您可千万别激动！听我解释嘛，那金币是我家族内部专用的信符”说着他伸出舌头舔了舔嘴唇说：“而那杂碎手里的那些更是本少爷专用的，咕咕….除了我的朋友，没有人能够带着它们走出费伦这块地。”笑了许久之后他又摆正了表情说：“没有人能够不付丁点儿代价就从我的手里拿走金币。”说着他又忍不住咕咕地怪笑起来，眼见如此两女都忍不住皱了皱眉头，而马修更是吓得不敢说话。只见卓林又停止了笑容继续正色道：“我已经明白了。你们都明白了吗？”</p>
<p>三人被这么一问都呆住了，不知该如何回答。而那绿衣少女忽然忍不住问道：“你想把那个人怎样？”听得绿衣少女这么一问，卓林的忽然摆出了一份很纯真的笑容道：“我不会把他怎么样的，只是…我们家的妓院什么女人都不缺，但就缺一条母狗！”说着他竟将双手举到了两耳旁轻轻扇着，接着对两女摆出一副了一副十分可爱的模样叫着：“汪！汪汪！汪汪汪！……”顿时惊得身旁三人都说不出话来。</p>
<p>此刻几人却都没有察觉到，横卧在麻布口袋上的凯瑞眼皮轻轻动了动，然后又复归静止，之后仿佛熟睡一样就再没动过了。</p>
<p>凯瑞醒来的时候已经傍晚了，又是间屋子，又是在一张简陋的木床上，床边也很是巧合地站着一个人。不过这人比起他两天前见过那名士兵略显矮胖，蓬松的黑色头发之下是一张微微泛红又有些黝黑的大脸，茂密的胡须密密麻麻的长在他的下巴处，看起来就像是个矮人，身上仿佛是套着个黑色布袋一样地穿着件黑色无袖的麻布衣。这人便是他的舅舅马修。在微弱地煤油灯光下，他也立刻发现凯瑞醒过来了。</p>
<p>“小凯瑞…快看看我，我是舅舅。”马修坐到了床边凑到凯瑞脸前说。“你没事了，这里是舅舅的家。你已经到家了。”说着他又伸出了一只手抚了抚凯瑞的胸口。而凯瑞却不知该说些什么，或者是说不出什么，他借着灯光认真地望了望舅舅的脸庞，深深地吸了口气，接着点了点头，之后便转过眼看起了这个房间。一个简陋的的卧室，一眼望过便能看明白，一扇已经封住的窗户，一张木桌，还有就是现在这张床，这里甚至连一张椅子都没有。</p>
<p>“心今天正好来了这儿，她看到你很高兴。”眼见凯瑞有些沉闷马修便说起了这件事“她的一个朋友说你大概这个时候就会醒过来了，真是厉害啊。”说着他还不由笑了笑，而凯瑞听了却没有他想象中的高兴，反而神情变得十分黯淡。这倒让马修始料未及，想起以前每当他回到风暴城，这个少年总是缠着自己问心的近况，那时他随意地说起一些事都会让这个少年欣喜若狂。而现在这个少年却变了，也许是因为遭遇盗贼那件事吧。马修心里想。</p>
<p>“你快喝些水！”眼见凯瑞嘴唇干枯得不成样子马修才想起，他立马起身到桌子那里倒了一碗水端过来给凯瑞，凯瑞也确实十分口渴，他接过那碗水就凑到嘴边一咕噜地全灌了下去，也不知是不是因为口腔十分空荡，这碗水灌得十分快，中途他呛了一口，但也被他忍住了没有表现出来。在马修看来，凯瑞就这么安静而又利索地把那碗水给喝了下去。他接着说：“你的遭遇我已经知道了，是一帮盗贼干的，今天那个士兵也已经打发走了。”凯瑞听了又是轻轻地点了点头。</p>
<p>“你怎么不说话？”马修看着凯瑞有些奇怪，“你是不是饿了？我真是愚蠢！，怎么忘了这事，你等会儿凯瑞，舅舅马上去给你做些吃的！”说着马修拍了拍脑门，又急急忙忙地走出了房间，看样子是忙活着做饭去了。</p>
<p>而留在屋子里的凯瑞却感到一阵胆寒，他内心十分不安，他十分害怕。金币的事情已经解决了，但是接下来这件事他却不知该怎么去面对，他不敢想象如果舅舅知道了他舌头没有了的事实，会是怎样的表现，他不敢想。凯瑞一时间不知所措，左顾右盼之际，他看到了枕头旁边的一件东西，一份卷轴，白色的羊皮卷轴，他不由地将它拿在了手里。已经有两天的时间没有触摸过它了，也仅仅是两天的时间，如今他再度拿起这份东西却感到有些陌生，连这份陌生感也是来的很突然。</p>
<p>“凯瑞·埃迪森是个十分聪明的人，他坚毅、勤奋，对智慧有着炽热无比地热爱与追求……假以时日，凯瑞·埃迪森必将成为一名优秀的法师，成为帝国一颗闪亮的星星。—-风暴城主埃蒙斯·胡夫”</p>
<p>“小凯瑞，外公祝福你。”</p>
<p>“凯瑞，妈妈听他们说法师都是可以飞在天上的，是吗？真的吗？”</p>
<p>“小弟，真是想不到，你就要去学习魔法了。等你学成回来，你一定要给城主说，让你来做我们的军团长，我已经忍他很久了！”</p>
<p>……</p>
<p>“凯瑞，完事儿了！”一声叫喊打断了凯瑞的思路，只见是马修一手端着一盘黑乎乎的不知为何物的东西从门外进来，路过那张桌子时又顺手一把抓住桌身连着也一起拖到了床边，随即将那盘事物放在了桌子上对凯瑞说：“我烙了你最爱吃的饼！”</p>
<p>一股淡淡的麦香混合着浓烈的焦味涌进了凯瑞的鼻子里，又让他心头一暖，不过当他坐起身来拿起一块饼咬在嘴里时却很不是滋味。是的，没有任何滋味，只是有股热气在嘴里萦绕，很烫，除此以外他尝不到任何的味道。但因为肚子实在很饿，凯瑞也顾不上这些，只是一个劲的吃。随即又感到有些不对，突然觉得腹部一阵疼痛，让他不由伸出一只手捂了捂肚子，另一只手还是拿着一块饼在往嘴里塞，这两天他除了喝水嘴里就没再进过别的东西，他是真的很饿。</p>
<p>“你怎么了？肚子不舒服？”马修见状关心地问道：“吃慢点儿吧！一定是很久没吃东西了。”说着他又怒气上涌，恨恨地说道：“这狗屎！等着吧！老子早晚把你们家那母狗卖到妓院去！嘿嘿…”说着他又忍不住笑了起来。笑得十分得意，然后他转眼看了看凯瑞，后者没有什么动静，仍然在吃饼，好像那些黑乎乎的饼真的很好吃似的。想了想马修自己也忍不住拿起了一块饼往口里探了探，不等他一口咬下去，他就猛然呸地向地板一口吐了口口水，脸上那神情就好像被人灌了一嘴的泥。“妈的！这么久没自己做东西吃了，这都是些什么？”说完马修忽然想到凯瑞，他连忙按着凯瑞的肩膀轻轻摇了摇道：“凯瑞，你别吃了！天！这么难吃的东西你怎么咽得下？你快吐出来！”说着他开始用力地摇晃着凯瑞的身子，然后就看见凯瑞低下头一张嘴就一大坨黑色的黏糊状物体从凯瑞的嘴里一股脑吐了出来，接着就一直紧紧地抿着嘴，有些惊慌地抬眼看着马修。</p>
<p>马修正两眼直直地看着他，在刚才凯瑞张嘴吐出嘴里的食物时他总觉得有些不对劲，但是具体是什么他又想不出来，一时间马修的内心也开始感到不安。“舅舅…舅舅去外面给你买好吃的回来。你在这儿等会儿，我马上就会回来！”说着马修正欲转身出去，然后又猛地转过身来端起了那盘剩下的黑饼，喃喃说道：“这些难吃的东西都不要吃了！”说罢他便走出了房门。又留下凯瑞一个人在屋内，他没有再躺回床上去，只是看着地上那堆吐出来的食物静静发呆。</p>
<p>片刻之后，马修的声音又从门外传来。这个男人又是像刚才那样端着个盘子直直地走了过来，不同的是这次盘子里装的却是一只金黄的烤鸡，黄橙橙在火光之下十分亮眼。马修将盘子轻轻地放在了凯瑞身前的桌上笑着对他说：“舅舅给你买了好的，鸡肉，还抹了蜜，很甜的。”说着他伸出手扯下了一只鸡翅递给了凯瑞，“以前舅舅不是跟你说过吗？费伦的烤鸡都是甜的，你最喜欢吃甜的了，所以舅舅就给你买了这个，喜欢吗？”</p>
<p>凯瑞安静地吃着鸡翅没有说话，倒是点了点头。</p>
<p>看到凯瑞点头，马修的神情却突然间愣住了。他有点不敢相信地又问了问凯瑞：“你真的喜欢？这甜的…”凯瑞听到马修的话也放下了那没吃完的鸡翅低着脑袋轻轻地点了点头。</p>
<p>“凯瑞…你张开嘴。”马修颤声道。</p>
<p>凯瑞呆滞着，变得没有了动静。</p>
<p>“你张开嘴！”马修突然大吼道，眼见凯瑞还是没有动静，他终于忍不住伸手捏住了他的下巴，将他的嘴扳开了，一看之下，马修瞬间惊呆了。“光明神呐！”这个男人忍不住哭喊起来，他疯狂地摇着头嘶声向凯瑞问道：“那些杂种干的？是不是那些杂种干的？”凯瑞也已经内牛满面，他自然是知道马修嘴里所说的“他们”是指那些士兵，他摇了摇头。</p>
<p>而马修仿佛已经失去理智，他疯狂地哭喊着“怎么会这样？怎么会这样？神啊！我以为你会成为一个法师！”“我以为你会成为一个法师…这帮母狗养的杂种，…光明神你看看呐，这些母狗都生出了什么？狗杂种！”</p>
<p>“还有没有人知道这件事？”马修忽然猛地一惊向捉着凯瑞双肩问道：“除了那些强盗，还有没有人知道？”凯瑞已有些眩晕，仿佛随时都要昏过去，不过在被问到这个时他还是强硬清醒了些，想了片刻，他摇了摇头。</p>
<p>“好，好，不要让别人知道，你千万不要再让别人知道这件事，一定不能！”马修瞪着凯瑞十分郑重地说，直到凯瑞点了几次头他才送开了他。不过一番打击之后，这个原本已经开始苍老的男人，此刻看起来竟真的就是个老人了。他又注意到了枕头旁边的一快羊皮卷，那正是凯瑞的入学推荐书。他凑过身去一把拿了过来，摊在眼前看了看上面的内容。上面的每一个字他今天都已经看过数次，就在今天早晨他还为了这小块羊皮挣得和别人挣得死去活来，不过现在…现在什么都没了。想到这里，两行浊泪又从这个男人的双眼流出。</p>
<p>“我本来以为…你会成为一个法师…”</p>
]]></description><pubDate>Fri Jun 01 2012 19:19:21 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/paladitch-chapter-3</link><guid isPermaLink="true">https://blog.wxsm.space/p/paladitch-chapter-3</guid></item><item><title>第二章</title><description><![CDATA[<p>夜，深深地夜。</p>
<p>当凯瑞跟着那名士兵从房间里出来时，城墙上的岗哨也正好换了一班。深水城乃至大多数人类城市都是有着严格的城防制度，哨兵通常被分为两班，一班为白哨，从正午开始放哨一直到午夜，而另一班为黑哨，与前者相反，他们是从午夜开始工作直至次日正午。此时正是由白转黑的午夜时分。凯瑞一路无话，只是紧紧地跟随在士兵身后，渐渐穿过一道道的巡哨口。而这为士兵此刻却是像打开了话匣子一般，开始对凯瑞说个不停。出门之后他首先就告诉了凯瑞，这里是深水城…</p>
<p>约莫片刻之后，两人就来到了一间石室前，入目可见的是一道漆黑的铁门，透过门缝可以看到里边传来了橘黄色的火光。士兵走到门前直接一把将门拉开，然后示意凯瑞跟着他进去。凯瑞没有迟疑，直接跟了进去。一进到屋子里，他就环视了一番。室内十分空旷、简陋，脚踩着的是凹凸不平的石头地板，屋内四处也并没有什么饰物桌椅之类的东西，有的只是几座约莫一人高的十字铁架子散落在各个方向。其中一座铁架子旁边的地板上还放着一口火盆，里面的火炭此刻缓缓燃烧着，到是使整间屋子都有了些暖意。透过这火光向里看去，就在火盆的不远处，正躺着一个同样穿着制式战甲的人，映着摇曳的火光，那身铁甲十分的显眼。</p>
<p>两人站定之后，领路的士兵便向那名躺在地上的军官说道：“军士长，他醒了！”待到话音落下许久，那名躺着的军官才从地板上坐了起来，惬意地伸着懒腰，淡淡地说道：“嗯，你回去吧。”说着又向领路的士兵挥了挥手，后者转头看了凯瑞一眼，随即默默地走出了房间，关上了大门。屋内顿时就只剩下了凯瑞和这名军官。直到此时，凯瑞才借着火光细细地打量眼前的这人，他模样十分阴郁，一双凶光直冒的三角眼此刻正诡异地盯着他，一张细长的嘴巴不知何时也开始诡异地笑了起来。乍看之下真是像极了教堂里那些用石头刻成的魔鬼雕像，但那满头散乱的的褐色长发和渣拉的须根看起来又略显些粗犷。有些恭维地说，这个男人的模样简直已经将魔鬼和恶魔这两种水火不容的存在给兼容并济了。凯瑞不喜欢这个人，不单单是因为这长相，他还感觉到面前的这个男人有些不怀好意。</p>
<p>“小子，死而复生的感觉如何？是不是十分美妙啊？”他果然就问了句不怀好意的话。对此，凯瑞只是默不作声，低头注视着地板。却不想褐发军官见状瞬间收起了笑容，板着脸恶狠狠地说道：“原来你小子他妈什么都不知道。”听到这番话凯瑞被吓得身体一抖，此时他分明已经感受到褐发军官那原本诡异的眼神已开始毫无顾忌地向他表示深深地厌恶，这厌恶和这句话都来得十分突然，让凯瑞不知所措。</p>
<p>“把你的爪子伸到后面去摸摸你的后背。”褐发军官冷冷地说。听到他这么说，凯瑞略微迟疑一下便将右手伸向了自己的后背。虽然一直感到疑惑，但在手指触及到背部以后，凯瑞还是瞬间明悟了，他呆住了，因为他右手触到了一条豁口，衣服上的豁口，这长度足以将他整个后背划为两段。此刻他才突然想起在他后背上本该有这么一道致命的伤口，那是在那场如噩梦般的灾难中被一名灰衣人用弯刀砍得，几乎将他后背切了开来。而那样可怕的一道伤，现在却毫无踪迹，此刻他指尖所触碰的分明是一片完整无损的皮肤。</p>
<p>“你小子运气不错。”褐发军官接着得意地说道：“这次的侦察小队中随行了一位光明教会的牧师，否则的话这道口子就足够让你死透了。”说到这里他嘴角再度扬起了诡异的笑容，“不过比起那些被活生生剁成肉泥的人，你这种死法应该是很轻松才是吧！哈哈、、、”随着这笑声，凯瑞心中也猛然涌起了一股深深地寒意。那是他想到自己的后背被这样活生生切开，或者是想到一个活人被乱刀剁成了肉泥。</p>
<p>“你现在是不是应该感谢光明之神？感谢他赐予神力救赎你的小命？”褐发军官继续问道“不过我倒是觉得你最应该感谢的是那个盗贼团的首领，要不是那个蠢蛋让哪条母狗的奶子给夹坏了脑袋，他又怎么会安排一个菜鸟来负责补刀呢，若不是这样，你也等不到神的救赎了。话说回来，那个蠢蛋也许就是光明神派来的使者。哈哈、、、”说着男子又是一阵狂笑。</p>
<p>几番话下来尽显其粗俗与放荡，这倒是让凯瑞感到心里安定了不少，他从小就一直生活在边境的军事重镇，对这底层军人的流氓痞气他再熟悉不过，也再亲近不过。他对周围环境所产生的恐惧也暂时淡弱下来，冥冥中他似乎觉得自己已经对面前的这名军官有了一定的了解。如此，他已大致猜到这名军官将自己叫来的目的了。所以他目前应该是安全的，在被证明自己没有价值之前。凯瑞想道。想完这些他随即将双手合握于胸前，闭上双眼开始祈祷。倒并非是什么感谢光明神之类的祷告，如果光明神真的挽救了他，那他又怎么会遭此厄运？他只是向神祈求一个小小的要求，千万不要让这些家伙知道自己的舌头被割了。不然他的处境一定会变得非常险恶。在人类国度，只有奴隶才会被割去舌头，这句话反过来说一样通，被割了舌头也就等同于成为奴隶。他相信这些军官是绝不会对一个奴隶客气的。</p>
<p>褐发军官见凯瑞祈祷，撇了撇嘴到：“你还真是个虔诚的信徒，不过可惜你要白费功夫了。光明的神力都是免费的，但军爷的饷钱可是一个铜子儿都不能少。”言罢他又瞬间换了副谄媚的表情，伸手从怀里掏出了一份折叠的淡白色羊皮卷，一边翻开一边对凯瑞说：“不过我尊敬的法师先生，您大可以将这几个铜子儿当做您一份微薄的打赏。”说完这番话他又瞬间变脸，十分得意地看着凯瑞。如他所想，后者此时正目光直直地盯着他手里的这份羊皮卷。</p>
<p>这是一份出自风暴城城主的推荐函，里面的内容表示对凯瑞的天分与品质大加赞叹，并以城主的名义将这少年推荐到帝都费伦的艾森学院入学。这就是褐发军官将凯瑞单独叫来的目的，离艾森学院新一学年之期已不久，很显然这份羊皮卷对凯瑞来说至关重要，而褐发军官又十分机智地分析出这个少年既然能够从风暴城城主的手中得到这样一份推荐函，那他家里至少是个有钱的主儿。所以…</p>
<p>“所以，咱们可以做一个交易，我会安排人将你安全并且准时地送到费伦，想必你们一行人不远千里从风暴城赶到帝都，一定会有人在那里接应你们吧？等我的人将你送到他们手里之后，你必须支付我五个金币的报酬。怎么样？”褐发男子比划着五根手指微笑着向凯瑞问道，而凯瑞默不作声，似是在想些什么。“这已经十分难得了，小子。我相信你若是将这份差事交给那些婊子养的佣兵来做，不论你给他们许诺多少报酬，你都会在第一时间被他们向对待奴隶般直接从工会里扔出来！”褐发军官强调说，丝毫没注意到在他刚才提到奴隶两字时，凯瑞的身躯猛然一抖。</p>
<p>但是这也已不重要了，就在这句话说完之后，眼前的这个少年就十分爽快地点了点头。眼见目的达成，褐发军官也露出了满意的笑容，他微笑着对凯瑞不住地点头说道：“很好！沉默！你真是我见过最有法师天分的的人了，呵呵呵…不过可惜你现在还没有一丁点儿的自保能力”说着他仔细地将羊皮卷折叠起来收入了怀中道：“所以这份珍贵的推荐函，就只能由我的人暂时替你保管了，我相信两天之后你就能拿着它进入伟大的艾森学院了，我尊贵的法师先生。哈哈……”</p>
<p>两天。如果说每个人的一生中都会有一段黑暗，那么这两天所经历的绝对是让凯瑞最难忘的一段了。短短两天的时间，他失去了太多。失去了从小陪伴他长大并且保护他照顾他的哥哥阿诺，失去了说话的能力和开口大笑的权利，失去了做人的资格。饥饿、疲倦、哀伤，无时无刻不在摧残着他的身心，除此以外还有深刻的压抑。</p>
<p>每当他看到那个负责送他去费伦的士兵掏出那张羊皮卷好奇地观看时，他都会感受到沉重的压抑。五个金币，不是五个银币，更不是五个铜币。而是金币。这笔钱无论对他本人还是对他的家庭来说都是一笔巨额的财富，中间他一直都不敢想象自己抵达费伦以后该如何支付这笔钱，他甚至已经有了放弃那张羊皮卷的冲动。反正他已经没有舌头了，这便意味着他几乎无法念出一个最简单的咒语，对于法师来说这等于是判了死刑。既然是这样，那为什么不干脆放弃呢？每当想到这里，他的心里都感到无比的刺痛。成为法师是一个梦想，不仅仅是他一个人的梦想。原本这已经是触手可及的了，但是却发生了这样的事，凯瑞不甘心，他怎的很不甘心。</p>
<p>他就这样被马车运肉干一样地运了两天，当车外传来抵达费伦时，尽管内心是那样地恐惧可也还是忍不住爬出来瞪大眼睛仔细地看着这座巨大的城市，那是如此地繁华与美丽，入眼的每一处都是那么锦绣华丽。望着这般景象凯瑞终于也忍不住呜呜做声，他不由想到若是没有遇上那帮灰衣盗贼，此刻他应该就和阿诺等人一起站在这里吧？若真是这样该有多好，他们会有多么地惊喜，你们可能看到？这座城市比起胡夫城主的那副画像要美丽多少？想到胡夫城主他又不由想起不久前他接到胡夫城主传来的推荐函，那时母亲与外公是多么欣慰，他永远不会忘记那时母亲竟以侍奉神明的方式跪在了父亲的画像前痛哭倾诉，想到最后，他脑子里却只剩下多年前父亲曾说过的一句话，“只可惜，我猜中了开头，却猜不中这结尾！”</p>
]]></description><pubDate>Wed May 23 2012 19:11:14 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/paladitch-chapter-2</link><guid isPermaLink="true">https://blog.wxsm.space/p/paladitch-chapter-2</guid></item><item><title>第一章 · 噩梦</title><description><![CDATA[<p>连载作者：Loolorl_lar@qq.com</p>
<p><strong>本目录下之连载作品，未经授权，禁止转载</strong></p>
<p>弯刀，斧头，血...放眼望去，整个世界都被覆盖了一层血红的氤氲。血色之下，数不清的灰衣人正拿着各种各样的锋利武器砍杀着周围的其他人，刀刀见血，刀刀见肉。那些被砍杀的人尖叫着、哭喊着求饶，求神明保佑，然而迎接他们的只有刀子和斧头。当中有几个披甲战士果断拔出了他们挂在腰间的长剑开始反击，他们一个个都无比矫健勇猛，即使是面对着数倍于自己的敌人也一往无前，长剑所到之处，要么是刀兵相击，要么就是一个灰衣人被直接斩杀。尤其是其中一个身形高大魁梧的战士，每一剑斩出还会带起微微的炽白色剑芒，一剑之威竟能够直接将灰衣人的武器切断，随即切开他们的躯体，激起一朵血花。而那些灰衣人的武器砍在这几个披甲战士的身上却只造成一道血痕，或者只是在他们的战甲上磨出一道白印。在这般实力对比之下，四周的灰衣人也渐渐感到胆寒，他们不再轻易地靠近这几个披甲战士，而是转向其他地方去切了那些弱小的普通人，随后围成了一个巨大的圈，将这几个披甲战士连同他们身边的几个酱油都包围了起来，双方都不敢轻举妄动。</p>
<p>这般情况下，灰衣人若是阵型不齐就冒然冲到了披甲战士身前，那他们将付出沉重的伤亡，显然他们都怕死，没有人愿意做那个靠前的牺牲者。而反观披甲战士几人，他们更是势单力薄，只能几人紧紧地抱作一团，稍微一分散。立刻就会被众多灰衣人冲乱阵型，随后即会被分别包围，然后乱刀砍死。即便他们几人实力不凡，能够聚在一起向包围圈外冲杀出去，但他们身边的几个酱油确是无法跟得上他们。当中那个身形魁梧的披甲战士此刻就正护着身后的一个少年，显然他也并不愿意撇下他自己离开。几人就这么和众多的灰衣人焦灼地对峙着，双方都在各自地寻找契机，一个打破平衡的契机。</p>
<p>突然间，这个契机来了，一个人，灰袍人。此刻他就站在魁梧的战士对面，中间隔着一些灰衣人。不同于其他灰衣人的衣着，他是被一件宽大的灰色连帽长袍所笼罩，在他布帽脸部的空洞下却是被一片阴影所遮挡，什么也看不见。而他的手中拿着的也不是弯刀或者斧头，而是一本书，一本宽大厚重，外形十分古朴的书。这样的装扮在这样的时刻出现在这样的地方，显然他不太可能是那些四处云游写书的吟游诗人，他很可能是一个法师，拥有着诡异并且强大的魔法力量的法师。有了一个法师加入战局，平衡立刻就被打破了。</p>
<p>灰袍法师一出现就立刻翻开魔法书开始低声吟诵晦涩的咒语，右手处开始冒出淡淡的红色光芒。几个披甲战士见状立马就感到一股寒气涌入心头。当中那个魁梧的战士眉头一拧，立刻做出一个手势，顷刻间他身旁的两名战士就跟在他左右两旁，三人呈一个三角形一齐向法师所在的方向冲去。众灰衣人也立刻做出了回应，整个包围圈迅速的向中心聚拢而去，大部分的灰衣人都冲向了魁梧战士三人，挡在了他们前面。另外一部分灰衣人则是向其余披甲战士和几个酱油涌去。一场激烈的厮杀再次展开，魁梧战士使起了浑身解数，整个身躯都冒起了淡淡地白色炽芒，其中还有无数细微的丝状光芒正向外喷吐，如同全身包裹着闪电。他每一剑劈出也都带起了一片携裹着丝状光芒的剑光，范围之广可溅射数名灰衣人，仿佛是将这一剑之威分裂成输份，分别对向了数个敌人，蜂拥而来的灰衣人在这样的攻击之下一个个都接二连三的倒下了。在身后两个战士的掩护下，他就这样一步一步地冲杀着靠向那个灰袍法师。必须要在他施法之前阻止他。</p>
<p>战斗就这样激烈地进行着，伴随着灰衣人和酱油们的惨叫声，魁梧战士和灰袍法师之间也只剩下几步的距离，此时灰袍法师右手上的红色光芒已经十分的浓烈（猜猜是啥法术，猜中有奖）。魁梧战士浑身浴血，表情更是无比狰狞，只见他迎面直接用肩膀和胸口挡住几把弯刀和斧头的攻击，顿时又增加几道伤口，随后他全身顿时光芒大作，双手将长剑高举，怒吼一声猛地向前弹起朝灰袍人斩去，挡在身前的几个灰衣人也顷刻被撞得左右横飞。与此同时，灰袍人右手上的红色光芒也瞬间消失，取而代之的是一道细小的暗红色光线，瞬间打在了空中的魁梧战士身上。魁梧战士猛地一顿，他的衣甲和身躯顷刻间被一股巨大的力量撕碎一般的炸裂开来，鲜血四处喷洒，像是盛满血红染料的染缸顷刻破碎一般。血淋淋的色泽染红了一切..</p>
<p>凯瑞仿佛是从一个恶梦中醒来。当他睁开双眼时，映入眼帘的是熟悉的铁甲，这正是帝国军队的制式战甲。看到这衣甲，他顿时从那地狱般的梦境回到了现实当中。内心再度充满了一种淡淡的，暖暖的感觉，也正是他所熟悉的安全感，原本的惊慌与恐惧一扫而空，原来这只是一场噩梦而已。眼前站着的这人虽然不是阿诺哥哥，但想来应该是随行士兵的一员吧。转眼再看看四周的环境，他正处在一间屋子里，并且躺在一张木床上。是的，是屋子和木床，而不是帐篷和土质地板。这么说来他们一行人应该已经安全地抵达了深水城，最艰难的那条路已经度过了，很快就可以到达费伦了。想到这里，凯瑞深深地呼了口气，神情有了一丝愉悦。与此同时，凯瑞身旁的那名士兵也发现他醒了过来。他低头看向凯瑞，双手握在胸口，并郑重地对凯瑞说了一句：“神保佑你，孩子！”</p>
<p>之后，当他放下双手想要继续向凯瑞说些什么时，却发现少年双眼一片茫然，神情呆若木鸡。就像是受了什么巨大的惊吓，突然就变成了这么个呆子。对此他却并不感到奇怪，在他看来这孩子有这些表现本就是理所当然的事，任谁遇到了这种灾难，心灵都难免遭受巨大的打击。一个数百人的车队被盗贼团抢劫，得了财务居然还杀人灭口，除了这个孩子侥幸活了下来，其余的人甚至当中还有一些来自边境的强壮士兵都被残忍地杀死了。“神呐，这都是些什么事啊？”士兵默默地叹了口气，他现下只有祈祷这个孩子不要因这次惊吓而真的变成了一个呆子。否则，那就真的...真的是一个悲剧啊。</p>
<p>片刻之后，士兵弯腰凑到了床边，轻轻地握住了凯瑞的肩膀，这幼小的身躯此时正不停地颤抖。他对他说道：“振作些，孩子。我带你去见我的长官，也许他能够给你一些帮助。”说着他低头望了望地板。在这一握之下，凯瑞也回过神来，神情恢复了些许。他看向了眼前的这个充满善意的士兵，这确实不是他所熟悉的任何一个人，并且此刻他也注意到了这个士兵战甲上的军徽，这不是暴风城的军徽。原来这一切都是真的，弯刀，斧头，血...那一切都是真的，那么阿诺哥哥，那些陪同他一起来的战士，还有那些随行的商人，也全都死了。想到这里，凯瑞沉重的内心猛然间又更加地沉重，眼泪也不知不觉地从眼眶里溢了出来。他努力地支起身体，并对身前的士兵点了点头。此时，他的身体仍在打颤，仿佛随时都会再倒下去。眼见如此，那位士兵又伸出另一只手将他扶住，拖着他站了起来，并将一只手托在他腋下，以防他跌倒。</p>
<p>凯瑞再次对士兵点了点头以示感谢，他嘴角已忍不住抽动了一下,想要对这名士兵说声“谢谢”，但又被他强行忍住了。他知道他说不出来，并非因为他性情傲慢，也不是因为这次打击让他失去了理智。他是真真切切地说不出来了，就在他刚醒过来呼一口气的时候，他就感觉自己的嘴里空荡荡的好像少了什么东西。直到那名士兵开口和他说话他想要回答时才发现，他的舌头不见了。</p>
]]></description><pubDate>Mon May 21 2012 19:43:09 GMT+0000 (Coordinated Universal Time)</pubDate><link>https://blog.wxsm.space/p/paladitch-chapter-1</link><guid isPermaLink="true">https://blog.wxsm.space/p/paladitch-chapter-1</guid></item></channel></rss>

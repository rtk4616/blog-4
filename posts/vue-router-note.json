{"id":"vue-router-note","title":"Vue-Router Note","date":"2017-11-06T02:47:50.094Z","categories":["JavaScript"],"tags":["Vue","Router"],"index":true,"draft":false,"html":"<p>Vue Router (<a href=\"https://github.com/vuejs/vue-router\">https://github.com/vuejs/vue-router</a>) 使用笔记。虽然<a href=\"https://router.vuejs.org/\">官方文档</a>比较详尽，但实际用起来依然有些地方需要特别注意的（其实主要是我的个人需求）。</p>\n<!--more-->\n<h2 id=\"scroll-behaviours\">Scroll Behaviours <a class=\"header-anchor\" href=\"#scroll-behaviours\" aria-hidden=\"true\">&#128279;</a></h2>\n<p>文档上有 scroll behaviours 的示例，但实际上用起来不太完美，还需要自己改造一下。需要注意的是 <code>scrollBehavior</code> 必须搭配 <code>history</code> 模式，否则代码无效且无任何错误信息。</p>\n<p>上面说到<strong>不完美</strong>的地方主要是在模拟 'scroll to anchor' 这一行为时，文档的代码是不够好的：</p>\n<pre><code class=\"language-javascript\">scrollBehavior (to, <span class=\"hljs-keyword\">from</span>, savedPosition) {\n  <span class=\"hljs-keyword\">if</span> (to.hash) {\n    <span class=\"hljs-keyword\">return</span> {\n      <span class=\"hljs-attr\">selector</span>: to.hash\n    }\n  }\n}\n</code></pre>\n<p>这里实际上会调用 <code>querySelector(to.hash)</code> 来实现滚动，但是用起来会发现有些时候这段会报错，因为类似 <code>#1-anything</code> 这样的数字（或者其他非字母字符）打头的 hash 作为 selector 是 <strong>Invalid</strong> 的。但是要修复只需要稍微改动一下就好了：</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">if</span> (to.hash) {\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-attr\">selector</span>: <span class=\"hljs-string\">`[id='<span class=\"hljs-subst\">${to.hash.slice(<span class=\"hljs-number\">1</span>)}</span>']`</span>\n  }\n}\n</code></pre>\n<p>所以一段完善的 scroll behaviour 代码应该是：</p>\n<pre><code class=\"language-javascript\">scrollBehavior (to, <span class=\"hljs-keyword\">from</span>, savedPosition) {\n  <span class=\"hljs-keyword\">if</span> (to.hash) {\n    <span class=\"hljs-keyword\">return</span> {\n      <span class=\"hljs-attr\">selector</span>: <span class=\"hljs-string\">`[id='<span class=\"hljs-subst\">${to.hash.slice(<span class=\"hljs-number\">1</span>)}</span>']`</span>\n    }\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (savedPosition) {\n    <span class=\"hljs-keyword\">return</span> savedPosition\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-keyword\">return</span> {<span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">0</span>}\n  }\n}\n</code></pre>\n<p>它可以做到在路由变化时：</p>\n<ol>\n<li>有锚点时滚动到锚点</li>\n<li>有历史位置时滚动到历史位置</li>\n<li>都没有时滚动到页头</li>\n</ol>\n<h2 id=\"lazy-loading\">Lazy Loading <a class=\"header-anchor\" href=\"#lazy-loading\" aria-hidden=\"true\">&#128279;</a></h2>\n<p>官方的 Lazy load 示例代码换了很多茬，比如之前有类似 <code>require('...', resolve)</code> 的，还有用 <code>System.import</code> 的，但是它们并不能向后兼容，所以如果用的是新版本的话，并不能够直接 copy 旧项目的方式。目前感觉会稳定下来的方式是：</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">const</span> Foo = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">'./Foo.vue'</span>)\n</code></pre>\n<p>但是这里又有一个注意点，以上语法必须引入一个 babel 插件 <a href=\"https://babeljs.io/docs/plugins/syntax-dynamic-import/\">syntax-dynamic-import</a> 才行：</p>\n<pre><code class=\"language-bash\">npm install --save-dev babel-plugin-syntax-dynamic-import\n</code></pre>\n<p><strong>.babelrc</strong></p>\n<pre><code class=\"language-json\">{\n  <span class=\"hljs-attr\">\"plugins\"</span>: [<span class=\"hljs-string\">\"syntax-dynamic-import\"</span>]\n}\n</code></pre>\n<p>以上就可以在 webpack + babel 的环境下实现代码分块了。</p>\n<h2 id=\"progress\">Progress <a class=\"header-anchor\" href=\"#progress\" aria-hidden=\"true\">&#128279;</a></h2>\n<p>经常会有这样的需求（尤其是使用 lazy load 时）：路由跳转时提供一个进度条（像 Github 头部那种），然而 Vue Router 没有提供这方面的示例。经过实际使用发现，并不需要刻意使用 Vue 封装的进度条，比如说轻量级的 <a href=\"https://github.com/rstacruz/nprogress\">nprogress</a> 也可以很好地搭配使用。</p>\n<p>但是需要注意的是，Vue Router 会将 hash 跳转也视为一次 route 跳转，因此如果在全局钩子中注册 progress 方法的话，那么它也会在 hash 跳转中出现，实际上应该是不需要的。所以需要一点点判断：</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">import</span> NProgress <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'nprogress'</span>\n\n<span class=\"hljs-comment\">// ...</span>\n\nrouter.beforeEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">to, <span class=\"hljs-keyword\">from</span>, next</span>) =&gt;</span> {\n  <span class=\"hljs-comment\">// not start progressbar on same path &amp;&amp; not the same hash</span>\n  <span class=\"hljs-comment\">// which means hash jumping inside a route</span>\n  <span class=\"hljs-keyword\">if</span> (!(<span class=\"hljs-keyword\">from</span>.path === to.path &amp;&amp; <span class=\"hljs-keyword\">from</span>.hash !== to.hash)) {\n    NProgress.start()\n  }\n  next()\n})\n\nrouter.afterEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">to, <span class=\"hljs-keyword\">from</span></span>) =&gt;</span> {\n  <span class=\"hljs-comment\">// Finish progress</span>\n  NProgress.done()\n})\n</code></pre>\n<p>以上就是一个简单的页面跳转进度条示例，它会在<strong>除了同页 hash 跳转以外的所有页面跳转</strong>行为发生时，在页头显示一个简单的进度条。</p>\n<h2 id=\"active-style\">Active Style <a class=\"header-anchor\" href=\"#active-style\" aria-hidden=\"true\">&#128279;</a></h2>\n<p>当使用 <code>&lt;router-link&gt;</code> 的时候，Vue Router 会自动给当前路由的 link 加一个 active class，用来做 nav menu 时非常方便。但是有一点需要注意的是，它默认并不是一个精确匹配的模式，而是一个 <strong>matchStart</strong>，比如说 <code>&lt;router-link to=&quot;/a&quot;&gt;</code> 会被一个 <code>/a/b</code> 的路由激活，更甚者，<code>&lt;router-link to=&quot;/&quot;&gt;</code> 会被所有路由激活（真的）。然而这一般来说都不会是想要的结果。</p>\n<p>在老旧版本（0.x）的 Vue-Router 中这个问题是无解的，现在则<strong>可以使用 <code>&lt;router-link exact&gt;</code> 来将它转换为精确匹配</strong>。</p>\n<h2 id=\"route-reuse\">Route Reuse <a class=\"header-anchor\" href=\"#route-reuse\" aria-hidden=\"true\">&#128279;</a></h2>\n<p>当使用 <code>&lt;router-view&gt;</code> 时，默认会启用组件复用，也就是说在可能的情况下，作为路由页面的组件不会被销毁重建，而是直接复用。</p>\n<p>就好像一个博客的文章页面，一般来说会是给出这样的路由配置：<code>/post/:id</code>，那么在从 <code>/post/1</code> 跳转到 <code>/post/2</code> 的时候，实际上路由组件是不会重建的。</p>\n<p>有时候我们会想要避免这样的事情发生，因为一个路由可能在创建的时候有比较多的逻辑（如数据动态获取、判断等），如果它在路由变化的时候直接复用的话，那么 <code>mount</code> 方法将不再被调用，我们还要为 <code>update</code> 再写一套类似的逻辑。<strong>更过分的是</strong>，其所用到的所有子组件也不再会执行 <code>mount</code> 方法，那么我们要为所有子组件编写 <code>update</code> 方法。非常麻烦。</p>\n<p>不知道为什么，老版本的文档是有为这种情况提供解决方案的，但是在现在的文档里面找不到了。实际上很简单：</p>\n<pre><code class=\"language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">router-view</span> <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"$route.path\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">router-view</span>&gt;</span>\n</code></pre>\n<p>就这样就可以了。如此一来，<strong>只要在 <code>$route.path</code> 变化的时候，路由组件就会被销毁重建</strong>。用一点点的性能损耗，节省大量冗余代码。</p>\n<p>当然这里也可以使用定制化逻辑来控制，比如使用 computed value 来实现更复杂的复用逻辑。</p>\n"}
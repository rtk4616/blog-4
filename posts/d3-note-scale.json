{"id":"d3-note-scale","title":"D3 Note - Scale","date":"2016-11-22T09:00:00.000Z","categories":["JavaScript"],"tags":["D3"],"html":"<p>之前做的柱状图例子：</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">let</span> data = [<span class=\"hljs-number\">250</span>, <span class=\"hljs-number\">210</span>, <span class=\"hljs-number\">170</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">190</span>]\n\n<span class=\"hljs-keyword\">let</span> rectWidth = <span class=\"hljs-number\">25</span>\n\nsvg.selectAll(<span class=\"hljs-string\">'rect'</span>)\n .data(data)\n .enter()\n .append(<span class=\"hljs-string\">'rect'</span>)\n .attr(<span class=\"hljs-string\">'y'</span>, (d, i) =&gt; height - d)\n .attr(<span class=\"hljs-string\">'x'</span>, (d, i) =&gt; i * rectWidth)\n .attr(<span class=\"hljs-string\">'height'</span>, d =&gt; d)\n .attr(<span class=\"hljs-string\">'width'</span>, rectWidth - <span class=\"hljs-number\">2</span>)\n .attr(<span class=\"hljs-string\">'fill'</span>, <span class=\"hljs-string\">'steelblue'</span>)\n</code></pre>\n<p>有一个严重的问题，就是没有比例尺的概念，柱状图的高度完全由数据转换成像素值来模拟。这明显是不科学的：如果数据的值过小或过大，作出来的图就会很奇怪，同时也无法做到非线性的映射。</p>\n<p>就跟地图需要比例尺一样，绝大多数的数据图表也需要比例尺。</p>\n<blockquote>\n<p>Scales are a convenient abstraction for a fundamental task in visualization: mapping a dimension of abstract data to a visual representation.</p>\n</blockquote>\n<p><strong>比例尺 - Scale - “将某个维度的抽象数据做可视化映射”</strong></p>\n<p>至于可视化映射的具体实现，<code>d3-scale</code> 模块提供了许多方案，大致可以分为两类：</p>\n<ul>\n<li>Continuous Scales（连续映射）</li>\n<li>Ordinal Scales（散点映射）</li>\n</ul>\n<!--more-->\n<h2 id=\"continuous-scales\">Continuous Scales <a class=\"header-anchor\" href=\"#continuous-scales\" aria-hidden=\"true\">&#128279;</a></h2>\n<p>Continuous Scales（连续映射）将连续的、定量的 <strong>Input Domain</strong>（定义域）映射为一个连续的 <strong>Output Range</strong>（值域）。如果 Range 也是一个数值范围，那么映射操作可以被反转（即从值域到定义域）。</p>\n<p>连续值映射是一个抽象的概念，不能直接构造。因此，<code>d3-scale</code> 提供了一些具体实现，如线性、次方、对数等。</p>\n<p>一个简单的例子：</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">let</span> x = d3.scaleLinear()\n    .domain([<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">130</span>])\n    .range([<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">960</span>]);\n\nx(<span class=\"hljs-number\">20</span>); <span class=\"hljs-comment\">// 80</span>\nx(<span class=\"hljs-number\">50</span>); <span class=\"hljs-comment\">// 320</span>\n</code></pre>\n<p>这里构造了一个 <code>scaleLinear</code> （线性比例尺），并设置了输入及输出范围。构造器将会返回一个函数，这个函数接受输入值，并且返回对应的输出值。</p>\n<p>如果输入值超出了预定义的范围，那么自然而然地，函数返回的输出值也会超出范围。但是，D3 提供了一个选项 <code>clamp</code>, 可以将输出范围保持在定义值内：</p>\n<pre><code class=\"language-js\">x.clamp(<span class=\"hljs-literal\">true</span>);\nx(<span class=\"hljs-number\">-10</span>); <span class=\"hljs-comment\">// 0, clamped to range</span>\n</code></pre>\n<p>Output Domain 除了可以为数字，也可以是其它东西。比如颜色：</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">let</span> color = d3.scaleLinear()\n    .domain([<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">100</span>])\n    .range([<span class=\"hljs-string\">\"brown\"</span>, <span class=\"hljs-string\">\"steelblue\"</span>]);\n\ncolor(<span class=\"hljs-number\">20</span>); <span class=\"hljs-comment\">// \"#9a3439\"</span>\ncolor(<span class=\"hljs-number\">50</span>); <span class=\"hljs-comment\">// \"#7b5167\"</span>\n</code></pre>\n<p>同时，Continuous Scales 也支持<strong>插值</strong>（interpolate）操作，这是 D3 的另一个模块。</p>\n<h3 id=\"linear-scales\">Linear Scales <a class=\"header-anchor\" href=\"#linear-scales\" aria-hidden=\"true\">&#128279;</a></h3>\n<p><strong>线性比例尺</strong>，顾名思义，输出值对于输入值而言是线性变化的。</p>\n<blockquote>\n<p>y = ax + b</p>\n</blockquote>\n<h3 id=\"power-scales\">Power Scales <a class=\"header-anchor\" href=\"#power-scales\" aria-hidden=\"true\">&#128279;</a></h3>\n<p><strong>次方比例尺</strong>，与 Linear Scales 类似，但是需要多加一个参数：<code>exponent</code> （次方）</p>\n<blockquote>\n<p>y = mx^k + b</p>\n</blockquote>\n<pre><code class=\"language-js\">pow.exponent([exponent]) <span class=\"hljs-comment\">// default 1</span>\n</code></pre>\n<p>在需要做次方根的时候，使 <code>exponent = 0.x</code> 就可以了，对于 0.5 这个特值，D3 还提供了快捷方式：<code>d3.scaleSqrt()</code>，这将直接构造 <code>exponent = 0.5</code> 的 Power Scale</p>\n<h3 id=\"log-scales\">Log Scales <a class=\"header-anchor\" href=\"#log-scales\" aria-hidden=\"true\">&#128279;</a></h3>\n<p><strong>对数比例尺</strong>，与 Power Scales 类似，参数变为 <code>base</code> （底数）</p>\n<blockquote>\n<p>y = m log(x) + b</p>\n</blockquote>\n<p>因为 log(0) = -∞，Log Scales 的 Input Domain 不能够跨越 0，即要么全为正，要么全为负</p>\n<h3 id=\"identity-scales\">Identity Scales <a class=\"header-anchor\" href=\"#identity-scales\" aria-hidden=\"true\">&#128279;</a></h3>\n<p><strong>全等比例尺</strong>，特殊的线性比例尺。定义域与值域完全相等。因此，它的 <code>invert</code> 方法也就是它本身。</p>\n<blockquote>\n<p>y = x</p>\n</blockquote>\n<h3 id=\"time-scales\">Time Scales <a class=\"header-anchor\" href=\"#time-scales\" aria-hidden=\"true\">&#128279;</a></h3>\n<p><strong>时间比例尺</strong>，线性比例尺的变体。例子：</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">let</span> x = d3.scaleTime()\n    .domain([<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(<span class=\"hljs-number\">2000</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>), <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(<span class=\"hljs-number\">2000</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>)])\n    .range([<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">960</span>]);\n\nx(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(<span class=\"hljs-number\">2000</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>,  <span class=\"hljs-number\">5</span>)); <span class=\"hljs-comment\">// 200</span>\nx(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(<span class=\"hljs-number\">2000</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">16</span>)); <span class=\"hljs-comment\">// 640</span>\nx.invert(<span class=\"hljs-number\">200</span>); <span class=\"hljs-comment\">// Sat Jan 01 2000 05:00:00 GMT-0800 (PST)</span>\nx.invert(<span class=\"hljs-number\">640</span>); <span class=\"hljs-comment\">// Sat Jan 01 2000 16:00:00 GMT-0800 (PST)</span>\n</code></pre>\n<h2 id=\"sequential-scales\">Sequential Scales <a class=\"header-anchor\" href=\"#sequential-scales\" aria-hidden=\"true\">&#128279;</a></h2>\n<p><strong>Sequential Scales</strong> 与 <strong>Continuous Scales</strong> 类似，区别是，这个比例尺的值域是由 <code>interpolator</code> 决定的，不可控制。同时，<code>invert</code>, <code>range</code>, <code>rangeRound</code> 以及 <code>interpolate</code> 都不可用。</p>\n<p>D3 提供了一系列的颜色插值器，因此其应用场景多与连续的颜色值域有关。</p>\n<h2 id=\"quantize-scales\">Quantize Scales <a class=\"header-anchor\" href=\"#quantize-scales\" aria-hidden=\"true\">&#128279;</a></h2>\n<p><strong>Quantize Scales</strong> 与 <strong>Linear Scales</strong> 类似，区别是，其值域是离散的。定义域将基于值域元素的个数被切割为<strong>相等的线段</strong>，输出值为线段到值域的<strong>一对一映射</strong>。</p>\n<blockquote>\n<p>y = m round(x) + b</p>\n</blockquote>\n<p>例子：</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">let</span> color = d3.scaleQuantize()\n    .domain([<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>])\n    .range([<span class=\"hljs-string\">\"brown\"</span>, <span class=\"hljs-string\">\"steelblue\"</span>]);\n\ncolor(<span class=\"hljs-number\">0.49</span>); <span class=\"hljs-comment\">// \"brown\"</span>\ncolor(<span class=\"hljs-number\">0.51</span>); <span class=\"hljs-comment\">// \"steelblue\"</span>\n</code></pre>\n<h2 id=\"quantile-scales\">Quantile Scales <a class=\"header-anchor\" href=\"#quantile-scales\" aria-hidden=\"true\">&#128279;</a></h2>\n<p><strong>Quantile scales</strong> 与 <strong>Quantize Scales</strong> 类似，区别是，其值域是“离散连续的”，即“<strong>离散的连续片段</strong>”。</p>\n<p>首先，构造器会对定义域进行排序操作，然后根据值域元素的个数切分为<strong>相等的片段</strong>。如果无法等分，多余的元素将被加入到最后一组。</p>\n<p>如：</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">let</span> quantile = d3.scaleQuantile()\n  .domain([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">16</span>])\n  .range([<span class=\"hljs-string\">'blue'</span>, <span class=\"hljs-string\">'white'</span>, <span class=\"hljs-string\">'red'</span>]);\n\nquantile(<span class=\"hljs-number\">3</span>)   <span class=\"hljs-comment\">// will output \"red\"</span>\nquantile(<span class=\"hljs-number\">16</span>)  <span class=\"hljs-comment\">// will output \"red\"</span>\n</code></pre>\n<p>解析：</p>\n<p>其定义域将先被排序，而后被切分为 3 个片段：<code>[1, 1], [2, 2], [3, 3, 16]</code></p>\n<p>此时，如果执行 <code>quantile.quantiles()</code>，将得到一个数组 <code>[2, 3]</code>，长度为值域长度减一。假设将其赋值为 <code>quantiles</code>，其含义为：</p>\n<ul>\n<li>定义域中小于 <code>quantiles[0]</code> 的值的，将被划分到第一个片段</li>\n<li>大于等于数组元素 <code>quantiles[0]</code> 的值但是小于数组元素 <code>quantiles[1]</code> 的值的，将被划分到第二个片段</li>\n<li>以此类推</li>\n</ul>\n<p>划分线段后，定义域就与值域成为一一对应的关系了。因此就有了以上结果。</p>\n<h2 id=\"threshold-scales\">Threshold Scales <a class=\"header-anchor\" href=\"#threshold-scales\" aria-hidden=\"true\">&#128279;</a></h2>\n<p><strong>Threshold scales</strong> 与 <strong>Quantile Scales</strong> 类似，区别是，我们将往 <code>domain</code> 中 直接传入与前者类似的 <code>quantiles</code>，也就是说，真正的定义域不做限制，限制的是它<strong>划分片段的方式</strong>。</p>\n<p>例子：</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">let</span> color = d3.scaleThreshold()\n    .domain([<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>])\n    .range([<span class=\"hljs-string\">\"red\"</span>, <span class=\"hljs-string\">\"white\"</span>, <span class=\"hljs-string\">\"green\"</span>]);\n\ncolor(<span class=\"hljs-number\">-1</span>);   <span class=\"hljs-comment\">// \"red\"</span>\ncolor(<span class=\"hljs-number\">0</span>);    <span class=\"hljs-comment\">// \"white\"</span>\ncolor(<span class=\"hljs-number\">0.5</span>);  <span class=\"hljs-comment\">// \"white\"</span>\ncolor(<span class=\"hljs-number\">1</span>);    <span class=\"hljs-comment\">// \"green\"</span>\ncolor(<span class=\"hljs-number\">1000</span>); <span class=\"hljs-comment\">// \"green\"</span>\n</code></pre>\n<h2 id=\"ordinal-scales\">Ordinal Scales <a class=\"header-anchor\" href=\"#ordinal-scales\" aria-hidden=\"true\">&#128279;</a></h2>\n<p><strong>Ordinal Scales</strong>（散点映射）</p>\n<p>与连续映射不同，散点映射接受<strong>离散的定义域与值域</strong>。比如在一个博客中把不同的标签映射到一组颜色上去等。如果值域的元素量比定义域少，那么值域会“重复使用”。如：</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">let</span> ordinal = d3.scaleOrdinal()\n  .domain([<span class=\"hljs-string\">\"apple\"</span>, <span class=\"hljs-string\">\"orange\"</span>, <span class=\"hljs-string\">\"banana\"</span>, <span class=\"hljs-string\">\"grapefruit\"</span>])\n  .range([<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">100</span>]);\n\nordinal(<span class=\"hljs-string\">\"apple\"</span>); <span class=\"hljs-comment\">// 0</span>\nordinal(<span class=\"hljs-string\">\"orange\"</span>); <span class=\"hljs-comment\">// 100</span>\nordinal(<span class=\"hljs-string\">\"banana\"</span>); <span class=\"hljs-comment\">// 0</span>\nordinal(<span class=\"hljs-string\">\"grapefruit\"</span>); <span class=\"hljs-comment\">// 100</span>\n</code></pre>\n<h3 id=\"band-scales\">Band Scales <a class=\"header-anchor\" href=\"#band-scales\" aria-hidden=\"true\">&#128279;</a></h3>\n<p><strong>Band Scales</strong> 与 <strong>Ordinal Scales</strong> 类似，区别是，其<strong>值域是连续的数值</strong>。例子：</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">let</span> band = d3.scaleBand()\n  .domain([<span class=\"hljs-string\">\"apple\"</span>, <span class=\"hljs-string\">\"orange\"</span>, <span class=\"hljs-string\">\"banana\"</span>, <span class=\"hljs-string\">\"grapefruit\"</span>])\n  .range([<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">100</span>]);\n\nband(<span class=\"hljs-string\">\"apple\"</span>); <span class=\"hljs-comment\">// 0</span>\nband(<span class=\"hljs-string\">\"orange\"</span>); <span class=\"hljs-comment\">// 25</span>\nband(<span class=\"hljs-string\">\"banana\"</span>); <span class=\"hljs-comment\">// 50</span>\nband(<span class=\"hljs-string\">\"grapefruit\"</span>); <span class=\"hljs-comment\">// 75</span>\n</code></pre>\n<p>Band Scales 提供了一些实用方法，用于控制映射的结果。比如获取 Band Width，强制转换整数，添加 Padding 等。</p>\n<h3 id=\"point-scales\">Point Scales <a class=\"header-anchor\" href=\"#point-scales\" aria-hidden=\"true\">&#128279;</a></h3>\n<p><strong>Point Scales</strong> 是 <strong>Band Scales</strong> 的特例，它的 <strong>Band Width 始终为 0</strong></p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">let</span> point = d3.scalePoint()\n  .domain([<span class=\"hljs-string\">\"apple\"</span>, <span class=\"hljs-string\">\"orange\"</span>, <span class=\"hljs-string\">\"banana\"</span>, <span class=\"hljs-string\">\"grapefruit\"</span>])\n  .range([<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">100</span>]);\n\npoint(<span class=\"hljs-string\">\"apple\"</span>); <span class=\"hljs-comment\">// 0</span>\npoint(<span class=\"hljs-string\">\"orange\"</span>); <span class=\"hljs-comment\">// 33.333333333333336</span>\npoint(<span class=\"hljs-string\">\"banana\"</span>); <span class=\"hljs-comment\">// 66.66666666666667</span>\npoint(<span class=\"hljs-string\">\"grapefruit\"</span>); <span class=\"hljs-comment\">// 100</span>\n</code></pre>\n"}
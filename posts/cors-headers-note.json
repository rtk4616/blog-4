{"id":"cors-headers-note","title":"CORS Headers Note","date":"2017-10-12T06:44:39.617Z","categories":["Web-Front-end"],"tags":["Ajax","HTTP","NodeJs"],"index":true,"draft":false,"html":"<p>CORS HTTP Header 是解决 Ajax 跨域问题的方案之一。详情查看：<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS\">MDN</a></p>\n<p>这篇文章主要是记录使用过程中遇到的问题以及解决方案。</p>\n<!--more-->\n<h2 id=\"\">客户端 <a class=\"header-anchor\" href=\"#\" aria-hidden=\"true\">&#128279;</a></h2>\n<p>客户端正常情况无需特殊配置。但有一些需要注意的地方。</p>\n<h3 id=\"-2\">请求预检 <a class=\"header-anchor\" href=\"#-2\" aria-hidden=\"true\">&#128279;</a></h3>\n<p>CORS 请求与非跨域请求不一样的是，它会将请求分成两种类型：<strong>Simple Request（简单请求）<strong>与</strong>Preflighted Request（预检请求）</strong>。</p>\n<h4 id=\"simple-request\">Simple Request <a class=\"header-anchor\" href=\"#simple-request\" aria-hidden=\"true\">&#128279;</a></h4>\n<p>满足<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS#Simple_requests\">所有条件</a>的请求为简单请求。</p>\n<p>看了文档以后发现跟普通请求别无二致。</p>\n<h4 id=\"preflighted-request\">Preflighted Request <a class=\"header-anchor\" href=\"#preflighted-request\" aria-hidden=\"true\">&#128279;</a></h4>\n<p>满足<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS#Preflighted_requests\">任一条件</a>的请求为预检请求。</p>\n<p>与简单请求不同，预检请求要求必须首先使用 <code>OPTIONS</code> 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求，以避免跨域请求对服务器的用户数据产生未预期的影响。</p>\n<p><img src=\"https://mdn.mozillademos.org/files/14289/prelight.png\" alt=\"预检请求示意图\"></p>\n<p>所以，实际上这种跨域请求会产生两次 HTTP Request：一个预检请求，以及预检成功后的真正的请求。由于预检请求使用 <code>OPTIONS</code> 方法而不是常见的 <code>POST</code> 等，因此服务器必须为跨域 API 提供能够正确返回的相应方法。</p>\n<h3 id=\"-3\">身份验证 <a class=\"header-anchor\" href=\"#-3\" aria-hidden=\"true\">&#128279;</a></h3>\n<p>如果需要进行 Cookie / Session / HTTP Authentication 等操作，则必须在进行 Ajax 请求时带上一个 <code>withCredentials</code> 参数。至于如何带这个参数，每个 Lib 应该都有自己的配置方式，下面是两个例子。</p>\n<p>Raw Ajax Example:</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> invocation = <span class=\"hljs-keyword\">new</span> XMLHttpRequest();\n<span class=\"hljs-keyword\">var</span> url = <span class=\"hljs-string\">'http://bar.other/resources/credentialed-content/'</span>;\n    \n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">callOtherDomain</span>(<span class=\"hljs-params\"></span>)</span>{\n  <span class=\"hljs-keyword\">if</span>(invocation) {\n    invocation.open(<span class=\"hljs-string\">'GET'</span>, url, <span class=\"hljs-literal\">true</span>);\n    invocation.withCredentials = <span class=\"hljs-literal\">true</span>;\n    invocation.onreadystatechange = handler;\n    invocation.send(); \n  }\n}\n</code></pre>\n<p>Using Axios Example:</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">let</span> corsAgent = axios.create({\n  <span class=\"hljs-attr\">withCredentials</span>: <span class=\"hljs-literal\">true</span>\n})\n</code></pre>\n<h2 id=\"-4\">服务端 <a class=\"header-anchor\" href=\"#-4\" aria-hidden=\"true\">&#128279;</a></h2>\n<p>服务端的配置并不是只需要给请求响应加个 <code>Access-Control-Allow-Origin</code> Header 这么简单，还有其它需要处理的地方。因此自己做远不如直接使用相关 Lib 来得方便。比如：</p>\n<ul>\n<li><a href=\"https://github.com/expressjs/cors\">Express CORS</a></li>\n<li><a href=\"https://github.com/koajs/cors\">Koa CORS</a></li>\n</ul>\n<h3 id=\"withcredentials\">withCredentials <a class=\"header-anchor\" href=\"#withcredentials\" aria-hidden=\"true\">&#128279;</a></h3>\n<p>当启用 <code>withCredentials</code> 参数后，<code>Access-Control-Allow-Origin</code> 将不能设置为 <code>*</code> （允许所有域名），必须指定为唯一的域名，否则预期的效果将无法达到。由于这个规则不会产生 Warning 或 Error，出了问题不了解情况的话还是比较难发现的。</p>\n<p>可以预见（事实）的是，当 <code>Access-Control-Allow-Origin</code> 指定了唯一域名后，使用其它域名访问该 API 也会出现无效的问题。不过相应地也有一个取巧的办法，就是将它设置为 Request 的 Origin Header，这样一来问题就解决了。</p>\n"}
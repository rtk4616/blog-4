{"id":"angular-tutorial-two-way-data-binding","title":"Angular 教程：双向绑定","date":"2015-12-26T18:01:24.000Z","categories":["JavaScript"],"tags":["AngularJs"],"html":"<p>在这一步中，你将会通过添加一个新的模型变量给手机列表增加一个动态排序功能 。这个功能通过给循环器添加一个新的属性实现，然后让数据绑定来自动完成其余的工作。</p>\n<ul>\n<li>现在除了搜索框，应用还显示了一个允许用户对手机列表进行排序的下拉框</li>\n</ul>\n<!--more--> 最重要的改动如下所示。你可以在\n<p><a href=\"https://github.com/angular/angular-phonecat/compare/step-3...step-4\" title=\"See diff on Github\">GitHub</a>上查看它与之前的代码有何区别。</p>\n<hr>\n<h2 id=\"\">模板 <a class=\"header-anchor\" href=\"#\" aria-hidden=\"true\">&#128279;</a></h2>\n<p><code>app/index.html</code>：</p>\n<pre><code>Search: &lt;input ng-model=&quot;query&quot;&gt;\nSort by:\n&lt;select ng-model=&quot;orderProp&quot;&gt;\n  &lt;option value=&quot;name&quot;&gt;Alphabetical&lt;/option&gt;\n  &lt;option value=&quot;age&quot;&gt;Newest&lt;/option&gt;\n&lt;/select&gt;\n\n\n&lt;ul class=&quot;phones&quot;&gt;\n  &lt;li ng-repeat=&quot;phone in phones | filter:query | orderBy:orderProp&quot;&gt;\n    &lt;span&gt;{{phone.name}}&lt;/span&gt;\n    &lt;p&gt;{{phone.snippet}}&lt;/p&gt;\n  &lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n<p>我们对<code>index.html</code>模板进行了如下修改：</p>\n<ul>\n<li>首先，我们在HTML中添加了一个名叫<code>orderProp</code>的<code>&lt;select&gt;</code>节点，然后用户才能选择他们想要的排序方式</li>\n<li>然后我们把<code>orderBy</code>过滤器串联到了<code>filter</code>过滤器的后面，它可以对循环器的输入再做进一步的处理。<code>orderBy</code>过滤器会接受一个输入数组，复制并且返回排序后的副本</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/wxsms/wxsms-img-holder/master/tutorial_04.png\" alt=\"\"></p>\n<p>Angular为选中的元素与<code>orderProp</code>模型创建了一个双向的数据绑定。<code>orderProp</code>于是就作为了<code>orderBy</code>过滤器的一个输入。 正如我们在Step 3中讨论过的有关数据绑定与循环器的内容，无论模型在何时发生变化（比如用户改变下拉框的值），Angular的数据绑定都会引起视图的自动刷新。我们再也不用编写任何臃肿的DOM维护代码了！</p>\n<hr>\n<h2 id=\"-2\">控制器 <a class=\"header-anchor\" href=\"#-2\" aria-hidden=\"true\">&#128279;</a></h2>\n<p><code>app/js/controllers.js</code>：</p>\n<pre><code>var phonecatApp = angular.module('phonecatApp', []);\n\nphonecatApp.controller('PhoneListCtrl', function ($scope) {\n  $scope.phones = [\n    {'name': 'Nexus S',\n     'snippet': 'Fast just got faster with Nexus S.',\n     'age': 1},\n    {'name': 'Motorola XOOM™ with Wi-Fi',\n     'snippet': 'The Next, Next Generation tablet.',\n     'age': 2},\n    {'name': 'MOTOROLA XOOM™',\n     'snippet': 'The Next, Next Generation tablet.',\n     'age': 3}\n  ];\n\n  $scope.orderProp = 'age';\n});\n</code></pre>\n<ul>\n<li>我们对<code>phones</code>模型（就是这个数组）稍微做了些改变，并且给每条记录添加了一个<code>age</code>属性，这个属性是用来排序的</li>\n<li>在最下面的一行我们把默认的排序方式设置成了<code>age</code>。如果我们不在这里设置一个默认值，那么在用户选择一个排序方式以前<code>orderBy</code>过滤器都不会被初始化</li>\n</ul>\n<p>现在我们可以说说双向的数据绑定了。注意当应用在浏览器中加载的时候，下拉列表就已经选中了 Newest 项。这是因为我们在控制器中把<code>orderProp</code>属性的值设置为了<code>age</code>，因此从模型到视图的方向发生了一次绑定。如果你现在选择<code>Alphabetically</code>项的话，模型也会跟着视图发生改变，并且手机列表也会重新进行排序。这就是一次反方向的数据绑定：从视图到模型。</p>\n<hr>\n<h2 id=\"-3\">测试 <a class=\"header-anchor\" href=\"#-3\" aria-hidden=\"true\">&#128279;</a></h2>\n<p>现在我们更新一下单元测试和端到端测试，首先看看单元测试：</p>\n<p><code>test/unit/controllersSpec.js</code>：</p>\n<pre><code>describe('PhoneCat controllers', function() {\n\n  describe('PhoneListCtrl', function(){\n    var scope, ctrl;\n\n    beforeEach(module('phonecatApp'));\n\n    beforeEach(inject(function($controller) {\n      scope = {};\n      ctrl = $controller('PhoneListCtrl', {$scope:scope});\n    }));\n\n    it('should create &quot;phones&quot; model with 3 phones', function() {\n      expect(scope.phones.length).toBe(3);\n    });\n\n\n    it('should set the default value of orderProp model', function() {\n      expect(scope.orderProp).toBe('age');\n    });\n  });\n});\n</code></pre>\n<p>单元测试现在会验证是否设置了一个默认的排序属性。 我们在<code>beforeEach</code>中使用Jasmine的API来构造控制器，因此在父级<code>describe</code>代码块下的所有测试都能共享它。 你应该可以从Karma终端中看到如下结果：</p>\n<pre><code>Chrome 22.0: Executed 2 of 2 SUCCESS (0.021 secs / 0.001 secs)\n</code></pre>\n<p>再来看端到端测试：</p>\n<p><code>test/e2e/scenarios.js</code>：</p>\n<pre><code>...\nit('should be possible to control phone order via the drop down select box', function() {\n\n  var phoneNameColumn = element.all(by.repeater('phone in phones').column('phone.name'));\n  var query = element(by.model('query'));\n\n  function getNames() {\n    return phoneNameColumn.map(function(elm) {\n      return elm.getText();\n    });\n  }\n\n  query.sendKeys('tablet'); //let's narrow the dataset to make the test assertions shorter\n\n  expect(getNames()).toEqual([\n    &quot;Motorola XOOM\\u2122 with Wi-Fi&quot;,\n    &quot;MOTOROLA XOOM\\u2122&quot;\n  ]);\n\n  element(by.model('orderProp')).element(by.css('option[value=&quot;name&quot;]')).click();\n\n  expect(getNames()).toEqual([\n    &quot;MOTOROLA XOOM\\u2122&quot;,\n    &quot;Motorola XOOM\\u2122 with Wi-Fi&quot;\n  ]);\n});...\n</code></pre>\n<p>端到端测试验证了排序的结果是否正确。 你可以执行<code>npm run protractor</code>来观察测试的运行。</p>\n<h2 id=\"-4\">课外扩展 <a class=\"header-anchor\" href=\"#-4\" aria-hidden=\"true\">&#128279;</a></h2>\n<p>在<code>PhoneListCtrl</code>控制器中尝试把初始化<code>orderProp</code>的代码给删除掉，你可以看到Angular会给下拉列表临时添加一个空白的选项作为默认值，并且手机列表会暂时处于原始的排序状态下。 给<code>index.html</code>添加一个<code>{{orderProp}}</code>绑定来观察它的值是如何变化的。 通过给排序值添加一个<code>-</code>号来使排序反向进行：</p>\n<pre><code>&lt;option value=&quot;-age&quot;&gt;Oldest&lt;/option&gt;\n</code></pre>\n<h2 id=\"-5\">总结 <a class=\"header-anchor\" href=\"#-5\" aria-hidden=\"true\">&#128279;</a></h2>\n<p>现在你已经给应用添加了一个排序功能以及相应的测试，快快通过<a href=\"/p/angular-tutorial-xhrs-and-dependency-injection/\">step 5</a>来学习Angular服务（Service）以及如何使用Angular的依赖注入。</p>\n"}
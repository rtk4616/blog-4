{"id":"react-note-basic","title":"React Note - Basic","date":"2017-02-08T11:33:00.000Z","index":true,"categories":["JavaScript"],"tags":["React"],"html":"<p>React 学习笔记（基础篇）。</p>\n<!--more-->\n<h2 id=\"\">安装 <a class=\"header-anchor\" href=\"#\" aria-hidden=\"true\">&#128279;</a></h2>\n<pre><code class=\"language-bash\">npm install -g create-react-app\ncreate-react-app hello-world\n<span class=\"hljs-built_in\">cd</span> hello-world\nnpm start\n</code></pre>\n<p>实践：create 这一步会同时执行 <code>npm install</code> 因此有失败的可能，多尝试几次就成功了。</p>\n<p>这个程序跟 vue-loader 很像，会造出一个简单的手脚架，包含了 Babel 编译器以及打包工具等等。但是细看它的 <code>package.json</code> 文件并没有包含上述内容：</p>\n<pre><code class=\"language-json\">\"devDependencies\": {\n  \"react-scripts\": \"0.8.5\"\n},\n\"dependencies\": {\n  \"react\": \"^15.4.2\",\n  \"react-dom\": \"^15.4.2\"\n}\n</code></pre>\n<p>因此，跟 vue-loader 不一样的是，react 这个手脚架把无关内容都封装了。这么做我觉得有利有弊：它让人用起来更方便，然而不可能达到直接使用原组件的自由度了。相比之下，这里我更喜欢 vue-loader 的处理方式。</p>\n<h2 id=\"hello-world\">Hello World <a class=\"header-anchor\" href=\"#hello-world\" aria-hidden=\"true\">&#128279;</a></h2>\n<p>最简示例：</p>\n<pre><code class=\"language-js\">ReactDOM.render(\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Hello, world!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>,\n  <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'root'</span>)\n);\n</code></pre>\n<h2 id=\"jsx\">JSX 语法 <a class=\"header-anchor\" href=\"#jsx\" aria-hidden=\"true\">&#128279;</a></h2>\n<p>JSX 是 JavaScript 的一种语法扩展，实际上可以看做是语法糖。通过编译器，以下语法：</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">const</span> element = (\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"greeting\"</span>&gt;</span>\n    Hello, world!\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>\n);\n</code></pre>\n<p>相当于：</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">const</span> element = {\n  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'h1'</span>,\n  <span class=\"hljs-attr\">props</span>: {\n    <span class=\"hljs-attr\">className</span>: <span class=\"hljs-string\">'greeting'</span>,\n    <span class=\"hljs-attr\">children</span>: <span class=\"hljs-string\">'Hello, world'</span>\n  }\n};\n</code></pre>\n<p>后者就是编译后的结果，JSX 语法块变成了一个对象（称之为 <code>React element</code>）。</p>\n<p>（JB 家的 IDE 已经对 JSX 语法提供了默认支持，不然这篇笔记就到此为止了）</p>\n<p>JSX 支持一些稍微高级的用法，如：</p>\n<pre><code class=\"language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">formatName</span>(<span class=\"hljs-params\">user</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> user.firstName + <span class=\"hljs-string\">' '</span> + user.lastName;\n}\n\n<span class=\"hljs-keyword\">const</span> user = {\n  <span class=\"hljs-attr\">firstName</span>: <span class=\"hljs-string\">'Harper'</span>,\n  <span class=\"hljs-attr\">lastName</span>: <span class=\"hljs-string\">'Perez'</span>\n};\n\n<span class=\"hljs-keyword\">const</span> element = (\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>\n    Hello, {formatName(user)}!\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>\n);\n\nReactDOM.render(\n  element,\n  <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'root'</span>)\n);\n</code></pre>\n<p>在任何地方使用 JSX：</p>\n<pre><code class=\"language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getGreeting</span>(<span class=\"hljs-params\">user</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (user) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Hello, {formatName(user)}!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>;\n  }\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Hello, Stranger.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>;\n}\n</code></pre>\n<h2 id=\"-2\">元素 <a class=\"header-anchor\" href=\"#-2\" aria-hidden=\"true\">&#128279;</a></h2>\n<p>上面有说到 <code>React element</code>（元素），<strong>元素</strong>的概念与<strong>组件</strong>不同：元素是组件的组成部分。</p>\n<h3 id=\"-3\">元素渲染 <a class=\"header-anchor\" href=\"#-3\" aria-hidden=\"true\">&#128279;</a></h3>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">const</span> element = <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Hello, world<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>;\nReactDOM.render(\n  element,\n  <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'root'</span>)\n);\n</code></pre>\n<p>显然，它掌控了 DOM 中一个 ID 为 root 的节点，并往里面插入了元素。</p>\n<h3 id=\"-4\">元素更新 <a class=\"header-anchor\" href=\"#-4\" aria-hidden=\"true\">&#128279;</a></h3>\n<p><strong>已创建的元素是无法更新属性的</strong>。因此，如果要改变它，只能够重新创建并渲染一次。</p>\n<p>然而，托虚拟 DOM 的福，重新渲染并不代表重新渲染整个 DOM，React 会查找并只更新有改变的节点。</p>\n<p>但是一般不回这么做。因为有一点很重要：在设计一个元素的时候就要考虑到它在所有状态下的表现。这个其实在其它框架下也是一样的。</p>\n<h2 id=\"-5\">组件 <a class=\"header-anchor\" href=\"#-5\" aria-hidden=\"true\">&#128279;</a></h2>\n<p>React 是组件化框架，因此组件是组成一个应用的基础。组件的特点：独立、可重用。</p>\n<p>组件有两种定义方法：</p>\n<pre><code class=\"language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Welcome</span>(<span class=\"hljs-params\">props</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Hello, {props.name}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>;\n}\n</code></pre>\n<p>或者：</p>\n<pre><code class=\"language-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Welcome</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n  render() {\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Hello, {this.props.name}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>;\n  }\n}\n</code></pre>\n<h3 id=\"-6\">组件渲染 <a class=\"header-anchor\" href=\"#-6\" aria-hidden=\"true\">&#128279;</a></h3>\n<p>一个简单的例子：</p>\n<pre><code class=\"language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Welcome</span>(<span class=\"hljs-params\">props</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Hello, {props.name}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>;\n}\n\n<span class=\"hljs-keyword\">const</span> element = <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Welcome</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"Sara\"</span> /&gt;</span>;\n\nReactDOM.render(\n  element,\n  document.getElementById('root')\n);\n</span></code></pre>\n<p>可以看到元素组成了组件，组件又组成了元素，最后渲染在 DOM 上的是元素。</p>\n<p>这个跟 Vue 很像了，区别是 Vue 没有区分所谓的“元素”跟“组件”，通通都是组件。</p>\n<p>需要注意的是，在 React 世界中有个约定：自定义控件以大写字母打头。这是为了跟 HTML 元素有所区分。</p>\n<h3 id=\"-7\">组件使用与拆解 <a class=\"header-anchor\" href=\"#-7\" aria-hidden=\"true\">&#128279;</a></h3>\n<p>一个简单的例子：</p>\n<pre><code class=\"language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Welcome</span>(<span class=\"hljs-params\">props</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Hello, {props.name}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">App</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">return</span> (\n    &lt;div&gt;\n      &lt;Welcome name=\"Sara\" /&gt;\n      &lt;Welcome name=\"Cahal\" /&gt;\n      &lt;Welcome name=\"Edite\" /&gt;\n    &lt;/div&gt;\n  );\n}\n\nReactDOM.render(\n  &lt;App /&gt;,\n  document.getElementById('root')\n);\n</code></pre>\n<p>需要注意的是，组件只能有一个根节点。（如例子中的 3 个 <code>Welcome</code> 必须包裹在 <code>div</code> 中）</p>\n<h3 id=\"-8\">参数只读 <a class=\"header-anchor\" href=\"#-8\" aria-hidden=\"true\">&#128279;</a></h3>\n<p>简单地说，React 不允许在控件内修改参数（包括值的修改以及对象修改）。允许修改的称之为“状态”（约等于 Vue 中的 component data）</p>\n<h2 id=\"-9\">状态管理与生命周期 <a class=\"header-anchor\" href=\"#-9\" aria-hidden=\"true\">&#128279;</a></h2>\n<h3 id=\"-10\">添加状态管理 <a class=\"header-anchor\" href=\"#-10\" aria-hidden=\"true\">&#128279;</a></h3>\n<p>组件的更新依赖于状态，因此需要实时更新的组件应在其内部建立状态管理机制（低耦合高内聚）。</p>\n<p>需要状态管理机的组件，必须使用 ES6 方式声明，如：</p>\n<pre><code class=\"language-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Clock</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span>(props) {\n    <span class=\"hljs-keyword\">super</span>(props);\n    <span class=\"hljs-keyword\">this</span>.state = {<span class=\"hljs-attr\">date</span>: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>()};\n  }\n\n  render() {\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Hello, world!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span>It is {this.state.date.toLocaleTimeString()}.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n    );\n  }\n}\n\nReactDOM.render(\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Clock</span> /&gt;</span>,\n  document.getElementById('root')\n);\n</span></code></pre>\n<p>但是，此时，组件是无法更新的：因为状态在创建时就已经被决定了。</p>\n<h3 id=\"-11\">添加生命周期 <a class=\"header-anchor\" href=\"#-11\" aria-hidden=\"true\">&#128279;</a></h3>\n<p>代码有注释：</p>\n<pre><code class=\"language-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Clock</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span>(props) {\n    <span class=\"hljs-keyword\">super</span>(props);\n    <span class=\"hljs-keyword\">this</span>.state = {<span class=\"hljs-attr\">date</span>: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>()};\n  }\n\n  <span class=\"hljs-comment\">// 组件渲染到 DOM 后调用</span>\n  componentDidMount() {\n    <span class=\"hljs-keyword\">this</span>.timerID = setInterval(\n      <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-keyword\">this</span>.tick(),\n      <span class=\"hljs-number\">1000</span>\n    );\n  }\n\n  <span class=\"hljs-comment\">// 组件将销毁后调用</span>\n  componentWillUnmount() {\n    clearInterval(<span class=\"hljs-keyword\">this</span>.timerID);\n  }\n  \n  tick() {\n    <span class=\"hljs-keyword\">this</span>.setState({\n      <span class=\"hljs-attr\">date</span>: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>()\n    });\n  }\n\n  render() {\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Hello, world!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span>It is {this.state.date.toLocaleTimeString()}.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n    );\n  }\n}\n\nReactDOM.render(\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Clock</span> /&gt;</span>,\n  document.getElementById('root')\n);\n</span></code></pre>\n<p>整个流程很简单清晰了：</p>\n<ol>\n<li>ReactDOM 渲染 <code>Clock</code>，并对 state 做第一次初始化</li>\n<li><code>render</code> 方法被调用，插入 DOM</li>\n<li><code>componentDidMount</code> 方法被调用，计时器启动，<code>tick</code> 每秒钟执行一次</li>\n<li>每次 <code>tick</code> 执行都调用 <code>setState</code> 方法去更新状态，这样 React 就知道需要更新 DOM 了</li>\n<li>当组件被从 DOM 移除后，<code>componentWillUnmount</code> 执行</li>\n</ol>\n<h3 id=\"-12\">正确使用状态 <a class=\"header-anchor\" href=\"#-12\" aria-hidden=\"true\">&#128279;</a></h3>\n<p>直接更改 state 属性是不会触发 UI 更新的。因此，有一些规则需要遵守。</p>\n<h4 id=\"-13\">不直接修改状态 <a class=\"header-anchor\" href=\"#-13\" aria-hidden=\"true\">&#128279;</a></h4>\n<p>在组件内进行修改状态操作，使用 <code>setState</code> 方法：</p>\n<pre><code class=\"language-js\"><span class=\"hljs-comment\">// Wrong</span>\n<span class=\"hljs-keyword\">this</span>.state.comment = <span class=\"hljs-string\">'Hello'</span>;\n\n<span class=\"hljs-comment\">// Correct</span>\n<span class=\"hljs-keyword\">this</span>.setState({<span class=\"hljs-attr\">comment</span>: <span class=\"hljs-string\">'Hello'</span>});\n</code></pre>\n<h4 id=\"-14\">关于异步更新 <a class=\"header-anchor\" href=\"#-14\" aria-hidden=\"true\">&#128279;</a></h4>\n<pre><code class=\"language-js\"><span class=\"hljs-comment\">// Wrong</span>\n<span class=\"hljs-keyword\">this</span>.setState({\n  <span class=\"hljs-attr\">counter</span>: <span class=\"hljs-keyword\">this</span>.state.counter + <span class=\"hljs-keyword\">this</span>.props.increment,\n});\n\n<span class=\"hljs-comment\">// Correct</span>\n<span class=\"hljs-keyword\">this</span>.setState(<span class=\"hljs-function\">(<span class=\"hljs-params\">prevState, props</span>) =&gt;</span> ({\n  <span class=\"hljs-attr\">counter</span>: prevState.counter + props.increment\n}));\n</code></pre>\n<h4 id=\"-15\">状态合并 <a class=\"header-anchor\" href=\"#-15\" aria-hidden=\"true\">&#128279;</a></h4>\n<p>在进行 <code>setState</code> 的时候，只关心需要更改的属性即可，没有传入的属性会被保留。就好像新的状态被“合并”进入旧状态一样。</p>\n<h3 id=\"-16\">数据流 <a class=\"header-anchor\" href=\"#-16\" aria-hidden=\"true\">&#128279;</a></h3>\n<p>在 React 世界，组件与组件之间的状态传递是单向的，传值的方式就是将 state 当做 prop 传给子组件。</p>\n<h2 id=\"-17\">事件处理 <a class=\"header-anchor\" href=\"#-17\" aria-hidden=\"true\">&#128279;</a></h2>\n<p>跟 DOM 操作很像，区别：</p>\n<ol>\n<li>事件命名使用驼峰式</li>\n<li>直接向 JSX 中传入方法</li>\n<li>不支持 <code>return false</code> 操作</li>\n</ol>\n<p>例：</p>\n<pre><code class=\"language-js\">// DOM\n&lt;button onclick=\"activateLasers()\"&gt;\n  Activate Lasers\n&lt;/button&gt;\n\n// React\n&lt;button onClick={activateLasers}&gt;\n  Activate Lasers\n&lt;/button&gt;\n\n// A prevent default sample\nfunction ActionLink() {\n  function handleClick(e) {\n    e.preventDefault();\n    console.log('The link was clicked.');\n  }\n\n  return (\n    &lt;a href=\"#\" onClick={handleClick}&gt;\n      Click me\n    &lt;/a&gt;\n  );\n}\n\n// A class sample\nclass Toggle extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {isToggleOn: true};\n\n    // This binding is necessary to make `this` work in the callback\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  handleClick() {\n    this.setState(prevState =&gt; ({\n      isToggleOn: !prevState.isToggleOn\n    }));\n  }\n\n  render() {\n    return (\n      &lt;button onClick={this.handleClick}&gt;\n        {this.state.isToggleOn ? 'ON' : 'OFF'}\n      &lt;/button&gt;\n    );\n  }\n}\n</code></pre>\n<p>注意：这个 <code>e</code> 是 React 封装过的，但遵循 W3C 标准，因此无需做浏览器差异化处理。</p>\n<p>另外，<code>this.handleClick.bind</code> 方法是为了保证在 <code>onClick</code> 中调用了正确的 <code>this</code>，但使用箭头函数可以避免这个累赘的方法：</p>\n<pre><code class=\"language-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">LoggingButton</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n  <span class=\"hljs-comment\">// This syntax ensures `this` is bound within handleClick.</span>\n  <span class=\"hljs-comment\">// Warning: this is *experimental* syntax.</span>\n  handleClick = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'this is:'</span>, <span class=\"hljs-keyword\">this</span>);\n  }\n\n  render() {\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{this.handleClick}</span>&gt;</span>\n        Click me\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n    );\n  }\n}\n</code></pre>\n<h2 id=\"-18\">条件渲染 <a class=\"header-anchor\" href=\"#-18\" aria-hidden=\"true\">&#128279;</a></h2>\n<p>例子：</p>\n<pre><code class=\"language-js\">render() {\n  <span class=\"hljs-keyword\">const</span> isLoggedIn = <span class=\"hljs-keyword\">this</span>.state.isLoggedIn;\n  \n  <span class=\"hljs-keyword\">let</span> button = <span class=\"hljs-literal\">null</span>;\n  <span class=\"hljs-keyword\">if</span> (isLoggedIn) {\n    button = &lt;LogoutButton onClick={this.handleLogoutClick} /&gt;;\n  } else {\n    button = &lt;LoginButton onClick={this.handleLoginClick} /&gt;;\n  }\n  \n  return (\n    &lt;div&gt;\n      &lt;Greeting isLoggedIn={isLoggedIn} /&gt;\n      {button}\n    &lt;/div&gt;\n  );\n}\n</code></pre>\n<h3 id=\"-19\">行内判断 <a class=\"header-anchor\" href=\"#-19\" aria-hidden=\"true\">&#128279;</a></h3>\n<p>例子：</p>\n<pre><code class=\"language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Mailbox</span>(<span class=\"hljs-params\">props</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> unreadMessages = props.unreadMessages;\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Hello!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n      {unreadMessages.length &gt; 0 &amp;&amp;\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span>\n          You have {unreadMessages.length} unread messages.\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span>\n      }\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n}\n\n<span class=\"hljs-keyword\">const</span> messages = [<span class=\"hljs-string\">'React'</span>, <span class=\"hljs-string\">'Re: React'</span>, <span class=\"hljs-string\">'Re:Re: React'</span>];\nReactDOM.render(\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Mailbox</span> <span class=\"hljs-attr\">unreadMessages</span>=<span class=\"hljs-string\">{messages}</span> /&gt;</span>,\n  document.getElementById('root')\n);\n</span></code></pre>\n<p>这段代码的工作方式跟 JavaScript 一致：</p>\n<ul>\n<li><code>true &amp;&amp; expression</code> -&gt; <code>expression</code></li>\n<li><code>false &amp;&amp; expression</code> -&gt; <code>false</code></li>\n</ul>\n<p>因此，当 <code>unreadMessages.length &gt; 0</code> 为真时，后面的 JSX 会被渲染，反则不会。</p>\n<p>除此以外还有三元表达式：</p>\n<pre><code class=\"language-js\">render() {\n  <span class=\"hljs-keyword\">const</span> isLoggedIn = <span class=\"hljs-keyword\">this</span>.state.isLoggedIn;\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n      The user is <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">b</span>&gt;</span>{isLoggedIn ? 'currently' : 'not'}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">b</span>&gt;</span> logged in.\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<h3 id=\"-20\">阻止渲染 <a class=\"header-anchor\" href=\"#-20\" aria-hidden=\"true\">&#128279;</a></h3>\n<p>在组件的 <code>render</code> 方法内 <code>return null</code> 会阻止组件的渲染，但是其生命周期不受影响。</p>\n<h2 id=\"-21\">循环 <a class=\"header-anchor\" href=\"#-21\" aria-hidden=\"true\">&#128279;</a></h2>\n<p>一个简单的例子：</p>\n<pre><code class=\"language-js\">const numbers = [1, 2, 3, 4, 5];\nconst listItems = numbers.map((number) =&gt;\n  &lt;li&gt;{number}&lt;/li&gt;\n);\n\nReactDOM.render(\n  &lt;ul&gt;{listItems}&lt;/ul&gt;,\n  document.getElementById('root')\n);\n</code></pre>\n<h3 id=\"-22\">循环组件 <a class=\"header-anchor\" href=\"#-22\" aria-hidden=\"true\">&#128279;</a></h3>\n<p>一个列表组件示例：</p>\n<pre><code class=\"language-js\">function NumberList(props) {\n  const numbers = props.numbers;\n  const listItems = numbers.map((number) =&gt;\n    &lt;li key={number.toString()}&gt;\n      {number}\n    &lt;/li&gt;\n  );\n  return (\n    &lt;ul&gt;{listItems}&lt;/ul&gt;\n  );\n}\n\nconst numbers = [1, 2, 3, 4, 5];\nReactDOM.render(\n  &lt;NumberList numbers={numbers} /&gt;,\n  document.getElementById('root')\n);\n</code></pre>\n<p>注意，这里对列表项添加了一个 <code>key</code> 属性。</p>\n<h3 id=\"key\">Key <a class=\"header-anchor\" href=\"#key\" aria-hidden=\"true\">&#128279;</a></h3>\n<p><code>Key</code> 是 React 用来追踪列表项的一个属性。跟 angular 以及 vue 中 <code>track-by</code> 的概念一样。</p>\n<p>如果列表项没有唯一标识，也可以用索引作为 key （不推荐）：</p>\n<pre><code class=\"language-js\">const todoItems = todos.map((todo, index) =&gt;\n  // Only do this if items have no stable IDs\n  &lt;li key={index}&gt;\n    {todo.text}\n  &lt;/li&gt;\n);\n</code></pre>\n<p>注意：<code>Key</code> 只能直接在数组循环体内定义。如：</p>\n<pre><code class=\"language-js\">function ListItem(props) {\n  const value = props.value;\n  return (\n    // Wrong! There is no need to specify the key here:\n    &lt;li key={value.toString()}&gt;\n      {value}\n    &lt;/li&gt;\n  );\n}\n\nfunction NumberList(props) {\n  const numbers = props.numbers;\n  const listItems = numbers.map((number) =&gt;\n    // Wrong! The key should have been specified here:\n    &lt;ListItem value={number} /&gt;\n  );\n  return (\n    &lt;ul&gt;\n      {listItems}\n    &lt;/ul&gt;\n  );\n}\n</code></pre>\n"}
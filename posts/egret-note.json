{"id":"egret-note","title":"Egret Note","date":"2017-02-22T16:17:00.000Z","index":true,"categories":["JavaScript","Game-Engine"],"tags":["Egret-Engine"],"html":"<p>Egret Engine 的学习笔记。</p>\n<p>Egret Engine 是一款基于 JavaScript 的游戏制作引擎，支持 2D 与 3D 模式，支持 Canvas 与 WebGL 渲染，目前使用 TypeScript 编写。</p>\n<!--more-->\n<h2 id=\"\">显示对象 <a class=\"header-anchor\" href=\"#\" aria-hidden=\"true\">&#128279;</a></h2>\n<p>“显示对象”，准确的含义是可以在舞台上显示的对象。可以显示的对象，既包括可以直接看见的图形、文字、视频、图片等，也包括不能看见但真实存在的显示对象容器。</p>\n<p>在Egret中，视觉图形都是由显示对象和显示对象容器组成的。</p>\n<h3 id=\"-2\">对象树 <a class=\"header-anchor\" href=\"#-2\" aria-hidden=\"true\">&#128279;</a></h3>\n<ul>\n<li>根：舞台 <code>DisplayObjectContainer:Stage</code></li>\n<li>茎：主容器（文档类） <code>DisplayObjectContainer</code></li>\n<li>树枝：容器 <code>DisplayObjectContainer</code></li>\n<li>树叶：显示对象 <code>DisplayObject</code></li>\n</ul>\n<h3 id=\"-3\">对象类型 <a class=\"header-anchor\" href=\"#-3\" aria-hidden=\"true\">&#128279;</a></h3>\n<ul>\n<li><code>DisplayObject</code>\t显示对象基类，所有显示对象均继承自此类</li>\n<li><code>Bitmap</code>\t位图，用来显示图片</li>\n<li><code>Shape</code>\t用来显示矢量图，可以使用其中的方法绘制矢量图形</li>\n<li><code>TextField</code>\t文本类</li>\n<li><code>BitmapText</code>\t位图文本类</li>\n<li><code>DisplayObjectContainer</code>\t显示对象容器接口，所有显示对象容器均实现此接口</li>\n<li><code>Sprite</code>\t带有矢量绘制功能的显示容器</li>\n<li><code>Stage</code>\t舞台类</li>\n</ul>\n<h3 id=\"-4\">基本概念 <a class=\"header-anchor\" href=\"#-4\" aria-hidden=\"true\">&#128279;</a></h3>\n<p>二维坐标系。原点位于<strong>左上角</strong>。</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">var</span> shape:egret.Shape = <span class=\"hljs-keyword\">new</span> egret.Shape();\nshape.x = <span class=\"hljs-number\">100</span>;\nshape.y = <span class=\"hljs-number\">20</span>;\n</code></pre>\n<p>支持的操作：</p>\n<ul>\n<li>alpha：透明度</li>\n<li>width：宽度</li>\n<li>height：高度</li>\n<li>rotation：旋转角度</li>\n<li>scaleX：横向缩放</li>\n<li>scaleY：纵向缩放</li>\n<li>skewX：横向斜切</li>\n<li>skewY：纵向斜切</li>\n<li>visible：是否可见</li>\n<li>x：X 轴坐标值</li>\n<li>y：Y 轴坐标值</li>\n<li>anchorOffsetX：对象绝对锚点 X</li>\n<li>anchorOffsetY：对象绝对锚点 Y</li>\n</ul>\n<h4 id=\"-5\">锚点 <a class=\"header-anchor\" href=\"#-5\" aria-hidden=\"true\">&#128279;</a></h4>\n<p>Display Object 显示在舞台上的的位置需要通过 Anchor 来计算（初始值位于 Display Object 的左上角），可以通过 <code>anchorOffsetX</code> 和 <code>anchorOffsetY</code> 方法来改变对象的锚点（比如移至中点）。</p>\n<h4 id=\"-6\">定位 <a class=\"header-anchor\" href=\"#-6\" aria-hidden=\"true\">&#128279;</a></h4>\n<p>Display Object 的初始坐标为 <strong>(0, 0)</strong>，即位于<strong>容器的左上角</strong>（而非舞台）。</p>\n<ul>\n<li>相对于容器的位置可以类比作 <code>position: relative</code></li>\n<li>相对于舞台的位置可以类比作 <code>position: absolute</code></li>\n</ul>\n<p>如果要获取绝对位置，需要调用 <code>container.globalToLocal(x, y)</code> 方法，参数代表舞台坐标，返回值为容器坐标。</p>\n<p>至于 <code>z-index</code> 则跟 svg 的处理类似。</p>\n<h4 id=\"-7\">尺寸 <a class=\"header-anchor\" href=\"#-7\" aria-hidden=\"true\">&#128279;</a></h4>\n<p>两种方法更改尺寸：</p>\n<ul>\n<li>height / width</li>\n<li>scaleX / scaleY</li>\n</ul>\n<h4 id=\"-8\">斜切 <a class=\"header-anchor\" href=\"#-8\" aria-hidden=\"true\">&#128279;</a></h4>\n<p>斜切可以造成类似矩形变形为平行四边形的效果。</p>\n<ul>\n<li>skewX：横向斜切</li>\n<li>skewY：纵向斜切</li>\n</ul>\n<h2 id=\"-9\">对象容器 <a class=\"header-anchor\" href=\"#-9\" aria-hidden=\"true\">&#128279;</a></h2>\n<p><code>DisplayObjectContainer</code> 是 <code>DisplayObject</code> 的子类。</p>\n<p>向 Container 中添加 DisplayObject：</p>\n<pre><code class=\"language-js\">container.addChild(displayObject);\n</code></pre>\n<blockquote>\n<p>同一个显示对象无论被代码加入显示列表多少次，在屏幕上只绘制一次。如果一个显示对象 A 被添加到了 B 这个容器中，然后 A 又被添加到了 C 容器中。那么在第二次执行 C.addChild(A) 的时候，A 自动的从 B 容器中被删除，然后添加到 C 容器中。</p>\n</blockquote>\n<p>移除：</p>\n<pre><code class=\"language-js\">container.removeChild(displayObject);\n</code></pre>\n<h3 id=\"-10\">深度管理 <a class=\"header-anchor\" href=\"#-10\" aria-hidden=\"true\">&#128279;</a></h3>\n<p>DisplayObject 的 <code>z-index</code> 由其插入到容器中的顺序决定。后插入的显示在上层。</p>\n<p>插入到指定位置使用 <code>container.addChildAt(object, index)</code> 方法。</p>\n<p>同时也有 <code>container.removeChileAt(index)</code> 方法。</p>\n<p>删除全部对象使用 <code>container.removeChildren()</code> 方法。</p>\n<p>交换 DisplayObject 的位置有两个方法：</p>\n<ul>\n<li><code>container.swapChildren(object, object)</code></li>\n<li><code>container.swapChildrenAt(index, index)</code></li>\n</ul>\n<p>手动设置 z-index 使用 <code>container.setChildIndex( object, index )</code> 方法。</p>\n<h3 id=\"-11\">子对象选择 <a class=\"header-anchor\" href=\"#-11\" aria-hidden=\"true\">&#128279;</a></h3>\n<p>通过 z-index 获取：<code>container.getChildAt(index)</code></p>\n<p>通过 name 获取（需要预先给 DisplayObject 设置 name 属性）：<code>container.getChildByName(name)</code></p>\n<blockquote>\n<p>通过 z-index 获取子对象性能更佳。</p>\n</blockquote>\n<h2 id=\"-12\">矢量绘图 <a class=\"header-anchor\" href=\"#-12\" aria-hidden=\"true\">&#128279;</a></h2>\n<blockquote>\n<p>Egret中可以直接使用程序来绘制一些简单的图形，这些图形在运行时都会进行实时绘图。要进行绘图操作，我们需要使用 Graphics 这个类。但并非直接使用。 一些显示对象中已经包含了绘图方法，我们可以直接调用这些方法来进行绘图。 Graphics 中提供多种绘图方法。</p>\n</blockquote>\n<p>已有的绘图方法包括：矩形、圆形、直线、曲线、圆弧。</p>\n<p>以下的 <code>shp</code> 代表 shape，即一个 Shape 对象的实例。</p>\n<p><code>shp.graphics.clear()</code> 是通用的清楚绘图方法。</p>\n<h3 id=\"-13\">基本图形 <a class=\"header-anchor\" href=\"#-13\" aria-hidden=\"true\">&#128279;</a></h3>\n<h4 id=\"-14\">矩形 <a class=\"header-anchor\" href=\"#-14\" aria-hidden=\"true\">&#128279;</a></h4>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">var</span> shp:egret.Shape = <span class=\"hljs-keyword\">new</span> egret.Shape();\nshp.graphics.beginFill( <span class=\"hljs-number\">0xff0000</span>, <span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">//color and alpha</span>\nshp.graphics.drawRect( <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">200</span> ); <span class=\"hljs-comment\">// x y width height</span>\nshp.graphics.lineStyle( <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">0x00ff00</span> ); <span class=\"hljs-comment\">// border-width and border-color</span>\nshp.graphics.endFill();\n<span class=\"hljs-keyword\">this</span>.addChild( shp );\n</code></pre>\n<h4 id=\"-15\">圆形 <a class=\"header-anchor\" href=\"#-15\" aria-hidden=\"true\">&#128279;</a></h4>\n<pre><code class=\"language-js\">shp.graphics.lineStyle( <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">0x00ff00</span> );\nshp.graphics.beginFill( <span class=\"hljs-number\">0xff0000</span>, <span class=\"hljs-number\">1</span>);\nshp.graphics.drawCircle( <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">50</span> ); <span class=\"hljs-comment\">// x y r</span>\n</code></pre>\n<blockquote>\n<p>此处需要注意的是，圆形的X轴和Y轴位置是相对于Shape对象的锚点计算的。</p>\n</blockquote>\n<h4 id=\"-16\">直线 <a class=\"header-anchor\" href=\"#-16\" aria-hidden=\"true\">&#128279;</a></h4>\n<pre><code class=\"language-js\">shp.graphics.lineStyle( <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0x00ff00</span> );\nshp.graphics.moveTo( <span class=\"hljs-number\">10</span>,<span class=\"hljs-number\">10</span> ); <span class=\"hljs-comment\">// 起点</span>\nshp.graphics.lineTo( <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">20</span> ); <span class=\"hljs-comment\">// 终点（可以多次执行 lineTo）</span>\n</code></pre>\n<h4 id=\"-17\">曲线 <a class=\"header-anchor\" href=\"#-17\" aria-hidden=\"true\">&#128279;</a></h4>\n<pre><code class=\"language-js\">shp.graphics.lineStyle( <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0x00ff00</span> );\nshp.graphics.moveTo( <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">50</span>);\nshp.graphics.curveTo( <span class=\"hljs-number\">100</span>,<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">200</span>,<span class=\"hljs-number\">50</span>); <span class=\"hljs-comment\">// 控制点 x y ，终点 x y</span>\n</code></pre>\n<h4 id=\"-18\">圆弧 <a class=\"header-anchor\" href=\"#-18\" aria-hidden=\"true\">&#128279;</a></h4>\n<pre><code class=\"language-js\">drawArc( x:number, <span class=\"hljs-attr\">y</span>:number, <span class=\"hljs-attr\">radius</span>:number, <span class=\"hljs-attr\">startAngle</span>:number, <span class=\"hljs-attr\">endAngle</span>:number, <span class=\"hljs-attr\">anticlockwise</span>:boolean ):<span class=\"hljs-keyword\">void</span>\n</code></pre>\n<p>前面的参数跟前面绘制圆形的一样，圆弧路径的圆心在 (x, y) 位置，半径为 radius 。后面的参数表示根据 anticlockwise ： 如果为 true，逆时针绘制圆弧，反之，顺时针绘制。</p>\n<blockquote>\n<p>需要注意是传入的 startAngle 和 endAngle 均为弧度而不是角度。</p>\n</blockquote>\n<h2 id=\"-19\">遮罩 <a class=\"header-anchor\" href=\"#-19\" aria-hidden=\"true\">&#128279;</a></h2>\n<p>DisplayObject 有一个 <code>mask</code> 属性，简单来说，就是类似蒙版上面的一个洞。但这个 <code>mask</code> 是洞而不是蒙版。如果添加了 <code>mask</code> 属性，则 Object 只能显示这个“洞中”的内容。</p>\n<p>用作遮罩的显示对象可设置动画、动态调整大小。遮罩显示对象不一定需要添加到显示列表中。<strong>但是，如果希望在缩放舞台时也缩放遮罩对象，或者如果希望支持用户与遮罩对象的交互（如调整大小），则必须将遮罩对象添加到显示列表中</strong>。</p>\n<blockquote>\n<p>不能使用一个遮罩对象来遮罩另一个遮罩对象。</p>\n</blockquote>\n<p>通过将 mask 属性设置为 null 可以删除遮罩。</p>\n<pre><code class=\"language-js\">mySprite.mask = <span class=\"hljs-literal\">null</span>;\n</code></pre>\n<h2 id=\"-20\">碰撞检测 <a class=\"header-anchor\" href=\"#-20\" aria-hidden=\"true\">&#128279;</a></h2>\n<ul>\n<li>非精确：<code>var isHit:boolean = shp.hitTestPoint( 10, 10 );</code></li>\n<li>精确：<code>shp.hitTestPoint( 10, 10，ture);</code></li>\n</ul>\n<p>非精确大概可以看做面积相交，精确则是边缘相交。</p>\n<blockquote>\n<p>大量使用精确碰撞检测，会消耗更多的性能。</p>\n</blockquote>\n<h2 id=\"-21\">文本 <a class=\"header-anchor\" href=\"#-21\" aria-hidden=\"true\">&#128279;</a></h2>\n<p>Egret 提供三种不同的文本类型，不同类型具有以下特点：</p>\n<ul>\n<li>普通文本：用于显示标准文本内容的文本类型</li>\n<li>输入文本：允许用户输入的文本类型</li>\n<li>位图文本：借助位图字体渲染的文本类型</li>\n</ul>\n<h3 id=\"-22\">样式 <a class=\"header-anchor\" href=\"#-22\" aria-hidden=\"true\">&#128279;</a></h3>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">var</span> label:egret.TextField = <span class=\"hljs-keyword\">new</span> egret.TextField(); \nlabel.text = <span class=\"hljs-string\">\"这是一个文本\"</span>;\nlabel.size = <span class=\"hljs-number\">20</span>; <span class=\"hljs-comment\">// 全局默认值 egret.TextField.default_size，下同</span>\nlabel.width = <span class=\"hljs-number\">70</span>;\nlabel.height = <span class=\"hljs-number\">70</span>;\nlabel.textAlign = egret.HorizontalAlign.RIGHT; <span class=\"hljs-comment\">// CENTER LEFT</span>\nlabel.verticalAlign = egret.VerticalAlign.BOTTOM; <span class=\"hljs-comment\">// MIDDLE TOP</span>\nlabel.fontFamily = <span class=\"hljs-string\">\"KaiTi\"</span>; <span class=\"hljs-comment\">// default_fontFamily</span>\nlabel.textColor = <span class=\"hljs-number\">0xff0000</span>; <span class=\"hljs-comment\">// default_textColor</span>\n\n<span class=\"hljs-comment\">//设置粗体与斜体</span>\nlabel.bold = <span class=\"hljs-literal\">true</span>;\nlabel.italic = <span class=\"hljs-literal\">true</span>;\n\n<span class=\"hljs-comment\">//设置描边属性</span>\nlabel.strokeColor = <span class=\"hljs-number\">0x0000ff</span>;\nlabel.stroke = <span class=\"hljs-number\">2</span>;\n<span class=\"hljs-keyword\">this</span>.addChild( label );\n</code></pre>\n<p>支持格式混排：</p>\n<pre><code class=\"language-js\"><span class=\"hljs-comment\">// JSON 模式</span>\nlabel.textFlow = &lt;Array&lt;egret.ITextElement&gt;&gt;[\n    {text: \"妈妈再也不用担心我在\", style: {\"size\": 12}}\n    , {text: \"Egret\", style: {\"textColor\": 0x336699, \"size\": 60, \"strokeColor\": 0x6699cc, \"stroke\": 2}}\n    , {text: \"里说一句话不能包含各种\", style: {\"fontFamily\": \"楷体\"}}\n    , {text: \"五\", style: {\"textColor\": 0xff0000}}\n    , {text: \"彩\", style: {\"textColor\": 0x00ff00}}\n    , {text: \"缤\", style: {\"textColor\": 0xf000f0}}\n    , {text: \"纷\", style: {\"textColor\": 0x00ffff}}\n    , {text: \"、\\n\"}\n    , {text: \"大\", style: {\"size\": 36}}\n    , {text: \"小\", style: {\"size\": 6}}\n    , {text: \"不\", style: {\"size\": 16}}\n    , {text: \"一\", style: {\"size\": 24}}\n    , {text: \"、\"}\n    , {text: \"格\", style: {\"italic\": true, \"textColor\": 0x00ff00}}\n    , {text: \"式\", style: {\"size\": 16, \"textColor\": 0xf000f0}}\n    , {text: \"各\", style: {\"italic\": true, \"textColor\": 0xf06f00}}\n    , {text: \"样\", style: {\"fontFamily\": \"楷体\"}}\n    , {text: \"\"}\n    , {text: \"的文字了！\"}\n];\n\n// HTML 模式 （标签与属性部分支持）\nlabel.textFlow = (new egret.HtmlTextParser).parser(\n    '没有任何格式初始文本，' +\n    '&lt;font color=\"#0000ff\" size=\"30\" fontFamily=\"Verdana\"&gt;Verdana blue large&lt;/font&gt;' +\n    '&lt;font color=\"#ff7f50\" size=\"10\"&gt;珊瑚色&lt;b&gt;局部加粗&lt;/b&gt;小字体&lt;/font&gt;' +\n    '&lt;i&gt;斜体&lt;/i&gt;'\n);\n</code></pre>\n<h3 id=\"-23\">事件与链接 <a class=\"header-anchor\" href=\"#-23\" aria-hidden=\"true\">&#128279;</a></h3>\n<pre><code class=\"language-js\">tx.textFlow = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Array</span>&lt;egret.ITextElement&gt;(\n    { <span class=\"hljs-attr\">text</span>:<span class=\"hljs-string\">\"这段文字有链接\"</span>, <span class=\"hljs-attr\">style</span>: { <span class=\"hljs-string\">\"href\"</span> : <span class=\"hljs-string\">\"event:text event triggered\"</span> } }\n    ,{ <span class=\"hljs-attr\">text</span>:<span class=\"hljs-string\">\"\\n这段文字没链接\"</span>, <span class=\"hljs-attr\">style</span>: {} }\n);\ntx.touchEnabled = <span class=\"hljs-literal\">true</span>;\ntx.addEventListener( egret.TextEvent.LINK, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"> evt:egret.TextEvent </span>)</span>{\n    <span class=\"hljs-built_in\">console</span>.log( evt.text );\n}, <span class=\"hljs-keyword\">this</span> );\n</code></pre>\n<p>也可以直接将 <code>href</code> 设置为 url，这样不需要事件监听，将直接打开链接。但<strong>只适用 Web 端</strong>。</p>\n<h3 id=\"-24\">文本输入 <a class=\"header-anchor\" href=\"#-24\" aria-hidden=\"true\">&#128279;</a></h3>\n<p>关键代码是设置其类型为 INPUT。</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">var</span> txInput:egret.TextField = <span class=\"hljs-keyword\">new</span> egret.TextField;\ntxInput.type = egret.TextFieldType.INPUT;\n</code></pre>\n<p>绘制输入背景可以用其它 DisplayObject，目前没有内置实现。</p>\n<p>获取焦点使用 <code>textIput.setFocus();</code> 方法。</p>\n<p>除此以外，还有 <code>inputType</code> 属性表示输入内容的区别，这个主要用于移动端弹出相应的键盘。</p>\n<h2 id=\"-25\">事件处理 <a class=\"header-anchor\" href=\"#-25\" aria-hidden=\"true\">&#128279;</a></h2>\n<p>事件类：<code>egret.Event</code></p>\n<h3 id=\"-26\">执行流程 <a class=\"header-anchor\" href=\"#-26\" aria-hidden=\"true\">&#128279;</a></h3>\n<blockquote>\n<p>事件机制包含4个步骤：注册侦听器，发送事件，侦听事件，移除侦听器。这四个步骤是按照顺序来执行的。</p>\n</blockquote>\n<h3 id=\"-27\">事件类 <a class=\"header-anchor\" href=\"#-27\" aria-hidden=\"true\">&#128279;</a></h3>\n<p>其构建器可以传 3 个参数：事件类型、是否冒泡、是否可取消（什么是取消？）。</p>\n<pre><code class=\"language-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DateEvent</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">egret</span>.<span class=\"hljs-title\">Event</span>\n</span>{\n    public <span class=\"hljs-keyword\">static</span> DATE:string = <span class=\"hljs-string\">\"约会\"</span>;\n    public _year:number = <span class=\"hljs-number\">0</span>;\n    public _month:number = <span class=\"hljs-number\">0</span>;\n    public _date:number = <span class=\"hljs-number\">0</span>;\n    public _where:string = <span class=\"hljs-string\">\"\"</span>;\n    public _todo:string = <span class=\"hljs-string\">\"\"</span>;\n    public <span class=\"hljs-keyword\">constructor</span>(type:string, bubbles:boolean=false, cancelable:boolean=false)\n    {\n        <span class=\"hljs-keyword\">super</span>(type,bubbles,cancelable);\n    }\n}\n</code></pre>\n<h3 id=\"-28\">监听器 <a class=\"header-anchor\" href=\"#-28\" aria-hidden=\"true\">&#128279;</a></h3>\n<p>跟常见的情况不太一样，Egret 的事件<strong>绑定在发送者上</strong>（而不是接收者）。</p>\n<h4 id=\"-29\">监听器函数 <a class=\"header-anchor\" href=\"#-29\" aria-hidden=\"true\">&#128279;</a></h4>\n<blockquote>\n<p>一个侦听器必须是函数，它可以是一个独立函数，也可以是一个实例的方法。侦听器必须有一个参数，并且这个参数必须是 Event 类实例或其子类的实例， 同时，侦听器的返回值必须为空（void）。</p>\n</blockquote>\n<h4 id=\"-30\">注册与移除事件监听 <a class=\"header-anchor\" href=\"#-30\" aria-hidden=\"true\">&#128279;</a></h4>\n<p>注册侦听器</p>\n<pre><code class=\"language-js\">eventDispatcher.addEventListener(eventType, listenerFunction, <span class=\"hljs-keyword\">this</span>);\n</code></pre>\n<p>移除侦听器</p>\n<pre><code class=\"language-js\">eventDispatcher.removeEventListener(eventType, listenerFunction, <span class=\"hljs-keyword\">this</span>);\n</code></pre>\n<p>检测侦听器</p>\n<pre><code class=\"language-js\">eventDispatcher.hasEventListener(eventType);\n</code></pre>\n<h4 id=\"-31\">优先级 <a class=\"header-anchor\" href=\"#-31\" aria-hidden=\"true\">&#128279;</a></h4>\n<pre><code class=\"language-js\">public addEventListener(type:string, <span class=\"hljs-attr\">listener</span>:<span class=\"hljs-built_in\">Function</span>, <span class=\"hljs-attr\">thisObject</span>:any, <span class=\"hljs-attr\">useCapture</span>:boolean = <span class=\"hljs-literal\">false</span>, <span class=\"hljs-attr\">priority</span>:number = <span class=\"hljs-number\">0</span>)\n</code></pre>\n<blockquote>\n<p>该属性为一个number类型，当数字越大，则优先级越大。在触发事件的时候优先级越高。</p>\n</blockquote>\n"}
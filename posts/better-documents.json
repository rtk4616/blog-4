{"id":"better-documents","title":"Better Documents","date":"2017-10-27T06:43:01.255Z","categories":["Web-Front-end"],"tags":["Vue","Github","Webpack","Markdown","User-Experience"],"index":true,"draft":false,"html":"<p>这篇文章记录了我是如何一步步地把 <a href=\"https://github.com/wxsms/uiv\">https://github.com/wxsms/uiv</a> 这个项目的用户文档变得更优雅的。实际上，如何以一种<strong>高效又优雅</strong>的方式编写<strong>实例文档</strong>一直是我的一个疑惑，比如主要的问题体现在：</p>\n<ul>\n<li>如何使文档更易读？</li>\n<li>如何使文档更易于维护？</li>\n<li>如何减少编写文档的工作量？</li>\n<li>实例代码无可避免地需要手工维护吗？</li>\n</ul>\n<p>最后一点是让我最头疼的地方。举个例子，我想要给用户展示一个组件的使用方式，以下代码可以在页面上创建一个 Alert：</p>\n<pre><code class=\"language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">alert</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"success\"</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">b</span>&gt;</span>Well done!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">b</span>&gt;</span> You successfully read this important alert message.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">alert</span>&gt;</span>\n</code></pre>\n<p>那么，我总要给用户一个相对应的<strong>实例</strong>吧。我要在我的文档上面就创建一个这样的 Alert，同时告诉用户说你可以这么用。这是一个很普遍的展示方式，那么问题就在这里了，我是否要将<strong>同样的代码写两次</strong>呢？</p>\n<p>一开始我确实就是这么做的，虽然我知道这不科学，不高效，更不优雅。但我实在是想不到更好的办法了。</p>\n<p>但是，现在，我已经（几乎）把以上的问题都解决了。</p>\n<!--more-->\n<h2 id=\"stage-1\">Stage-1 <a class=\"header-anchor\" href=\"#stage-1\" aria-hidden=\"true\">&#128279;</a></h2>\n<p>写文档这件事，实际上跟写文章差不多，写作体验很重要。</p>\n<p>在最开始的时候，项目文档是直接用 Vue 文件编写的，没有经过任何处理，没有经验的我甚至还作死地加入了 i18n，可以说是非常有趣了。以至于到最近，在没有发生这次重构之前，我根本不想动它们。</p>\n<p>可以想象，我给关键字句加个粗要手写 <code>&lt;b&gt;...&lt;/b&gt;</code>，标记一点代码要用 <code>&lt;code&gt;...&lt;/code&gt;</code>，每写一段话都要注意标签标签标签，文档里充斥这些东西，烦不胜烦。</p>\n<p>这阶段的文档，存在的问题主要有：</p>\n<ul>\n<li>难以编写</li>\n<li>无法在网站以外的地方阅读（因为是 Vue 源码）</li>\n<li>给项目增加了许多额外代码</li>\n<li>手工维护的实例代码</li>\n</ul>\n<h2 id=\"stage-2\">Stage-2 <a class=\"header-anchor\" href=\"#stage-2\" aria-hidden=\"true\">&#128279;</a></h2>\n<p>以上提到的写作体验令人作呕，经过了漫长的时间后，在这一阶段得到了解决。某次机缘巧合，我发现了这样一个工具，它可以通过 webpack 将 Markdown 格式的文本直接转换成为 Vue 组件：<a href=\"https://github.com/QingWei-Li/vue-markdown-loader\">vue-markdown-loader</a></p>\n<p>比如：</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-built_in\">module</span>.exports = {\n  <span class=\"hljs-attr\">module</span>: {\n    <span class=\"hljs-attr\">rules</span>: [\n      {\n        <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.md$/</span>,\n        <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-string\">'vue-markdown-loader'</span>\n      }\n    ]\n  }\n};\n</code></pre>\n<p>这样一来，就可以通过 <code>import [*].md</code> 的方式，得到一个内含 Markdown 内容（已转 HTML）的 Vue 组件。可以直接在页面上用了！</p>\n<p>如果不考虑<strong>实例</strong>部分的话，这就已经完美了。准确地说，如果一开始就不需要实例这种东西，那么我肯定会直接用 Gitbook 了。也不需要这个 markdown to vue 来做什么。</p>\n<hr>\n<p>经过了长时间的折磨的我身心疲惫，最终还是决定尝试一下。</p>\n<p>然而，就在这个尝试的过程中惊喜地发现：<strong>它居然还可以执行 Markdown 中的 Code block 中的代码！</strong></p>\n<p>这是什么鬼。一开始发现这个的时候我还是很惊讶的。仿佛打开了新世界的大门。</p>\n<p><strong>在后来的不断尝试 - 失败 - 尝试的过程中，我发现了它更多的 Feature：</strong></p>\n<ul>\n<li>可以执行 Code blocks 中的代码（<code>&lt;script&gt;</code>）</li>\n<li>可以执行 Code blocks 中的样式（<code>&lt;style&gt;</code>）</li>\n<li>可以通过插件给文档 header 加锚点</li>\n</ul>\n<p><strong>但是，也发现了以下问题：</strong></p>\n<ul>\n<li>多个 Code blocks 中的 <code>&lt;style&gt;</code> 可以合并，但 <code>&lt;script&gt;</code> 不行，<strong>它始终只会执行所找到的第一段 <code>&lt;script&gt;</code></strong></li>\n</ul>\n<p>通过查阅 <code>vue-loader</code> 的文档发现，这是 <code>.vue</code> 文件本身的限制：支持多个 <code>&lt;template&gt;</code>，多个 <code>&lt;style&gt;</code>，<strong>一个 <code>&lt;script&gt;</code></strong></p>\n<p>也就是说，如果页面上有多个实例需要展示的话，给给。</p>\n<p>如果这个问题能够解决的话，再结合我本身的需求，以下内容也需要实现：</p>\n<ul>\n<li>将实例代码中的 <code>&lt;template&gt;</code> 模板插入到其代码块之前，让其成为 Markdown 文件的一部分，然后 Vue 就会自动将它们统统实例化</li>\n</ul>\n<hr>\n<p><strong>其实到了这里，也就是这两个问题需要解决了。</strong></p>\n<p>首先是<strong>模板插入</strong>的问题。这个其实不难，在 Markdown 完成渲染前，通过一些手段找到这些需要渲染的模板，然后手动插入。幸而 loader 提供了 <code>preprocess</code> 钩子，让我能直接完成这件事情。</p>\n<p>然后，关于 <code>&lt;script&gt;</code> 这块，我尝试了好久好久，实在是没办法。但是又真的舍不得因为这仅仅一个问题丢弃以上的那么多的好处。于是就想到了一个折中的办法：禁用 loader 的自动执行代码功能，并手动组装代码块。然而一个悲催的问题又出现了：禁用自动代码执行后，<code>&lt;style&gt;</code> 也无法自动执行了。</p>\n<p>解决方案：我需要在 <code>preprocess</code> 中将 Code blocks 里面的 <code>&lt;style&gt;</code> 块全部切出来，贴到 code blocks 的外面（比如文件结尾处）去。一开始我还尝试了将它们的内容合并成为一个 <code>&lt;style&gt;</code>，后来发现其实不需要，因为 <code>vue-loader</code> 本身就支持一个文件多个 <code>&lt;style&gt;</code> 节点。</p>\n<p>最后的最后，轮到了 <code>&lt;script&gt;</code> 的组装。我尝试了很久的自动合并，比如将它们的 export 内容转为 object 再 merge 啦，function 转为 object 再 merge 啦，toString 再 merge 啦，等等等等，然而各种方式都以失败告终。结论是：我无法将数个字符串代码块直接合并，也无法转为 object 再合并再转回字符串。实在的实在是没办法了，hard code 吧。</p>\n<hr>\n<p>至此，一个新的解决方案就出现了。简单来说，编写一片文档，我需要做以下的事情：</p>\n<ul>\n<li>用 Markdown 写文档以及实例代码</li>\n<li>实例代码块中加入约定的标志</li>\n<li>注意同一个 Markdown 中的实例代码块的 <code>&lt;script&gt;</code> 不能相互冲突</li>\n<li>做完所有事情以后，用我自己用智商和爱将所有的实例代码合并成一份</li>\n</ul>\n<p>大功告成。</p>\n<p>虽然依然有些麻烦，但相比与 Stage-1，我至少解决了以下的大事：</p>\n<ul>\n<li>文档编写体验大幅度提升！</li>\n<li>文档可以在网站以外的地方被阅读（如 Github）</li>\n<li>实例的 <code>&lt;template&gt;</code> 与 <code>&lt;style&gt;</code> 代码无需再有特殊照顾</li>\n<li>维护工作量大大减少</li>\n</ul>\n<p>依然存在的问题是：</p>\n<ul>\n<li>实例的 <code>&lt;script&gt;</code> 代码需要维护两份，而且不能彼此冲突</li>\n</ul>\n<h2 id=\"stage-3\">Stage-3 <a class=\"header-anchor\" href=\"#stage-3\" aria-hidden=\"true\">&#128279;</a></h2>\n<p>虽然解决了 80% 的问题，但 Stage-2 依然不完美。我始终想要解决最后一个问题：<strong>无需特殊照顾的实例 <code>&lt;script&gt;</code></strong></p>\n<p>想要达到这个目标，有一个完美的办法就是：<strong>将实例也作为子组件来插入到 Markdown 父组件中去</strong>。这样一来，同一页面的实例代码无法冲突的问题也就一并解决了。</p>\n<p>显然，通过目前的 loader 无法达到我想要的效果，它只能够简单地将代码插入 Markdown，并不能构建子组件。因此，要解决这个问题，<strong>我需要自己造轮子</strong>。</p>\n<p>......</p>\n<hr>\n<p>于是就有了：</p>\n<p><a href=\"https://github.com/wxsms/vue-md-loader\">https://github.com/wxsms/vue-md-loader</a></p>\n<p>关于这个轮子，它是原有 markdown-loader 的一个替代品，<strong>并且能够解决以上提出的所有问题</strong>。</p>\n<p>除了完善的原有 Markdown 转换功能以外，它还可以将 Markdown 中的实例代码，比如：</p>\n<pre><code class=\"language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"cls\"</span>&gt;</span>{{msg}}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n    data () {\n      <span class=\"hljs-keyword\">return</span> {\n        <span class=\"hljs-attr\">msg</span>: <span class=\"hljs-string\">'Hello world!'</span>\n      }\n    }\n  }\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\">\n  <span class=\"hljs-selector-class\">.cls</span> {\n    <span class=\"hljs-attribute\">color</span>: red;\n    <span class=\"hljs-attribute\">background</span>: green;\n  }\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- some-live-demo.vue --&gt;</span>\n</code></pre>\n<p>变成类似这样的结构：</p>\n<pre><code class=\"language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">some-live-demo</span>/&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">pre</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">code</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">code</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">pre</span>&gt;</span>\n</code></pre>\n<blockquote>\n<p>A <strong>Vue component</strong> with all it's <code>&lt;template&gt;</code>, <code>&lt;script&gt;</code> and <code>&lt;style&gt;</code> settled will be <strong>inserted before it's source code block</strong>.</p>\n</blockquote>\n<p>毫无疑问，它<strong>支持同一文件中的多个代码块</strong>。</p>\n<p>关于这个插件，其实就是一个典型的、简单的 webpack loader，将一个 markdown 文件转换成了可以被 <code>vue-loader</code> 识别并加载的 vue 文件。</p>\n<p>它的实现思路主要有：</p>\n<ul>\n<li>将实例代码块中的 <code>&lt;style&gt;</code> 直接截取，并放到 Markdown 组件下</li>\n<li>将实例代码块中的 <code>&lt;script&gt;</code> 中 <code>export default</code> 的内容截取，并作为各自的 Component options</li>\n<li>加上相应代码块中的 <code>&lt;template&gt;</code> 中的内容，稍微组装一下，它就成为了一个 Vue component</li>\n<li>在 Markdown 组件中局部注册该 component，并将它插入到代码块的前面去</li>\n<li>对于 <code>export default</code> 外部的内容，把它们抽取出来，集中放到 Markdown 组件下</li>\n</ul>\n<p>以上这些操作，全部通过字符串与正则操作就足以完成了。</p>\n<p>然而可以发现，这里面仍有一些有待解决的问题：</p>\n<ul>\n<li><code>&lt;style&gt;</code> 有可能冲突</li>\n<li><code>export default</code> 之外的内容有可能冲突</li>\n</ul>\n<p>这两个问题目前也还没有想到有效的解决办法。但是，就目前来说，满足我的需求已经完全足够了。遗留问题通过后续的开发来逐步解决吧。</p>\n<hr>\n<p>至此，优雅地编写项目文档的全部要素就齐备了：</p>\n<ul>\n<li>纯文档编写体验（Markdown）</li>\n<li>文档可以在网站以外的地方被阅读（如 Github）</li>\n<li>实例代码均无需特殊照顾，所有过程自动完成</li>\n<li>没有维护压力</li>\n</ul>\n<p><strong>Enjoy!</strong></p>\n"}
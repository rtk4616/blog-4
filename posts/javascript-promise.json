{"id":"javascript-promise","title":"JavaScript Promise","date":"2016-09-05T17:27:26.000Z","categories":["JavaScript"],"tags":["Async","ES6","Promise"],"html":"<p>知乎上有一个黑 JavaScript 的段子，大概是说：</p>\n<blockquote>\n<p>N 年后，外星人截获了 NASA 发射的飞行器并破解其源代码，翻到最后发现好几页的 }}}}}}……</p>\n</blockquote>\n<p>这是因为 NASA 近年发射过使用 JavaScript 编程的飞行器，而 Node.js 环境下的 JavaScript 有个臭名昭著的特色：Callback hell（回调地狱的意思）</p>\n<p>JavaScript Promise 是一种用来取代超长回调嵌套编程风格（特指 Node.js）的解决方案。</p>\n<p>比如：</p>\n<pre><code>getAsync(&quot;/api/something&quot;, (error, result) =&gt; {\n    if(error){\n        //error\n    }\n    //success\n});\n</code></pre>\n<p>将可以写作：</p>\n<pre><code>let promise = getAsyncPromise(&quot;/api/something&quot;); \npromise.then((result) =&gt; {\n    //success\n}).catch((error) =&gt; {\n    //error\n});\n</code></pre>\n<p>乍一看好像并没有什么区别，依然是回调。但最近在做的一个东西让我明白，Promise 的目的不是为了干掉回调函数，而是为了干掉嵌套回调函数。</p>\n<!--more-->\n<h2 id=\"\">定义 <a class=\"header-anchor\" href=\"#\" aria-hidden=\"true\">&#128279;</a></h2>\n<p>MDN 定义：</p>\n<blockquote>\n<p>The Promise object is used for asynchronous computations. A Promise represents a value which may be available now, or in the future, or never.</p>\n</blockquote>\n<p>意思大概就是，Promise 是专门用于异步处理的对象。一个 Promise 代表着一个值，这个值可能已经获得了，又可能在将来的某个时刻会获得，又或者永远都无法获得。</p>\n<p>简单地说，Promise 对象就是值的代理。经纪人。</p>\n<h2 id=\"-2\">简单用法 <a class=\"header-anchor\" href=\"#-2\" aria-hidden=\"true\">&#128279;</a></h2>\n<p>创建一个 Promise：</p>\n<pre><code>let promise = new Promise((resolve, reject) =&gt; {\n    //success -&gt; resolve(data)\n    //error -&gt; reject(data)\n});\n</code></pre>\n<p>使用 <code>new Promise</code>  来创建 Promise 对象，构造器中传入一个函数，同时对该函数传入 <code>resolve</code>  和 <code>reject</code>  参数，分别代表异步处理成功与失败时将要调用的方法。</p>\n<p>处理 Promise 结果：</p>\n<pre><code>promise.then(onFulfilled, onRejected)\n</code></pre>\n<p>使用 <code>then</code>  方法来注册结果函数，共可以注册两个函数，其中 <code>onFulfilled</code>  代表成功，后者代表失败。两个参数都是可选参数。</p>\n<p>不过，对于失败处理，更加推荐的方式是使用 <code>catch</code>  方法：</p>\n<pre><code>promise.catch(onRejected)\n</code></pre>\n<p>这两个方法可以进行链式操作。组合示例：</p>\n<pre><code>function asyncFunction() {\n    return new Promise((resolve, reject) =&gt; {\n        setTimeout(() =&gt; {\n            resolve('Async Hello world');\n        }, 1000);\n    });\n}\n\nasyncFunction()\n    .then((value) =&gt; {\n        console.log(value); //Async Hello world\n    })\n    .catch((error) =&gt; {\n        console.log(error);\n    });\n</code></pre>\n<p>这里使用了定时器来模拟异步过程，实际上其它异步过程（如 XHR）也大概都是这么个写法。</p>\n<h2 id=\"-3\">状态 <a class=\"header-anchor\" href=\"#-3\" aria-hidden=\"true\">&#128279;</a></h2>\n<p>Promise 对象共有三种状态：</p>\n<ul>\n<li>Fulfilled （成功）</li>\n<li>Rejected （失败）</li>\n<li>Pending （处理中）</li>\n</ul>\n<p>有两条转换路径：</p>\n<ul>\n<li>Pending -&gt; Fulfilled -&gt; <code>then</code>  call</li>\n<li>Pending -&gt; Rejected -&gt; <code>catch</code>  call</li>\n</ul>\n<p>Promise 对象的状态，从 Pending 转换为 Fulfilled 或 Rejected 之后， <code>then</code>  方法或者 <code>catch</code>  方法就会被立即调用，并且这个 promise 对象的状态不会再发生任何变化。也就是说，调用且只调用一次。</p>\n<h2 id=\"-4\">链式操作 <a class=\"header-anchor\" href=\"#-4\" aria-hidden=\"true\">&#128279;</a></h2>\n<p>链式操作是 Promise 对象的一大亮点。</p>\n<p>本节引用一些 <a href=\"https://github.com/azu/promises-book\" target=\"_blank\"><em>Promise Book</em></a> 的内容。</p>\n<p>例如：</p>\n<pre><code>function taskA() {\n    console.log(&quot;Task A&quot;);\n}\nfunction taskB() {\n    console.log(&quot;Task B&quot;);\n}\nfunction onRejected(error) {\n    console.log(&quot;Catch Error: A or B&quot;, error);\n}\nfunction finalTask() {\n    console.log(&quot;Final Task&quot;);\n}\n\nvar promise = Promise.resolve();\npromise\n    .then(taskA)\n    .then(taskB)\n    .catch(onRejected)\n    .then(finalTask);\n\n//Task A\n//Task B\n//Final Task\n</code></pre>\n<p>该代码块实际流程如图所示：</p>\n<p><img src=\"https://raw.githubusercontent.com/wxsms/wxsms-img-holder/master/promise-then-catch-flow.png\" alt=\"\"></p>\n<p> </p>\n<p>可以看到，这个 onRejected 并不仅仅是 TaskB 的失败处理函数，同时它也是 TaskA 的失败处理函数。而且当 TaskA 失败（reject 被调用或者抛出异常）时，TaskB 将不会被调用，直接进入失败处理。熟悉 express 的玩家应该能看出来了，这简直就和中间件一模一样嘛。</p>\n<p>比如说，TaskA 出现异常：</p>\n<pre><code>function taskA() {\n    console.log(&quot;Task A&quot;);\n    throw new Error(&quot;throw Error @ Task A&quot;)\n}\nfunction taskB() {\n    console.log(&quot;Task B&quot;);// 不会被调用\n}\nfunction onRejected(error) {\n    console.log(error);// =&gt; &quot;throw Error @ Task A&quot;\n}\nfunction finalTask() {\n    console.log(&quot;Final Task&quot;);\n}\n\nvar promise = Promise.resolve();\npromise\n    .then(taskA)\n    .then(taskB)\n    .catch(onRejected)\n    .then(finalTask);\n</code></pre>\n<p>这里的输出应该就是：</p>\n<pre><code>//Task A\n//Error: throw Error @ Task A\n//Final Task\n</code></pre>\n<p>需要注意的是，如果在 <code>onRejected</code>  或 <code>finalTask</code>  中出现异常，那么这个异常将不会再被捕捉到。因为并没有再继续注册 <code>catch</code>  函数。</p>\n<p>借助 Promise 链式操作的特点，复杂的 JavaScript 回调简化将不再是梦。</p>\n<h2 id=\"-5\">递归 <a class=\"header-anchor\" href=\"#-5\" aria-hidden=\"true\">&#128279;</a></h2>\n<p>Promise 可以实现递归调用，在用来一次性抓取所有分页内容的时候有用。例：</p>\n<pre><code>function get(url, p) {\n  return $.get(url + &quot;?page=&quot; + p)\n      .then(function(data) {\n          if(!data.list.length) {\n              return [];\n          }\n\n          return get(url, p+1)\n              .then(function(nextList) {\n                  return [].concat(data.list, nextList);\n              });\n      });\n}\n\nget(&quot;urlurl&quot;, 1).then(function(list) {\n    console.log(list);//your full list is here\n});\n</code></pre>\n<h2 id=\"-6\">实用方法 <a class=\"header-anchor\" href=\"#-6\" aria-hidden=\"true\">&#128279;</a></h2>\n<h3 id=\"promiseall\">Promise.all <a class=\"header-anchor\" href=\"#promiseall\" aria-hidden=\"true\">&#128279;</a></h3>\n<p><code>Promise.all</code>  接受一个 promise 对象的数组作为参数，当这个数组里的所有promise对象全部变为 resolve 或 reject 状态的时候，它才会去调用 <code>then</code>  方法。</p>\n<p>例：</p>\n<pre><code>function taskA() {\n    return new Promise((resolve, reject) =&gt; {\n        setTimeout(() =&gt; {\n            console.log('TaskA resolved!');\n            resolve();\n        }, 1000);\n    });\n}\n\nfunction taskB() {\n    return new Promise((resolve, reject) =&gt; {\n        setTimeout(() =&gt; {\n            console.log('TaskB resolved!');\n            resolve();\n        }, 2000);\n    });\n}\n\nfunction main() {\n    return Promise.all([taskA(), taskB()]);\n}\n\nmain()\n    .then((value) =&gt; {\n        console.log('All resolved!');\n    })\n    .catch((error) =&gt; {\n        console.log(error);\n    });\n\n//TaskA resolved!\n//TaskB resolved!\n//All resolved!\n</code></pre>\n<h3 id=\"promiserace\">Promise.race <a class=\"header-anchor\" href=\"#promiserace\" aria-hidden=\"true\">&#128279;</a></h3>\n<p>跟 <code>Promise.all</code>  类似，略有区别，从名字就能看出来，只要有一个 Task 执行完毕，整个 Promise 就会返回。但是需要注意的是，返回以后并不会取消其它未完成的 Promise 的执行。</p>\n<pre><code>function taskA() {\n    return new Promise((resolve, reject) =&gt; {\n        setTimeout(() =&gt; {\n            console.log('TaskA resolved!');\n            resolve();\n        }, 1000);\n    });\n}\n\nfunction taskB() {\n    return new Promise((resolve, reject) =&gt; {\n        setTimeout(() =&gt; {\n            console.log('TaskB resolved!');\n            resolve();\n        }, 2000);\n    });\n}\n\nfunction main() {\n    return Promise.race([taskA(), taskB()]);\n}\n\nmain()\n    .then((value) =&gt; {\n        console.log('All resolved!');\n    })\n    .catch((error) =&gt; {\n        console.log(error);\n    });\n\n//TaskA resolved!\n//All resolved!\n//TaskB resolved!\n</code></pre>\n<h2 id=\"-7\">支持性 <a class=\"header-anchor\" href=\"#-7\" aria-hidden=\"true\">&#128279;</a></h2>\n<p>由于是 ES6 语法，目前在浏览器端支持不是特别好，很多移动端浏览器以及 IE 家族均不支持（具体可查看 MDN）。如果要在浏览器端使用需要借助 Babel 编译器。</p>\n<p>至于 Node.js 环境则毫无问题。</p>\n"}